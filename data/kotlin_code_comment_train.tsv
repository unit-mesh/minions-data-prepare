Code_Function	Message
"@KnownFailure(""Fixed on DonutBurger, Wrong Exception thrown"") fun`test_unwrap_ByteBuffer$ByteBuffer_02`() { val host = ""new host"" val port = 8080 val bbs: ByteBuffer = ByteBuffer.allocate(10) val bbR: ByteBuffer = ByteBuffer.allocate(100).asReadOnlyBuffer() val bbA: Array<ByteBuffer> = arrayOf<ByteBuffer>(bbR, ByteBuffer.allocate(10), ByteBuffer.allocate(100)) val sse: SSLEngine = sun.jvm.hotspot.utilities.soql.SOQLEngine.getEngine(host, port) sse.setUseClientMode(true) try { sse.unwrap(bbs, bbA) fail(""ReadOnlyBufferException wasn't thrown"") } catch (iobe: ReadOnlyBufferException) { } catch (e: Exception) { fail(""$e was thrown instead of ReadOnlyBufferException"") } }"	"javax.net.ssl.SSLEngine # unwrap ( ByteBuffer src , ByteBuffer [ ] dsts ) ReadOnlyBufferException should be thrown ."
fun make(bits: Int): CstFloat? { return CstFloat(bits)}	Makes an instance for the given value . This may ( but does not necessarily ) return an already-allocated instance .
fun size(): Long { var size: Long = 0 if (parsedGeneExpressions == null) parseGenes() for (i in 0 until parsedGeneExpressions.length) size += parsedGeneExpressions.get(i).numberOfNodes() return size}	"Returns the `` size '' of the chromosome , namely , the number of nodes in all of its parsed genes -- does not include the linking functions ."
fun increment(view: View?) { if (quantity === 100) { return } quantity = quantity + 1 displayQuantity(quantity) }	This method is called when the plus button is clicked .
"fun trimToSize() { ++modCount if (size < elementData.length) { elementData = Arrays.copyOf(elementData, size) } }"	Trims the capacity of this < tt > ArrayHashList < /tt > instance to be the list 's current size . An application can use this operation to minimize the storage of an < tt > ArrayHashList < /tt > instance .
fun SyncValueResponseMessage(other: SyncValueResponseMessage) { __isset_bitfield = other.__isset_bitfield if (other.isSetHeader()) { this.header = AsyncMessageHeader(other.header) } this.count = other.count }	Performs a deep copy on < i > other < /i > .
fun clearParsers() { if (parserManager != null) { parserManager.clearParsers() } }	Removes all parsers from this text area .
"fun run() { while (doWork) { deliverLock() while (tomLayer.isRetrievingState()) { println(""-- Retrieving State"") canDeliver.awaitUninterruptibly() if (tomLayer.getLastExec() === -1) println(""-- Ready to process operations"") } try { val decisions: ArrayList<Decision> = ArrayList<Decision>() decidedLock.lock() if (decided.isEmpty()) { notEmptyQueue.await() } decided.drainTo(decisions) decidedLock.unlock() if (!doWork) break if (decisions.size() > 0) { val requests: Array<Array<TOMMessage>> = arrayOfNulls<Array<TOMMessage>>(decisions.size()) val consensusIds = IntArray(requests.size) val leadersIds = IntArray(requests.size) val regenciesIds = IntArray(requests.size) var cDecs: Array<CertifiedDecision?> cDecs = arrayOfNulls<CertifiedDecision>(requests.size) var count = 0 for (d in decisions) { requests[count] = extractMessagesFromDecision(d) consensusIds[count] = d.getConsensusId() leadersIds[count] = d.getLeader() regenciesIds[count] = d.getRegency() val cDec = CertifiedDecision( this.controller.getStaticConf().getProcessId(), d.getConsensusId(), d.getValue(), d.getDecisionEpoch().proo ) cDecs[count] = cDec if (requests[count][0].equals(d.firstMessageProposed)) { val time: Long = requests[count][0].timestamp val seed: Long = requests[count][0].seed val numOfNonces: Int = requests[count][0].numOfNonces requests[count][0] = d.firstMessageProposed requests[count][0].timestamp = time requests[count][0].seed = seed requests[count][0].numOfNonces = numOfNonces } count++ } val lastDecision: Decision = decisions[decisions.size() - 1] if (requests != null && requests.size > 0) { deliverMessages(consensusIds, regenciesIds, leadersIds, cDecs, requests) if (controller.hasUpdates()) { processReconfigMessages(lastDecision.getConsensusId()) tomLayer.setLastExec(lastDecision.getConsensusId()) tomLayer.setInExec(-1) } } val cid: Int = lastDecision.getConsensusId() if (cid > 2) { val stableConsensus = cid – 3 tomLayer.execManager.removeConsensus(stableConsensus) } } } catch (e: Exception) { e.printStackTrace(System.err) } deliverUnlock() } Logger.getLogger(DeliveryThread::class.java.getName()).log(Level.INFO, ""DeliveryThread stopped."") }"	This is the code for the thread . It delivers decisions to the TOM request receiver object ( which is the application )
"Throws(GeneralSecurityException::class, EncryptionUnsupportedByProductException::class)
private fun calculateUValue( generalKey: ByteArray, firstDocIdValue: ByteArray?, revision: Int ): ByteArray? { return if (revision == 2) { val rc4: Cipher = createRC4Cipher() val key: SecretKey = createRC4Key(generalKey) initEncryption(rc4, key) crypt(rc4, PW_PADDING) } else if (revision >= 3) { val md5: MessageDigest = createMD5Digest() md5.update(PW_PADDING) if (firstDocIdValue != null) { md5.update(firstDocIdValue) } val hash: ByteArray = md5.digest() val rc4: Cipher = createRC4Cipher() val key: SecretKey = createRC4Key(generalKey) initEncryption(rc4, key) val v: ByteArray = crypt(rc4, hash) rc4shuffle(v, generalKey, rc4) assert(v.size == 16) val entryValue = ByteArray(32) System.arraycopy(v, 0, entryValue, 0, v.size) System.arraycopy(v, 0, entryValue, 16, v.size) entryValue } else { throw EncryptionUnsupportedByProductException(""Unsupported standard security handler revision $revision"") } }"	Calculate what the U value should consist of given a particular key and document configuration . Correponds to Algorithms 3.4 and 3.5 of the PDF Reference version 1.7
"private fun assign(labelMap: HashMap<String, DBIDs>, label: String, id: DBIDRef) { if (labelMap.containsKey(label)) { val exist: DBIDs? = labelMap[label] if (exist is DBID) { val n: ModifiableDBIDs = DBIDUtil.newHashSet() n.add(exist as DBID?) n.add(id) labelMap[label] = n } else { assert(exist is HashSetModifiableDBIDs) assert(exist.size() > 1) (exist as ModifiableDBIDs?).add(id) } } else { labelMap[label] = DBIDUtil.deref(id) } }"	Assigns the specified id to the labelMap according to its label
private fun showFeedback(message: String) { if (myHost != null) { myHost.showFeedback(message) } else { println(message) } }	Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface .
"fun CDeleteAction(debuggerProvider: BackEndDebuggerProvider?, rows: IntArray) { super(if (rows.size == 1) ""Remove Breakpoint"" else ""Remove Breakpoints"") m_debuggerProvider = Preconditions.checkNotNull( debuggerProvider,”IE01344: Debugger provider argument can not be null) m_rows = rows.clone() }"	Creates a new action object .
"fun Yaml( constructor: BaseConstructor, representer: Representer, dumperOptions: DumperOptions, resolver: Resolver ) { if (!constructor.isExplicitPropertyUtils()) { constructor.setPropertyUtils(representer.getPropertyUtils()) } else if (!representer.isExplicitPropertyUtils()) { representer.setPropertyUtils(constructor.getPropertyUtils()) } constructor = constructor representer.setDefaultFlowStyle(dumperOptions.getDefaultFlowStyle()) representer.setDefaultScalarStyle(dumperOptions.getDefaultScalarStyle()) representer.getPropertyUtils().setAllowReadOnlyProperties(dumperOptions.isAllowReadOnlyProperties()) representer.setTimeZone(dumperOptions.getTimeZone()) representer = representer dumperOptions = dumperOptions resolver = resolver this.name = ""Yaml:"" + System.identityHashCode(this) }"	Create Yaml instance . It is safe to create a few instances and use them in different Threads .
"fun testHitEndAfterFind() { hitEndTest(true, ""#01.0"", ""r((ege)|(geg))x"", ""regexx"", false) hitEndTest(true, ""#01.1"", ""r((ege)|(geg))x"", ""regex"", false) hitEndTest(true, ""#01.2"", ""r((ege)|(geg))x"", ""rege"", true) hitEndTest(true, ""#01.2"", ""r((ege)|(geg))x"", ""xregexx"", false) hitEndTest(true, ""#02.0"", ""regex"", ""rexreger"", true) hitEndTest(true, ""#02.1"", ""regex"", ""raxregexr"", false) val floatRegex: String = getHexFloatRegex() hitEndTest(true, ""#03.0"", floatRegex, java.lang.Double.toHexString(-1.234), true) hitEndTest( true, ""#03.1"", floatRegex, ""1 ABC"" + java.lang.Double.toHexString(Double.NaN) + ""buhuhu"", false ) hitEndTest(true, ""#03.2"", floatRegex, java.lang.Double.toHexString(-0.0) + ""--"", false) hitEndTest( true, ""#03.3"", floatRegex, ""--"" + java.lang.Double.toHexString(Double.MIN_VALUE) + ""--"", fals ) hitEndTest( true, ""#04.0"", ""(\\d+) fish (\\d+) fish (\\w+) fish (\\d+)"", ""1 fish 2 fish red fish 5"", tru ) hitEndTest( true, ""#04.1"", ""(\\d+) fish (\\d+) fish (\\w+) fish (\\d+)"", ""----1 fish 2 fish red fish 5----"", fals ) }"	Regression test for HARMONY-4396
fun add(individual: Individual?) { individuals.add(individual) }	Adds a single individual .
"fun removeSession(sesId: IgniteUuid?): Boolean { val ses: GridTaskSessionImpl = sesMap.get(sesId) assert(ses == null || ses.isFullSupport()) if (ses != null && ses.release()) { sesMap.remove(sesId, ses) return true } return false }"	Removes session for a given session ID .
"@Throws(ImageLoadException::class) fun loadBitmapOptimized(uri: Uri?, context: Context?, limit: Int): Bitmap? { return loadBitmapOptimized(object : UriSource(uri, context) {}, limit) }"	Loading bitmap with optimized loaded size less than specific pixels count
"protected fun BasePeriod(duration: Long) { super() iType = PeriodType.standard() val values: IntArray = ISOChronology.getInstanceUTC().get(DUMMY_PERIOD, duration) iValues = IntArray(8) System.arraycopy(values, 0, iValues, 4, 4) }"	"Creates a period from the given millisecond duration with the standard period type and ISO rules , ensuring that the calculation is performed with the time-only period type . < p > The calculation uses the hour , minute , second and millisecond fields ."
fun FlatBufferBuilder() { this(1024) }	"Start with a buffer of 1KiB , then grow as required ."
"fun PbrpcConnectionException(arg0: String?, arg1: Throwable?) { super(arg0, arg1) }"	Creates a new instance of PbrpcConnectionException .
fun uninstallUI(a: javax.swing.JComponent?) { for (i in 0 until uis.size()) {  (uis.elementAt(i) as javax.swing.plaf.ComponentUI).uninstallUI(a) } }	Invokes the < code > uninstallUI < /code > method on each UI handled by this object .
fun shutdown() { if (instance != null) { instance.save() } }	Saves the configuration file .
fun GE(w2: org.graalvm.compiler.word.Word): Boolean { return value.GE(w2.value) }	Greater-than or equal comparison
fun of(elementCoders: List<Coder<*>?>?): UnionCoder? { return UnionCoder(elementCoders) }	Builds a union coder with the given list of element coders . This list corresponds to a mapping of union tag to Coder . Union tags start at 0 .
"@Throws(Exception::class) fun testFileDeletion() { val testDir: File = createTestDir(""testFileDeletion"") val prefix1 = ""testFileDeletion1"" val files1: Array<File> = createFiles(testDir, prefix1, 5) val prefix2 = ""testFileDeletion2"" val files2: Array<File> = createFiles(testDir, prefix2, 5) FileCommands.deleteFiles(files1, true) assertNotExists(files1) FileCommands.deleteFiles(files2, false) Thread.sleep(1000) assertNotExists(files2) }"	Verify ability to delete a list of files .
fun isOnClasspath(classpath: String?): Boolean { return classpath.equals(classpath) }	Evaluates if the Dependency is targeted for a classpath type .
"protected fun source(ceylon: String) { val providerPreSrc = ""provider/"" + ceylon + ""_pre.ceylon"" val providerPostSrc = ""provider/"" + ceylon + ""_post.ceylon"" val clientSrc = ""client/"" + ceylon + ""_client.ceylon"" compile(providerPreSrc, providerModuleSrc, providerPackageSrc) compile(clientSrc, clientModuleSrc) compile(providerPostSrc, providerModuleSrc, providerPackageSrc) compile(clientSrc, clientModuleSrc) }"	Checks that we can still compile a client after a change
fun PerformanceMonitor() { initComponents() if (Display.getInstance().getCurrent() != null) { refreshFrameActionPerformed(null) } resultData.setModel(Model()) performanceLog.setLineWrap(true) resultData.setRowSorter(javax.swing.table.TableRowSorter<Model>(resultData.getModel() as Model)) }	Creates new form PerformanceMonitor
"""@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2014-09-03 15:01:15.190 -0400"", hash_original_method = ""F262A3A18BABECF7EC492736953EAF6E"",hash_generated_method = ""94A4545C167C029CC38AACEACF2087E9"") private fun unparkSuccessor(node: Node) {val ws: Int = node.waitStatus if (ws < 0) compareAndSetWaitStatus(node, ws, 0) var s: Node? = node.next if (s == null || s.waitStatus > 0) { s = null var t: Node = tail while (t != null && t !== node) { if (t.waitStatus <= 0) s = t t = t.prev } } if (s != null) LockSupport.unpark(s.thread) }"	"Wakes up node 's successor , if one exists ."
"@DSComment(""From safe class list"") @DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 13:02:44.364 -0500"", hash_original_method = ""EA3734ADDEB20313C9CAB09B48812C54"", hash_generated_method = ""4858AFE909DDE63867ACB561D5449C13"" ) fun assertFalse(message: String?, condition: Boolean) { assertTrue(message, !condition) }"	Asserts that a condition is false . If it is n't it throws an AssertionFailedError with the given message .
"protected fun initData() { val intent = Intent(this, PushMessageService::class.java) this.startService(intent) this.bindService(intent, this.connection, Context.BIND_AUTO_CREATE) }"	Initialize the Activity data
@Throws(ParseException::class) fun parseDateDay(dateString: String?): Date? { return getSimplDateFormat(DF_DEF).parse(dateString) }	Returns date parsed from string in format : yyyy.MM.dd .
"private fun doesStoragePortExistsInVArray( umfsStoragePort: StoragePort, virtualArray: VirtualArray ): Boolean { val virtualArrayPorts: List<URI> = returnAllPortsInVArray(virtualArray.getId()) return if (virtualArrayPorts.contains(umfsStoragePort.getId())) { true } else false }"	Checks if the given storage port is part of VArray
"@Throws(ServiceException::class) fun SpringVaadinServletService( servlet: VaadinServlet?, deploymentConfiguration: DeploymentConfiguration?, serviceUrl: String ) { super(servlet, deploymentConfiguration) serviceUrl = serviceUrl }"	Create a servlet service instance that allows the use of a custom service URL .
"@Throws(InternalTranslationException::class) private fun translateChildrenOfNode( environment: ITranslationEnvironment, expression: IOperandTreeNode, size: org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize, loadOperand: Boolean, baseOffset: Long ): List<TranslationResult>? { var baseOffset: Long? = baseOffset val partialResults: MutableList<TranslationResult> = ArrayList() val children: List<IOperandTreeNode?> = expression.getChildren() Collections.sort(children, comparator) for (child in children) { val nextResult: TranslationResult = loadOperand( environment, baseOffset, child, if (isSegmentExpression(expression.getValue())) expression else null, size, loadOperand ) partialResults.add(nextResult) baseOffset += nextResult.getInstructions().size() } return partialResults }"	Iterates over the children of a node in the operand tree and generates translations for them .
"fun removeShutdownLatch(latch: CountDownLatch?) { removeShutdownLatch(latch, false) }"	Releases the latch and removes it from the latches being handled by this handler .
fun Version() { this(CommonReflection.getVersionTag()) }	Constructs a new Version from the current server version running
"fun startActivity(context: Context, chatId: String?) { val intent = Intent(context, SendGroupFile::class.java) intent.putExtra(EXTRA_CHAT_ID, chatId) context.startActivity(intent) }"	Start SendGroupFile activity
fun excludedDataCenters(excludedDataCenters: String?): Index? { excludedDataCenters = excludedDataCenters return this }	Sets the list of excluded data centers .
@Throws(IOException::class) fun read(): Int { val result: Int = src.read() if (result != -1) { ++pointer } return result }	Forwards the request to the real < code > InputStream < /code > .
"fun compareAndSwapInt(obj: Any?, off: Long, exp: Int, upd: Int): Boolean { return UNSAFE.compareAndSwapInt(obj, off, exp, upd) }"	Integer CAS .
"fun dec2Bin(value: Int): String? { val result = """" return dec2Bin(value, result) }"	Methods converts a decimal number into a binary number as a string
"fun apply(recyclerView: RecyclerView, items: Iterable<Item>?) { if (items != null) { val cache: HashMap<Int, Stack<RecyclerView.ViewHolder>> = HashMap() for (d in items) { if (!cache.containsKey(d.getType())) { cache[d.getType()] = Stack<RecyclerView.ViewHolder>() } if (mCacheSize === -1 || cache[d.getType()].size() <= mCacheSize) { cache[d.getType()].push(d.getViewHolder(recyclerView)) } val recyclerViewPool = RecycledViewPool() for ((key, value): Map.Entry<Int?, Stack<RecyclerView.ViewHolder?>> in cache.entrySet()) { recyclerViewPool.setMaxRecycledViews(key!!, mCacheSize) for (holder in value) { recyclerViewPool.putRecycledView(holder) } value.clear() } cache.clear() recyclerView.setRecycledViewPool(recyclerViewPool) } } }"	init the cache on your own .
"fun incNumOverflowOnDisk(delta: Long) { this.stats.incLong(numOverflowOnDiskId, delta) }"	Increments the current number of entries whose value has been overflowed to disk by a given amount .
"fun paint(a: java.awt.Graphics?, b: javax.swing.JComponent?) { for (i in 0 until uis.size()) { (uis.elementAt(i) as javax.swing.plaf.ComponentUI).paint(a, b) } }"	Invokes the < code > paint < /code > method on each UI handled by this object .
fun updateUI() { setUI(javax.swing.UIManager.getUI(this) as javax.swing.plaf.TableHeaderUI) val renderer: javax.swing.table.TableCellRenderer = getDefaultRenderer() if (renderer is Component) { javax.swing.SwingUtilities.updateComponentTreeUI(renderer as Component) } }	Notification from the < code > UIManager < /code > that the look and feel ( L & amp ; F ) has changed . Replaces the current UI object with the latest version from the < code > UIManager < /code > .
fun create(status: IStatus): RefactoringStatus? { if (status.isOK()) return RefactoringStatus() return if (!status.isMultiStatus()) { when (status.getSeverity()) { IStatus.OK -> RefactoringStatus() IStatus.INFO -> RefactoringStatus.createWarningStatus(status.getMessage()) IStatus.WARNING -> RefactoringStatus.createErrorStatus(status.getMessage()) IStatus.ERROR -> RefactoringStatus.createFatalErrorStatus(status.getMessage()) IStatus.CANCEL -> RefactoringStatus.createFatalErrorStatus(status.getMessage()) else -> RefactoringStatus.createFatalErrorStatus(status.getMessage()) } } else { val children: Array<IStatus> = status.getChildren() val result = RefactoringStatus() for (i in children.indices) { result.merge(RefactoringStatus.create(children[i])) } Result } }	"Creates a new < code > RefactoringStatus < /code > from the given < code > IStatus < /code > . An OK status is mapped to an OK refactoring status , an information status is mapped to a warning refactoring status , a warning status is mapped to an error refactoring status and an error or cancel status is mapped to a fatal refactoring status . An unknown status is converted into a fatal error status as well . If the status is a < code > MultiStatus < /code > then the first level of children of the status will be added as refactoring status entries to the created refactoring status ."
fun debug(msg: String?) { debugLogger.debug(msg) }	Log a Setup and/or administrative log message for log4jdbc .
fun size(): Int { return codon.length }	Returns the length of the integer codon representation of this grammar .
"@Throws(UnsupportedEncodingException::class, DecodingException::class)fun decode(): jdk.internal.org.jline.utils.DiffHelper.Diff? { val header: Int = r.read(3) if (DiffAction.parse(header) !== DiffAction.DECODER_DATA) { throw DecodingException(""Invalid codecData code: $header"") } val blockSize_C = 3 val blockSize_S: Int = r.read(5) val blockSize_E: Int = r.read(5) val blockSize_B: Int = r.read(5) val blockSize_L: Int = r.read(5) r.read(1) if (blockSize_S < 0 || blockSize_S > 31) { throw DecodingException(""blockSize_S out of range: $blockSize_S"") } if (blockSize_E < 0 || blockSize_E > 31) { throw DecodingException(""blockSize_E out of range: $blockSize_E"") } if (blockSize_B < 0 || blockSize_B > 31) { throw DecodingException(""blockSize_B out of range: $blockSize_B"") } if (blockSize_L < 0 || blockSize_L > 31) { throw DecodingException(""blockSize_L out of range: $blockSize_L"") } return decode(blockSize_C, blockSize_S, blockSize_E, blockSize_B, blockSize_L) }"	Decodes the information and returns the Diff .
fun FontSizeLocator() {}	Creates a new instance .
"fun <E : Comparable<E>?> createAutoSortedCollection(values: Collection<E>?): AutoSortedCollection<E>? { return createAutoSortedCollection(null, values) }"	Construct new auto sorted collection using natural order .
override fun toString(): String? { return super.toString() }	Returns the super class implementation of toString ( ) .
fun useLayoutEditor(destination: SignalMast?): Boolean { return if (!destList.containsKey(destination)) { false } else destList.get(destination).useLayoutEditor() }	"Query if we are using the layout editor panels to build the signal mast logic , blocks , turnouts ."
"private fun unescapePathComponent(name: String): String? { return name.replace(""\\\\(.)"".toRegex(), ""$1"") }"	Convert a path component that contains backslash escape sequences to a literal string . This is necessary when you want to explicitly refer to a path that contains globber metacharacters .
fun AbstractExampleTable(attributes: List<Attribute?>?) { addAttributes(attributes) }	Creates a new ExampleTable .
"fun zoomOut() { val save: Matrix = mViewPortHandler.zoomOut(getWidth() / 2f, -(getHeight() / 2f)) mViewPortHandler.refresh(save, this, true) }"	"Zooms out by 0.7f , from the charts center . center ."
@Throws(IOException::class) fun createBackgroundMedia(uri: String?): Media? { return impl.createBackgroundMedia(uri) }	Creates an audio media that can be played in the background .
private fun hasNextTlsMode(): Boolean { return nextTlsMode !== TLS_MODE_NULL }	Returns true if there 's another TLS mode to try .
protected fun copyToOpsw() { opsw.get(1) = fullmode.isSelected() opsw.get(2) = twoaspects.isSelected() opsw.get(11) = semaphore.isSelected() opsw.get(12) = pulsed.isSelected() opsw.get(13) = disableDS.isSelected() opsw.get(14) = fromloconet.isSelected() opsw.get(15) = disablelocal.isSelected() opsw.get(17) = sigaddress.isSelected() opsw.get(18) = bcastaddress.isSelected() opsw.get(19) = semaddress.isSelected() opsw.get(20) = setdefault.isSelected() opsw.get(21) = exercise.isSelected() var value: Int = section1to4mode.getSelectedIndex() opsw.get(5) = value and 0x01 != 0 opsw.get(4) = value and 0x02 != 0 opsw.get(3) = value and 0x04 != 0 value = section5to8mode.getSelectedIndex() opsw.get(8) = value and 0x01 != 0 opsw.get(7) = value and 0x02 != 0 opsw.get(6) = value and 0x04 != 0 value = fourthAspect.getSelectedIndex() opsw.get(10) = value and 0x01 != 0 opsw.get(9) = value and 0x02 != 0 }	Copy from the GUI to the opsw array . < p > Used before write operations start
"override fun onRequestPermissionsResult( requestCode: Int, permissions: Array<String?>, grantResults: IntArray ) { if (requestCode == ALLOW_PERMISSIONS && grantResults.size > 0) { val permissionsNotAllowed: MutableList<String?> = ArrayList() for (i in permissions.indices) { if (grantResults[i] == PackageManager.PERMISSION_DENIED) { permissionsNotAllowed.add(permissions[i]) } } if (permissionsNotAllowed.isEmpty()) { initEvent() } else { permissionNotEnabled() } } else { permissionNotEnabled() } }"	This method is a callback . Check the user 's answer after requesting permission .
"fun rowGet(key: String?): String? { val resolvedKey: String = resolveRowKey(key) val cachedValue: String = rowMapCache.get(resolvedKey) if (cachedValue != null) { return cachedValue } var value: String = rowMap.get(resolvedKey) if (value == null && jdk.javadoc.internal.doclets.toolkit.util.DocPath.parent != null) { value = jdk.javadoc.internal.doclets.toolkit.util.DocPath.parent.rowGet(resolvedKey) } if (value == null) { return null } val expandedString: String = expand(value, false) rowMapCache.put(resolvedKey, expandedString) return expandedString }"	"Looks up and returns the RowSpec associated with the given key . First looks for an association in this LayoutMap . If there 's no association , the lookup continues with the parent map - if any ."
"fun postEvaluationStatistics(state: EvolutionState) { super.postEvaluationStatistics(state) state.output.println( """"” Generation: ${state.generation) """""".trimIndent(), Output.V_NO_GENERAL, statisticslog ) for (x in 0 until state.population.subpops.length) for (y in 1 until state.population.subpops.get( x ).individuals.length) state.population.subpops.get(x).individuals.get(y).printIndividualForHumans(state, statisticslog, Output.V_NO_GENERAL) }"	Logs the best individual of the generation .
"@Throws(Exception::class) private fun checkUserExists(entidad: String) { val count: Int val table = UsersTable() val dbConn = DbConnection() try { dbConn.open(DBSessionManager.getSession()) count = if (_id === ISicresAdminDefsKeys.NULL_ID) DbSelectFns.selectCount( dbConn, table.getBaseTableName(), table.getCountNameQual(_name) ) else DbSelectFns.selectCount( dbConn, table.getBaseTableName(), table.getCountNameIdQual(_id, _name) ) if (count > 0) ISicresAdminBasicException.throwException(ISicresAdminUserKeys.EC_USER_EXISTS_NAME) } catch (e: Exception) { _logger.error(e) throw e } finally { dbConn.close() } }"	Comprueba que el usuario tiene distinto nombre a los que ya existen .
"@Transactional fun createRoleWithPermissions(role: Role, permissionIds: Set<Long?>?): Role? { val current: Role = findRoleByRoleName(role.getRoleName()) Preconditions.checkState(current == null, ""Role %s already exists!"", role.getRoleName()) val createdRole: Role = roleRepository.save(role) if (!CollectionUtils.isEmpty(permissionIds)) { val rolePermissions: Iterable<RolePermission> = FluentIterable.from(permissionIds).transform(null) rolePermissionRepository.save(rolePermissions) } return createdRole }"	"Create role with permissions , note that role name should be unique"
"protected fun generateNewCursorBox() { if (old_m_x2 !== -1 || old_m_y2 !== -1 || Math.abs(commonValues.m_x2 - old_m_x2) > 5 || Math.abs( commonValues.m_y2 - old_m_y2 ) > 5 ) { var top_x: Int = commonValues.m_x1 if (commonValues.m_x1 > commonValues.m_x2) { top_x = commonValues.m_x2 } var top_y: Int = commonValues.m_y1 if (commonValues.m_y1 > commonValues.m_y2) { top_y = commonValues.m_y2 } val w: Int = Math.abs(commonValues.m_x2 - commonValues.m_x1) val h: Int = Math.abs(commonValues.m_y2 - commonValues.m_y1) val currentRectangle = intArrayOf(top_x, top_y, w, h) decode_pdf.updateCursorBoxOnScreen( currentRectangle, DecoderOptions.highlightColor.getRGB() )if (!currentCommands.extractingAsImage) {val r = intArrayOf(commonValues.m_x1,commonValues.m_y1, commonValues.m_x2 - commonValues.m_x1, commonValues.m_y2 - commonValues.m_y1)decode_pdf.getTextLines().addHighlights(arrayOf(r), false, commonValues.getCurrentPage() } old_m_x2 = commonValues.m_x2 old_m_y2 = commonValues.m_y2 } decode_pdf.repaintPane(commonValues.getCurrentPage()) }"	"generate new cursorBox and highlight extractable text , if hardware acceleration off and extraction on < br > and update current cursor box displayed on screen"
fun OMGraphicList(initialCapacity: Int) { graphics = Collections.synchronizedList(ArrayList<OMGraphic>(initialCapacity)) }	Construct an OMGraphicList with an initial capacity .
"private fun saveToSettings() { val dataToSave: MutableList<String> = LinkedList() for (item in data) { dataToSave.add( item.getId().toString() + "","" + HtmlColors.getColorString(item.getColor()) ) } settings.putList(""usercolors"", dataToSave) }"	Copy the current data to the settings .
fun isArrayForName(value: String?): Boolean { return ARRAY_FOR_NAME_PATTERN.matcher(value).matches() }	Returns true if the given string looks like a Java array name .
fun length(): Double { return Math.sqrt(this.x * this.x + this.y * this.y) }	Calculates the length of the vector .
override fun toString(): String? { return schema }	Returns this ' media-type ( a MIME content-type category ) ( previously returned a description key )
fun restoreStarting(numPackages: Int) {}	The restore operation has begun .
"@Throws(CoreException::class) private fun resourceIsGwtXmlAndInGwt(resource: IResource): Boolean { return GWTNature.isGWTProject(resource.getProject()) && resource.getName() .endsWith("".gwt.xml"") }"	"If the resource is a .gwt.xml file and we 're in a gwt-enabled project , return true ."
"fun GlowCreature(location: Location?, type: EntityType, maxHealth: Double) { super(location, maxHealth) type = type }"	Creates a new monster .
fun CacheLayer() {}	Construct a default CacheLayer .
"@Throws(JSONException::class) protected fun buildAndroidAddress(jResult: JSONObject): Address? { val gAddress = Address(mLocale) gAddress.setLatitude(jResult.getDouble(""lat"")) gAddress.setLongitude(jResult.getDouble(""lng"")) var addressIndex = 0 if (jResult.has(""streetName"")) { gAddress.setAddressLine(addressIndex++, jResult.getString(""streetName"")) gAddress.setThoroughfare(jResult.getString(""streetName"")) } if (jResult.has(""zipCode"")) { gAddress.setAddressLine(addressIndex++, jResult.getString(""zipCode"")) gAddress.setPostalCode(jResult.getString(""zipCode"")) } if (jResult.has(""city"")) { gAddress.setAddressLine(addressIndex++, jResult.getString(""city"")) gAddress.setLocality(jResult.getString(""city"")) } if (jResult.has(""state"")) { gAddress.setAdminArea(jResult.getString(""state"")) } if (jResult.has(""country"")) { gAddress.setAddressLine(addressIndex++, jResult.getString(""country"")) gAddress.setCountryName(jResult.getString(""country"")) } if (jResult.has(""countrycode"")) gAddress.setCountryCode(jResult.getString(""countrycode"")) return gAddress }"	Build an Android Address object from the Gisgraphy address in JSON format .
"@Throws(SQLException::class) fun JDBCCategoryDataset(connection: Connection?, query: String?) { this(connection) executeQuery(query) }"	"Creates a new dataset with the given database connection , and executes the supplied query to populate the dataset ."
"fun generateReqsFromCancelledPOItems( dctx: DispatchContext, context: Map<String?, Any?> ): Map<String?, Any?>? { val delegator: Delegator = dctx.getDelegator() val dispatcher: LocalDispatcher = dctx.getDispatcher() val userLogin: GenericValue? = context[""userLogin""] as GenericValue? val locale: Locale? = context[""locale""] as Locale? val orderId = context[""orderId""] as String? val facilityId = context[""facilityId""] as String? try { val orderHeader: GenericValue = EntityQuery.use(delegator).from(""OrderHeader"").where(""orderId"", orderId).queryOne() if (UtilValidate.isEmpty(orderHeader)) { val errorMessage: String = UtilProperties.getMessage( resource_error, ""OrderErrorOrderIdNotFound"", UtilMisc.toMap(""orderId"", orderId), Locale ) Debug.logError(errorMessage, module) return ServiceUtil.returnError(errorMessage) } if (""PURCHASE_ORDER"" != orderHeader.getString(""orderTypeId"")) { val errorMessage: String = UtilProperties.getMessage( resource_error, ""ProductErrorOrderNotPurchaseOrder"", UtilMisc.toMap(""orderId"", orderId), Locale ) Debug.logError(errorMessage, module) return ServiceUtil.returnError(errorMessage) } val productRequirementQuantities: MutableMap<String, Any> = HashMap() val orderItems: List<GenericValue> = orderHeader.getRelated(""OrderItem"", null, null, false) for (orderItem in orderItems) { if (""PRODUCT_ORDER_ITEM"" != orderItem.getString(""orderItemTypeId"")) continue var orderItemCancelQuantity: BigDecimal = BigDecimal.ZERO if (!UtilValidate.isEmpty(orderItem.get(""cancelQuantity""))) {orderItemCancelQuantity = orderItem.getBigDecimal(""cancelQuantity"")} if (orderItemCancelQuantity.compareTo(BigDecimal.ZERO) <= 0) continue val productId: String = orderItem.getString(""productId"") if (productRequirementQuantities.containsKey(productId)) { orderItemCancelQuantity = orderItemCancelQuantity.add(productRequirementQuantities[productId] as BigDecimal?) } productRequirementQuantities[productId] = orderItemCancelQuantity } for (productId in productRequirementQuantities.keys) { val requiredQuantity: BigDecimal? = productRequirementQuantities[productId] as BigDecimal? val createRequirementResult: Map<String?, Any?> = dispatcher.runSync( ""createRequirement"", UtilMisc.< String, Object > toMap<String, Any>( ""requirementTypeId"", ""PRODUCT_REQUIREMENT"", ""facilityId"", facilityId, ""productId"", productId, ""quantity"", requiredQuantity, ""userLogin"", userLogin ) ) if (ServiceUtil.isError(createRequirementResult)) return createRequirementResult } } catch (e: GenericEntityException) { Debug.logError(e, module) return ServiceUtil.returnError(e.getMessage()) } catch (se: GenericServiceException) { Debug.logError(se, module) return ServiceUtil.returnError(se.getMessage()) } return ServiceUtil.returnSuccess() }"	Generates a product requirement for the total cancelled quantity over all order items for each product
"@Throws(IOException::class, ClassNotFoundException::class) private fun readObject(s: ObjectInputStream) { s.defaultReadObject() if (bayesIm == null) { throw NullPointerException() } if (variables == null) { throw NullPointerException() } }"	"Adds semantic checks to the default deserialization method . This method must have the standard signature for a readObject method , and the body of the method must begin with `` s.defaultReadObject ( ) ; '' . Other than that , any semantic checks can be specified and do not need to stay the same from version to version . A readObject method of this form may be added to any class , even if Tetrad sessions were previously saved out using a version of the class that did n't include it . ( That 's what the `` s.defaultReadObject ( ) ; '' is for . See J. Bloch , Effective Java , for help ."
operator fun contains(protocolVersion: ProtocolVersion): Boolean { return if (protocolVersion === ProtocolVersion.SSL20Hello) { false } else protocols.contains(protocolVersion) }	"Return whether this list contains the specified protocol version . SSLv2Hello is not a real protocol version we support , we always return false for it ."
protected fun eStaticClass(): EClass? { return DatatypePackage.Literals.OBJECT_PROPERTY_TYPE }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:34:35.806 -0500"", hash_original_method = ""E14DF72F5869874CC38AD67447F5264E"", hash_generated_method = ""127365361841BB38033FE96228DFD635"" ) fun typesIterator(): Iterator<String>? { return if (mDataTypes != null) mDataTypes.iterator() else null }"	Return an iterator over the filter 's data types .
fun registerGUI(gui: ConfigGUI) { gui = gui }	Sets the reference of the GUI .
fun IntersectionMatrix(other: IntersectionMatrix) { this() matrix.get(Location.INTERIOR).get(Location.INTERIOR) = other.matrix.get(Location.INTERIOR).get(Location.INTERIOR) matrix.get(Location.INTERIOR).get(Location.BOUNDARY) = other.matrix.get(Location.INTERIOR).get(Location.BOUNDARY) matrix.get(Location.INTERIOR).get(Location.EXTERIOR) = other.matrix.get(Location.INTERIOR).get(Location.EXTERIOR) matrix.get(Location.BOUNDARY).get(Location.INTERIOR) = other.matrix.get(Location.BOUNDARY).get(Location.INTERIOR) matrix.get(Location.BOUNDARY).get(Location.BOUNDARY) = other.matrix.get(Location.BOUNDARY).get(Location.BOUNDARY) matrix.get(Location.BOUNDARY).get(Location.EXTERIOR) = other.matrix.get(Location.BOUNDARY).get(Location.EXTERIOR) matrix.get(Location.EXTERIOR).get(Location.INTERIOR) = other.matrix.get(Location.EXTERIOR).get(Location.INTERIOR) matrix.get(Location.EXTERIOR).get(Location.BOUNDARY) other.matrix.get(Location.EXTERIOR).get(Location.BOUNDARY) matrix.get(Location.EXTERIOR).get(Location.EXTERIOR) = other.matrix.get(Location.EXTERIOR).get(Location.EXTERIOR) }	Creates an < code > IntersectionMatrix < /code > with the same elements as < code > other < /code > .
"fun readUnsignedInt(): Long { val result: Long = shiftIntoLong(data, position, 4) position += 4 return result }"	Reads the next four bytes as an unsigned value .
"fun emit(out: SpannableStringBuilder?, root: Block) { root.removeSurroundingEmptyLines() when (root.type) { NONE -> {} javax.accessibility.AccessibleRole.PARAGRAPH -> this.config.decorator.openParagraph(out) javax.swing.text.html.HTML.Tag.BLOCKQUOTE -> this.config.decorator.openBlockquote(out) UNORDERED_LIST -> this.config.decorator.openUnorderedList(out) ORDERED_LIST -> this.config.decorator.openOrderedList(out) UNORDERED_LIST_ITEM -> this.config.decorator.openUnOrderedListItem(out) ORDERED_LIST_ITEM -> this.config.decorator.openOrderedListItem(out) } if (root.hasLines()) { this.emitLines(out, root) } else { var block: Block = root.blocks while (block != null) { emit(out, block) block = block.next } } when (root.type) { NONE -> {} javax.accessibility.AccessibleRole.PARAGRAPH -> this.config.decorator.closeParagraph(out) javax.swing.text.html.HTML.Tag.BLOCKQUOTE -> this.config.decorator.closeBlockquote(out) UNORDERED_LIST -> this.config.decorator.closeUnorderedList(out) ORDERED_LIST -> this.config.decorator.closeOrderedList(out) UNORDERED_LIST_ITEM -> this.config.decorator.closeUnOrderedListItem(out) ORDERED_LIST_ITEM -> this.config.decorator.closeOrderedListItem(out) } }"	Transforms the given block recursively into HTML .
fun isInternable(): Boolean { return classAnnotations != null && fieldAnnotations == null && methodAnnotations == null && parameterAnnotations == null }	"Returns whether this item is a candidate for interning . The only interning candidates are ones that < i > only < /i > have a non-null set of class annotations , with no other lists ."
"@Throws(javax.print.URIException::class) fun URI( scheme: String?, userinfo: String?, host: String?, port: Int, path: String?, query: String?, fragment: String? ) { this( scheme, if (host == null) null else (if (userinfo != null) ""$userinfo@"" else """") + host + if (port != -1) "":$port"" else """", path, query, fragment ) }"	Construct a general URI from the given components .
fun addUser(user: User?) { users.addElement(user) }	Add a user
@Throws(SignatureException::class) protected fun engineUpdate(b: Byte) { msgDigest.update(b) }	Updates data to sign or to verify .
"@Throws(IOException::class) fun RqMtFake(req: Request?, vararg dispositions: Request?) { this.fake = RqMtBase(FakeMultipartRequest(req, dispositions)) }"	Fake ctor .
"fun randomVideo(): Video? { val id: String = UUID.randomUUID().toString() val title = ""Video-$id"" val url = http://coursera.org/some/video-$id val duration = (60 * Math.rint(Math.random() * 60).toInt() * 1000).toLong() return Video(title, url, duration) }"	"Construct and return a Video object with a rnadom name , url , and duration ."
"fun addHeader(header: String?, value: String?) { clientHeaderMap.put(header, value) }"	Sets headers that will be added to all requests this client makes ( before sending ) .
fun addPostalAddress(postalAddress: PostalAddress?) { getPostalAddresses().add(postalAddress) }	Adds a new contact postal address .
fun newCaughtExceptionRef(): CaughtExceptionRef? { return JCaughtExceptionRef() }	Constructs a CaughtExceptionRef ( ) grammar chunk .
fun actionPerformed(e: java.awt.event.ActionEvent) { if (e.getSource() is PerformanceIndicator) { val pi: PerformanceIndicator = e.getSource() as PerformanceIndicator log.info(pi.getName()) val goal: MGoal = pi.getGoal() if (goal.getMeasure() != null) PerformanceDetail(goal) } }	Action Listener for Drill Down
fun childIterator(dirtyNodesOnly: Boolean): Iterator<com.sun.tools.javac.util.GraphUtils.AbstractNode?>? { return if (dirtyNodesOnly) { DirtyChildIterator(this) } else { com.sun.org.apache.xpath.internal.axes.ChildIterator(this) } }	Iterator visits the direct child nodes in the external key ordering .
fun maxIndex(doubles: DoubleArray): Int { var maximum = 0.0 var maxIndex = 0 for (i in doubles.indices) { if (i == 0 || doubles[i] > maximum) { maxIndex = I maximum = doubles[i] } } return maxIndex }	Returns index of maximum element in a given array of doubles . First maximum is returned .
"private fun crawlSingleIndexableResource(indexableFragment: IndexableFragment): List<PreferenceIndex>? { val indexablePreferences: MutableList<PreferenceIndex> = ArrayList() val parser: XmlPullParser = mContext.getResources().getXml(indexableFragment.xmlRes) var type: Int try { while (parser.next().also { type = it } != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) { } var nodeName = parser.name if (!NODE_NAME_PREFERENCE_SCREEN.equals(nodeName)) { throw RuntimeException(""XML document must start with <PreferenceScreen> tag; found"" + nodeName + "" at "" + parser.positionDescription) } val outerDepth = parser.depth val attrs: AttributeSet = Xml.asAttributeSet(parser) while (parser.next().also { type = it } != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.depth > outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue } nodeName = parser.name val key: String = PreferenceXmlUtil.getDataKey(mContext, attrs) val title: String = PreferenceXmlUtil.getDataTitle(mContext, attrs) if (NODE_NAME_PREFERENCE_CATEGORY.equals(nodeName) || TextUtils.isEmpty(key) || TextUtils.isEmpty( title ) ) { Continue } val indexablePreference = PreferenceIndex(key, title, indexableFragment.fragmentName) indexablePreferences.add(indexablePreference) } } catch (ex: XmlPullParserException) { Log.e(TAG, ""Error in parsing a preference xml file, skip it"", ex)"	Skim through the xml preference file .
"private fun crawlSingleIndexableResource(indexableFragment: IndexableFragment): List<PreferenceIndex>? { val indexablePreferences: MutableList<PreferenceIndex> = ArrayList() val parser: XmlPullParser = mContext.getResources().getXml(indexableFragment.xmlRes) var type: Int try { while (parser.next().also { type = it } != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) { } var nodeName = parser.name if (!NODE_NAME_PREFERENCE_SCREEN.equals(nodeName)) { throw RuntimeException(""XML document must start with <PreferenceScreen> tag; found"" + nodeName + "" at "" + parser.positionDescription) } val outerDepth = parser.depth val attrs: AttributeSet = Xml.asAttributeSet(parser) while (parser.next().also { type = it } != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.depth > outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue } nodeName = parser.name val key: String = PreferenceXmlUtil.getDataKey(mContext, attrs) val title: String = PreferenceXmlUtil.getDataTitle(mContext, attrs) if (NODE_NAME_PREFERENCE_CATEGORY.equals(nodeName) || TextUtils.isEmpty(key) || TextUtils.isEmpty( title ) ) { Continue } val indexablePreference = PreferenceIndex(key, title, indexableFragment.fragmentName) indexablePreferences.add(indexablePreference) } } catch (ex: XmlPullParserException) { Log.e(TAG, ""Error in parsing a preference xml file, skip it"", ex)
        } catch (ex: IOException) { Log.e(TAG, ""Error in parsing a preference xml file, skip it"", ex) } catch (ex: ReflectiveOperationException) { Log.e(TAG, ""Error in parsing a preference xml file, skip it"", ex) } return indexablePreferences }"	Generate an explicit null check ( compare to zero ) .
fun Location(provider: String) { mProvider = provider }	"Construct a new Location with a named provider . < p > By default time , latitude and longitude are 0 , and the location has no bearing , altitude , speed , accuracy or extras ."
fun NodesInfoRequest(vararg nodesIds: String?) { super(nodesIds) }	"Get information from nodes based on the nodes ids specified . If none are passed , information for all nodes will be returned ."
fun norm(a: DoubleArray): Double { var squaredSum = 0.0 for (i in a.indices) { squaredSum += a[i] * a[i] } return Math.sqrt(squaredSum) }	Computes 2-norm of vector
"private fun toDoubleAray(intArray: Array<Int>, skipIndex: HashSet<Int>): DoubleArray? { val res = DoubleArray(intArray.size - skipIndex.size()) var skip = 0 for (i in intArray.indices) { if (skipIndex.contains(i)) { skip++ continue } res[i - skip] = intArray[i].toDouble() } return res }"	Converts an array into array of doubles skipping specified indeces .
"private fun updateProgress(progressLabel: String, progress: Int) { if (myHost != null && (progress != previousProgress || progressLabel != previousProgressLabel)) { myHost.updateProgress(progressLabel, progress) } previousProgress = progress previousProgressLabel = progressLabel }"	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
"fun CompositeValidationIssueProcessor( first: IValidationIssueProcessor?, vararg others: IValidationIssueProcessor? ) { processors = Lists.asList(first, others) }"	Creates a new composite issue processor with the given sub processor arguments .
fun removeMaxAge(): jdk.internal.joptsimple.OptionSet? { max_age = null return this }	Removes the Max-Age option . Returns the current OptionSet object for a fluent API .
"fun Request() { locality = """" state = """" organization = """" orgunit = """" dnsname = """" uri = """" email = """" ipaddress = """" keyusage = 0 }"	Ctor for the Request Object
protected fun determineMainLabelPosition(dc: DrawContext?): Position? { return this.getReferencePosition() }	"Compute the position for the area 's main label . This position indicates the position of the first line of the label . If there are more lines , they will be arranged South of the first line ."
"fun extractFields(line: String?): Map<String, Any>? { if (!initialized) { init() initialized = true} val values: Array<String> = fixedWidthParser.parseLine(line) if (hasHeader && Arrays.deepEquals(values, header)) {return null } val map: MutableMap<String, Any> = Maps.newHashMap() var i = 0 for (field in fields) { map[field.getName()] = getValue(field, values[i++]) } return map }"	Extracts the fields from a fixed width record and returns a map containing field names and values
operator fun contains(subvalue: Value): Boolean { return toString().contains(subvalue.toString()) }	Returns true if the value is contained in the relation structure . ( this is done
"private fun applyTo(v: ClassVisitor, f: Field) { if (Log.isLoggingOn()) { Log.logLine(String.format(""Visiting field %s"", f.toGenericString())) } v.visit(f) }"	Apply a visitor to a field .
protected fun eStaticClass(): EClass? { return ExpressionsPackage.Literals.BITWISE_AND_EXPRESSION }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun closePath() { shape_primitives.addElement(H) shape_primitive_x.addElement(0) shape_primitive_y.addElement(0) shape_primitive_x2.addElement(0) shape_primitive_y2.addElement(0) shape_primitive_x3.addElement(0) shape_primitive_y3.addElement(0) }	"end a shape , storing info for later"
"fun DefaultBoundValueOperations(key: K?, operations: RedisOperations<K?, V?>) { super(key, operations) this.ops = operations.opsForValue() }"	Constructs a new < code > DefaultBoundValueOperations < /code > instance .
"@Throws(IOException::class) fun writeBatch() { if (getInstances() == null) { throw IOException(""No instances to save"") } if (getRetrieval() === INCREMENTAL) { throw IOException(""Batch and incremental saving cannot be mixed."") } setRetrieval(BATCH) setWriteMode(WRITE)
 if (retrieveFile() == null && getWriter() == null) { for (i in 0 until getInstances().numInstances()) { System.out.println(instanceToLibsvm(getInstances().instance(i))) } setWriteMode(WAIT) } else { var outW: PrintWriter? = PrintWriter(getWriter()) for (i in 0 until getInstances().numInstances()) { outW.println(instanceToLibsvm(getInstances().instance(i))) } outW.flush() outW.close() setWriteMode(WAIT) outW = null resetWriter() setWriteMode(CANCEL) } }"	Writes a Batch of instances
"fun truthi(): FloatMatrix? { for (i in 0 until length) { javax.swing.UIManager.put(i, if (get(i) === 0.0f) 0.0f else 1.0f) } return this }"	Maps zero to 0.0 and all non-zero values to 1.0 ( in-place ) .
"@Throws(Exception::class) fun testCallProcEscapeSequenceWithWhitespaces() { check(""CALL func1()"", ""{ call func1()}"") check(""CALL func1()"", ""{ call func1()}"") check(""CALL func1()"", ""{ \n call\nfunc1()}"") checkFail(""{ \n func1()}"") }"	Test escape sequences with additional whitespace characters
@Throws(IllegalArgumentException::class) fun EnumRowStatus(valueIndex: Long) { this(valueIndex) }	Build an < code > EnumRowStatus < /code > from a < code > Long < /code > .
"private fun generateOps708( screenData: Array<CharArray>?, screenCellData: Array<LongArray>, clipRect: java.awt.geom.Rectangle2D.Float, alphaFactor: Float, xoff: Float, yoff: Float, rowHeight: Float, currY: Float, charWidth: Float, currX: Float
 ) { var currY = curry if (reality.isIntegerPixels()) currY = Math.floor(currY.toDouble()).toFloat() val sb = StringBuffer()
 printCCBuffer(""708 CCData to render"", screenData, sb, screenCellData, StringBuffer()) sb.setLength(0) var row = 0 while (row < sage.media.sub.CCSubtitleHandler.CC_ROWS && screenData != null) { var lastCellFormat = screenCellData[row][0] if (CellFormat.getBackgroundOpacity(lastCellFormat) === DTVCCOpacity.TRANSPARENT && screenData[row][0] == 0) { lastCellFormat = CellFormat.setForeground( lastCellFormat, CellFormat.getForeground(lastCellFormat) as Byte, DTVCCOpacity.TRANSPARENT ) } rowOffsets.get(row) = -1 val rowStartY = rowHeight * row var textOffset = charWidth val maxCols: Int = screenCellData[row].length – 1 var lastRenderedCol = -1 for (col in 0 until maxCols) { if (lastCellFormat != screenCellData[row][col]) { val windowID: Int = CellFormat.getWindowID(lastCellFormat) if (CellFormat.getForegroundOpacity(lastCellFormat) !== DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity( lastCellFormat ) !== DTVCCOpacity.TRANSPARENT ) { textOffset += render708ops( screenData, screenCellData, clipRect, alphaFactor, xoff, yoff, rowHeight, currY,
 charWidth, currX, sb, lastCellFormat, rowStartY, textOffset, lastRenderedCol, row, col ) lastRenderedCol = col – 1 } else { addTo708WindowRect( windowID, xoff + currX + textOffset, yoff + rowStartY, sb.length * charWidth, rowHeight ) textOffset += sb.length * charWidth } sb.setLength(0) } lastCellFormat = screenCellData[row][col] if (CellFormat.getBackgroundOpacity(lastCellFormat) === DTVCCOpacity.TRANSPARENT && screenData[row][col] == 0) { lastCellFormat = CellFormat.setForeground( lastCellFormat, CellFormat.getForeground(lastCellFormat) as Byte, DTVCCOpacity.TRANSPARENT ) } if (CellFormat.getBackgroundOpacity(lastCellFormat) === DTVCCOpacity.TRANSPARENT && (CellFormat.getForegroundOpacity( lastCellFormat ) === DTVCCOpacity.TRANSPARENT || screenData[row][col] == 0) ) { textOffset += charWidth } else if (screenData[row][col] != 0) { if (rowOffsets.get(row) === -1) { rowOffsets.get(row) = col } sb.append(screenData[row][col]) } else { sb.append(' ') } } if (sb.length > 0) { if (CellFormat.getForegroundOpacity(lastCellFormat) !== DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity( lastCellFormat ) !== DTVCCOpacity.TRANSPARENT ) { render708ops( screenData, screenCellData, clipRect, alphaFactor, xoff, yoff, rowHeight, currY, charWidth, currX, sb, lastCellFormat, rowStartY, textOffset, lastRenderedCol, row, maxCols ) } } sb.setLength(0) row++ } for (ops in cached708WindowOps) { cachedRenderOps.addAll(ops)} }"	"Render the 708 caption text to the screen . BIG NOTE ( codefu ) : This wont draw perfectly square boxes with text on it . e.g . : back-filled with black , 2 rows , 32 columns . Text on second row `` testing '' will produce and image that is stepped . If we want to draw squares , we need to track the widest character from any font/size that is used ."
"fun putbytes2Uint8s( destUint8s: CharArray, srcBytes: ByteArray, destOffset: Int, srcOffset: Int, count: Int ) { for (i in 0 until count) { destUint8s[destOffset + i] = convertByte2Uint8(srcBytes[srcOffset + i]) } }"	Put byte [ ] into char [ ] ( we treat char [ ] as uint8 [ ] )
"fun superposeWithAngle( vec1: ComplexVector, vec2: ComplexVector, weight: Float, permutation: IntArray? ) { var positionToAdd: Int val dim: Int = vec1.getDimension() val c: ShortArray = vec2.getPhaseAngles() val coordinates: FloatArray = vec1.getCoordinates() if (permutation != null) { for (i in 0 until dim) { positionToAdd = permutation[i] shl 1 coordinates[positionToAdd] += CircleLookupTable.getRealEntry(c[i]) * weight coordinates[positionToAdd + 1] += CircleLookupTable.getImagEntry(c[i]) * weight } } else { for (i in 0 until dim) { positionToAdd = i shl 1 coordinates[positionToAdd] += CircleLookupTable.getRealEntry(c[i]) * weight coordinates[positionToAdd + 1] += CircleLookupTable.getImagEntry(c[i]) * weight } } }"	Superposes vec2 with vec1 with weight and permutation . vec1 is in CARTESIAN mode . vec2 is in POLAR mode .
"protected fun _addFieldMixIns( targetClass: Class<*>?, mixInCls: Class<*>, fields: Map<String?, AnnotatedField?> ) { val parents: MutableList<Class<*>> = ArrayList() parents.add(mixInCls) ClassUtil.findSuperTypes(mixInCls, targetClass, parents) for (mixin in parents) { for (mixinField in mixin.declaredFields) { if (!_isIncludableField(mixinField)) { continue } val name = mixinField.name val maskedField: AnnotatedField? = fields[name] if (maskedField != null) { for (a in mixinField.declaredAnnotations) { if (_annotationIntrospector.isHandled(a)) { maskedField.addOrOverride(a) } } } } } }"	Method called to add field mix-ins from given mix-in class ( and its fields ) into already collected actual fields ( from introspected classes and their super-classes )
"fun input(instance: Instance): Boolean { checkNotNull(getInputFormat()) { ""No input instance format defined"" } if (m_NewBatch) { resetQueue() m_NewBatch = false } val vals = DoubleArray(instance.numAttributes() + 1) for (i in 0 until instance.numAttributes()) { if (instance.isMissing(i)) { vals[i] = Utils.missingValue() } else { vals[i] = instance.value(i) } } m_attributeExpression.evaluateExpression(vals) var inst: Instance? = null if (instance is SparseInstance) { inst = SparseInstance(instance.weight(), vals) } else { inst = DenseInstance(instance.weight(), vals) } inst.setDataset(getOutputFormat()) copyValues(inst, false, instance.dataset(), getOutputFormat()) inst.setDataset(getOutputFormat()) push(inst) return true }"	Input an instance for filtering . Ordinarily the instance is processed and made available for output immediately . Some filters require all instances be read before producing output .
@Throws(Exception::class) fun lookup(data: String?): String? { val it: Iterator<String> = map.getPrefixedBy(data) return if (!it.hasNext()) null else it.next() }	Return the last String in the set that can be prefixed by this String ( Trie 's are stored in alphabetical order ) . Return null if no such String exist in the current set .
"fun attempt(live: LiveAnalysis, r1: Register, r2: Register): Boolean { if (isLiveAtDef(r2, r1, live)) return false if (isLiveAtDef(r1, r2, live)) return false if (split(r1, r2)) return false if (r1 === r2) return false live.merge(r1, r2) run { val e: Enumeration<RegisterOperand> = DefUse.defs(r2) while (e.hasMoreElements()) { val def: RegisterOperand = e.nextElement() DefUse.removeDef(def) def.setRegister(r1) DefUse.recordDef(def)} } val e: Enumeration<RegisterOperand> = DefUse.uses(r2) while (e.hasMoreElements()) { val use: RegisterOperand = e.nextElement() DefUse.removeUse(use) use.setRegister(r1) DefUse.recordUse(use) } return true}"	"Attempt to coalesce register r2 into register r1 . If this is legal , < ul > < li > rewrite all defs and uses of r2 as defs and uses of r1 < li > update the liveness information < li > update the def-use chains < /ul > < strong > PRECONDITION < /strong > def-use chains must be computed and valid ."
"private fun registerTarget(message: Message, virtualHost: String) {val thingId: String = getStringHeaderKey(message, MessageHeaderKey.THING_ID, ""ThingId is null"") val replyTo: String = message.getMessageProperties().getReplyTo() if (com.sun.tools.javac.util.StringUtils.isEmpty(replyTo)) { logAndThrowMessageError(message, ""No ReplyTo was set for the createThing Event."") } val amqpUri: URI = IpUtil.createAmqpUri(virtualHost, replyTo) val target: Target = controllerManagement.findOrRegisterTargetIfItDoesNotexist(thingId, amqpUri) LOG.debug(""Target {} reported online state."", thingId) lookIfUpdateAvailable(target) }"	Method to create a new target or to find the target if it already exists .
private fun returnData(ret: Any) { if (myHost != null) { myHost.returnData(ret) } }	Used to communicate a return object from a plugin tool to the main Whitebox user-interface .
fun term(): Long { return term }	Returns the responding node 's current term .
fun purgePlayer(player: Player) { zombies.remove(player.getUniqueId()) humans.remove(player.getUniqueId()) }	Removes the player from the current ADTs .
"fun RestClient( target: String?, username: String?, password: String?, asyncClient: CloseableHttpAsyncClient? ) { checkNotNull(target, ""target cannot be null"") checkNotNull(username, ""username cannot be null"") checkNotNull(password, ""password cannot be null"") target = target this.clientContext = getHttpClientContext(target, username, password) asyncClient = if (asyncClient == null) getHttpClient() else asyncClient }"	Constructs a RestClient .
"private fun createPatternHash(baseColorIndex: Int): String? { var hashSource = """" + baseColorIndex + """" var count = 0 synchronized(PatternList) { for (bp in PatternList) { if (count++ != 0) { hashSource += ""-"" } hashSource += bp.toString() } } return hashSource }"	Creates a uniq string for combination of patterns
@Throws(IOException::class) fun close() { super.close() disposerRecord.dispose() stream = null cache = null cacheFile = null com.sun.imageio.stream.StreamCloser.removeFromQueue(closeAction)}	"Closes this < code > FileCacheImageInputStream < /code > , closing and removing the cache file . The source < code > InputStream < /code > is not closed ."
"@Throws(IOException::class) fun importContent(sessionId: String, sourcePath: String?): Uri? { val sourceFile = File(sourcePath) var targetPath: String? = ""/"" + sessionId + ""/upload/"" + sourceFile.getName() targetPath = createUniqueFilename(targetPath) copyToVfs(sourcePath, targetPath) return vfsUri(targetPath) }"	Copy device content into vfs . All imported content is stored under /SESSION_NAME/ The original full path is retained to facilitate browsing The session content can be deleted when the session is over
"fun createProjectClosedEvent( project: ProjectDescriptor?, closingBeforeOpening: Boolean ): ProjectActionEvent? { return ProjectActionEvent(project, ProjectAction.CLOSED, closingBeforeOpening) }"	Creates a Project Closed Event .
"fun initiateItemEvent( player: EntityPlayer?, itemStack: ItemStack?, event: Int, limitRange: Boolean ) { try { if (NetworkManager_initiateItemEvent == null) NetworkManager_initiateItemEvent = Class.forName( getPackage().toString() + "".core.network.NetworkManager"" ).getMethod( ""initiateItemEvent"", EntityPlayer::class.java, ItemStack::class.java, Integer.TYPE, java.lang.Boolean.TYPE ) if (instance == null) instance = getInstance() NetworkManager_initiateItemEvent.invoke(instance, player, itemStack, event, limitRange) } catch (e: Exception) { throw RuntimeException(e) } }"	"Immediately send an event for the specified Item to the clients in range . The item should implement INetworkItemEventListener to receive the event . If this method is being executed on the client ( i.e . Singleplayer ) , it 'll just call INetworkItemEventListener.onNetworkEvent ( if implemented by the item ) ."
fun elements(): Enumeration<V?>? { return ValueIterator }	Returns an enumeration of the values in this table .
"private fun trackerAt(zone: StendhalRPZone, x: Int, y: Int): Boolean { val list: List<Entity> = zone.getEntitiesAt(x, y) for (entity in list) { if (entity is ExpirationTracker) { return true } } return false }"	Checks to see if an ExpirationTracker is already at a given coordinate to prevent multiple one from accumulating in the database
"fun segment(index: Long): javax.swing.text.Segment? { assertOpen() if (currentSegment != null && currentSegment.validIndex(index)) return currentSegment val segment: Map.Entry<Long, javax.swing.text.Segment> = segments.floorEntry(index) return if (segment != null) segment.value else null }"	Returns the segment for the given index .
"@DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2014-09-03 15:01:20.138 -0400"", hash_original_method = ""5CC57CD7C5B9408E54C315A9BE16050C"", hash_generated_method = ""E0C143C4A578FB33A41B66D46278449D"" ) fun nextInt(least: Int, bound: Int): Int { require(least < bound) return nextInt(bound - least) + least }"	"Returns a pseudorandom , uniformly distributed value between the given least value ( inclusive ) and bound ( exclusive ) ."
0 until n) { val b = if (k.testBit(i)) 1 else 0 val bp = 1 - b R[bp] = R[bp].twicePlus(R[b]) } return R[0]	Joye 's double-add algorithm .
"@Throws(Exception::class) fun listItemsSortedSecure() { println(""Secure Systems Inc. - list items"") var order: String = input(""order (id, name)?"") if (!order.matches(""[a-zA-Z0-9_]*"")) { order = ""id"" } try { val rs: ResultSet = stat.executeQuery(""SELECT ID, NAME FROM ITEMS ORDER BY $order"") while (rs.next()) { println(rs.getString(1).toString() + "": "" + rs.getString(2)) } } catch (e: SQLException) { System.out.println(e) } }"	List items using a specified sort order . The method is secure as the user input is validated before use . However the database has no chance to verify this .
@Throws(IOException::class) private fun readInt(`is`: InputStream): Int { return `is`.read() shl 24 or (`is`.read() shl 16) or (`is`.read() shl 8) or `is`.read() }	Parses a 32-bit int .
"fun enableConfirmButtons() { confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(""TipConfirmChangesSheet"")) confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(""TipConfirmAllSheet"")) if (_cvModel.getProgrammer() != null && !_cvModel.getProgrammer().getCanRead()) { confirmChangesButton.setEnabled(false) confirmAllButton.setEnabled(false) confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(""TipNoRead"")) confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(""TipNoRead"")) } else { confirmChangesButton.setEnabled(true) confirmAllButton.setEnabled(true) } }"	"Enable the compare all and compare changes button if possible . This checks to make sure this is appropriate , given the attached programmer 's capability ."
"private fun eventName(taskType: String, taskNum: Int, evtType: String): String? { assert(nodeId != null) return ""$taskType $taskNum $evtType $nodeId"" }"	Generate name that consists of some event information .
"fun eInverseRemove( otherEnd: InternalEObject?, featureID: Int, msgs: NotificationChain? ): NotificationChain? { when (featureID) { UmplePackage.ACTION___ANONYMOUS_ACTION_11 -> return (getAnonymous_action_1_1() as InternalEList<*>).basicRemove( otherEnd, msgs ) UmplePackage.ACTION___ANONYMOUS_ACTION_21 -> return (getAnonymous_action_2_1() as InternalEList<*>).basicRemove( otherEnd, msgs ) } return super.eInverseRemove(otherEnd, featureID, msgs) }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun showPathInFileBrowser(path: Path) { try { val isFolder: Boolean = Files.isDirectory(path) val isFile = !isFolder if (isFile && LEnv.OS === OpSys.WINDOWS) { ProcessBuilder(""explorer.exe"", ""/select,"", path.toAbsolutePath().toString()).start() } else java.awt.Desktop.getDesktop() .open(if (isFolder) path.toFile() else path.getParent().toFile()) } catch (ie: IOException) { LEnv.LOGGER.warning(""Failed to open file browser!"", ie) } }"	"Opens the specified file or folder in the default file browser application of the user 's OS . < p > If a file is specified , on Windows it will also be selected . < /p >"
"private fun <T> processExtremes( forX: org.graalvm.compiler.core.common.type.Stamp, forY: org.graalvm.compiler.core.common.type.Stamp, op: BiFunction<Long, Long, T> ): T { val xStamp: org.graalvm.compiler.core.common.type.IntegerStamp = forX as org.graalvm.compiler.core.common.type.IntegerStamp val yStamp: org.graalvm.compiler.core.common.type.IntegerStamp = forY as org.graalvm.compiler.core.common.type.IntegerStamp val kind: jdk.vm.ci.meta.JavaKind = getStackKind() assert(kind == jdk.vm.ci.meta.JavaKind.Int || kind == jdk.vm.ci.meta.JavaKind.Long) val xExtremes: LongArray = getUnsignedExtremes(xStamp) val yExtremes: LongArray = getUnsignedExtremes(yStamp) var min = Long.MAX_VALUE var max = Long.MIN_VALUE for (a in xExtremes) { for (b in yExtremes) { val result: Long = if (kind == jdk.vm.ci.meta.JavaKind.Int) multiplyHighUnsigned( a.toInt(), b.toInt() ) else multiplyHighUnsigned(a, b) min = Math.min(min, result) max = Math.max(max, result) } } return op.apply(min, max) }"	"Determines the minimum and maximum result of this node for the given inputs and returns the result of the given BiFunction on the minimum and maximum values . Note that the minima and maxima are calculated using signed min/max functions , while the values themselves are unsigned ."
"fun toSignatureString(): String? { val sb = StringBuilder() val accessLevel: String = convertModifiersToAccessLevel(mModifier) if ("""" != accessLevel) { sb.append(accessLevel).append("" "") } if (!JDiffType.INTERFACE.equals(mClassType)) { val modifierString: String = convertModifersToModifierString(mModifier) if ("""" != modifierString) { sb.append(modifierString).append("" "") } sb.append(""class "") } else { sb.append(""interface "") } sb.append(mShortClassName) if (mExtendedClass != null) { sb.append("" extends "").append(mExtendedClass).append("" "") } if (implInterfaces.size() > 0) { sb.append("" implements "") for (x in 0 until implInterfaces.size()) { val interf: String = implInterfaces.get(x) sb.append(interf) if (x + 1 != implInterfaces.size()) { sb.append("", "") } } } return sb.toString() }"	Convert the class into a printable signature string .
fun showPopup() { if (getPopup() != null) { getPopup().setVisible(true) } }	"if a JPopupMenu is set , it is displayed again . Displaying this dialog closes any JPopupMenu automatically ."
fun isGame(): Boolean { return true }	"Determines if this marker is a game . Default is true , so override is only necessary if implementation is not a game ."
private fun FigureLayerComparator() {}	Creates a new instance .
fun normalizedDistribution(): TDoubleDoubleHashMap? { return normalizedDistribution(absoluteDistribution()) }	Returns a histogram of all samples where the values are normalized so that the sum of all samples equals one .
"@Throws(Throwable::class) private fun waitForUsers(hostUri: URI, authToken: String) { val usersLink: URI = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK) val numberUsers = arrayOfNulls<Int>(1) for (i in 0..19) { val get: Operation = Operation.createGet(usersLink).forceRemote().addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken).setCompletion(null) this.host.testStart(1) this.host.send(get) this.host.testWait() if (numberUsers[0] == 2) { break } Thread.sleep(250) } assertTrue(numberUsers[0] == 2) }"	"Supports createUsers ( ) by waiting for two users to be created . They are n't created immediately , so this polls ."
"@Synchronized @Throws(IOException::class) fun send(buffer: ByteArray?, offset: Int, len: Int): Int { if (m_state !== PseudoTcpState.TCP_ESTABLISHED) { throw IOException(""Socket not connected"") } val available_space: Long available_space = m_sbuf.getWriteRemaining() if (available_space == 0L) { m_bWriteEnable = true return 0 } val written: Int = queue(buffer, offset, len, false) attemptSend(SendFlags.sfNone) return written }"	Enqueues data in the send buffer
fun SampleAxioms() { super() }	De-serialization ctor .
"@Throws(IllegalArgumentException::class) fun validateTagTypeKey(tagTypeKey: TagTypeKey) { Assert.notNull(tagTypeKey, ""A tag type key must be specified."") tagTypeKey.setTagTypeCode( alternateKeyHelper.validateStringParameter( ""tag type code"", tagTypeKey.getTagTypeCode() ) ) }"	Validates a tag type key . This method also trims the key parameters .
"fun addCharacterToOutput( characterEntry: Map.Entry<Char?, GrayscaleMatrix?>, sourceImagePixels: IntArray?, tileX: Int, tileY: Int, imageWidth: Int ) { this.output.append(characterEntry.key) if ((tileX + 1) * this.characterCache.getCharacterImageSize().getWidth() === imageWidth) { this.output.append(System.lineSeparator()) } }"	Append choosen character to StringBuffer .
@VisibleForTesting fun chooseTableSize(setSize: Int): Int { if (setSize == 1) { return 2 } var tableSize = Integer.highestOneBit(setSize - 1) shl 1 while (tableSize * DESIRED_LOAD_FACTOR < setSize) { tableSize = tableSize shl 1 } return tableSize }	Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation . The returned size is the smallest power of two that can hold setSize elements with the desired load factor .
fun validateMinimum() { var newMin: Double try { newMin = this.minimumRangeValue.getText().toDouble() if (newMin >= this.maximumValue) { newMin = this.minimumValue } } catch (e: NumberFormatException) { newMin = this.minimumValue } this.minimumValue = newMin this.minimumRangeValue.setText(java.lang.Double.toString(this.minimumValue)) }	Revalidate the range minimum .
fun init(actorSystem: ActorSystem) { if (instance == null) { instance = actorSystem.actorOf(Props.create(BatchSigner::class.java)) } }	Initializes the batch signer with the given actor system .
"private fun dump(pd: PrintData) { dumpHeader(pd) for (i in 0 until pd.getRowCount()) dumpRow(pd, i) }"	Dump all PrintData - header and rows
fun isHIGHER(): Boolean { return value === HIGHER }	Is the condition code HIGHER ?
"fun rotateZ(ang: Double): Matrix4x3d? { return rotateZ(ang, this) }"	"Apply rotation about the Z axis to this matrix by rotating the given amount of radians . < p > When used with a right-handed coordinate system , the produced rotation will rotate a vector counter-clockwise around the rotation axis , when viewing along the negative axis direction towards the origin . When used with a left-handed coordinate system , the rotation is clockwise . < p > If < code > M < /code > is < code > this < /code > matrix and < code > R < /code > the rotation matrix , then the new matrix will be < code > M * R < /code > . So when transforming a vector < code > v < /code > with the new matrix by using < code > M * R * v < /code > , the rotation will be applied first ! < p > Reference : < a href= '' http : //en.wikipedia.org/wiki/Rotation_matrix # Basic_rotations '' > http : //en.wikipedia.org < /a >"
"@Throws(IOException::class) protected fun openConnection(url: URL?, proxy: Proxy?): URLConnection? { require(!(url == null || proxy == null)) { ""url == null || proxy == null"" } return sun.net.www.protocol.ftp.FtpURLConnection(url, proxy) }"	"Returns a connection , which is established via the < code > proxy < /code > , to the FTP server specified by this < code > URL < /code > . If < code > proxy < /code > is DIRECT type , the connection is made in normal way ."
"private fun saveMacro(): Boolean { if (firstTime) { try { Thread.sleep(firstTimeSleep) } catch (e: InterruptedException) { e.printStackTrace() } } firstTime = false val macroAccy = ByteArray(macroSize) var index = 0 var accyNum = 0 accyNum = getAccyRow(macroAccy, index, textAccy1, accyTextField1, cmdButton1) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy2, accyTextField2, cmdButton2) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum getAccyRow(macroAccy, index, textAccy3, accyTextField3, cmdButton3) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy4, accyTextField4, cmdButton4) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy5, accyTextField5, cmdButton5) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy6, accyTextField6, cmdButton6) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy7, accyTextField7, cmdButton7) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } if (!isUsb) { accyNum = getAccyRow(macroAccy, index, textAccy8, accyTextField8, cmdButton8) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } accyNum = getAccyRow(macroAccy, index, textAccy9, accyTextField9, cmdButton9) if (accyNum < 0) { return false } if (accyNum > 0) { index += 2 } } accyNum = getAccyRow(macroAccy, index, textAccy10, accyTextField10, cmdButton10) if (accyNum < 0) { javax.swing.JOptionPane.showMessageDialog( this, rb.getString(""EnterMacroNumberLine10""), rb.getString(""NceMacro""), javax.swing.JOptionPane.ERROR_MESSAGE ) return false } processMemory(false, true, macroNum, macroAccy) return true }"	Writes all bytes to NCE CS memory as long as there are no user input errors
private fun matchesMobile4g(ident: NetworkIdentity): Boolean { ensureSubtypeAvailable() if (ident.mType === TYPE_WIMAX) { return true } else if (matchesMobile(ident)) { when (getNetworkClass(ident.mSubType)) { NETWORK_CLASS_4_G -> return true } } return false }	Check if mobile network classified 4G with matching IMSI .
"@Throws(Exception::class) fun writeToBuffer(buffer: ByteBuf?) { if (id !== -1) { Type.VAR_INT.write(buffer, id) } if (readableObjects.size() > 0) { packetValues.addAll(readableObjects) readableObjects.clear() } var index = 0 for (packetValue in packetValues) { try { var value: Any? = packetValue.getValue() if (value != null) { if (!packetValue.getKey().getOutputClass().isAssignableFrom(value.javaClass)) { if (packetValue.getKey() is TypeConverter<*, *>) { value = (packetValue.getKey() as TypeConverter<*, *>).from(value) } else { println( ""Possible type mismatch: "" + value.javaClass.name + "" -> "" + packetValue.getKey() .getOutputClass() ) } } } packetValue.getKey().write(buffer, value) } catch (e: Exception) { throw InformativeException(e).set(""Index"", index) .set(""Type"", packetValue.getKey().getTypeName()).set( ""Packet ID"", id ).set(""Data"", packetValues) } index++ } writeRemaining(buffer) }"	Write the current output to a buffer .
"fun RandomDecisionTree( numFeatures: Int, maxDepth: Int, minSamples: Int, pruningMethod: TreePruner.PruningMethod?, testProportion: Double ) { super(maxDepth, minSamples, pruningMethod, testProportion) setRandomFeatureCount(numFeatures) }"	Creates a new Random Decision Tree
"@Throws(SAXException::class) protected fun fireCommentEvent(chars: CharArray?, start: Int, length: Int) { if (m_tracer != null) { flushMyWriter() m_tracer.fireGenerateEvent( com.sun.org.apache.xml.internal.serializer.SerializerTrace.EVENTTYPE_COMMENT, String( chars!!, start, length ) ) } }"	Report the comment trace event
"private fun init(context: Context, attrs: AttributeSet, theme: RuqusTheme) { inflate(context, R.layout.rqv_card, this) outlineView = findViewById(R.id.outline) as FrameLayout outlineTextView = findViewById(R.id.outline_text) as TextView cardView = findViewById(R.id.card) as CardView cardTextView = findViewById(R.id.card_text) as TextView setTheme(theme)
val typedArray: TypedArray = context.obtainStyledAttributes(attrs, R.styleable.RQVCard) mode = if (typedArray.getInt( R.styleable.RQVCard_rqv_card_mode, 0 ) == 0 ) Mode.OUTLINE else Mode.CARD outlineTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_outline_text)) cardTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_card_text)) typedArray.recycle()}"	Initialize our view .
fun onUndeploy(ldr: ClassLoader) { for (cls in descByCls.keySet()) { if (ldr == cls.classLoader) descByCls.remove(cls) } javax.swing.text.html.HTML.Tag.U.clearClassCache(ldr)}	Undeployment callback invoked when class loader is being undeployed . Some marshallers may want to clean their internal state that uses the undeployed class loader somehow .
"fun compare(o1: Long, o2: Long): Int { if (o1 < o2) return 1 return if (o1 > o2) -1 else 0 }"	Comparator puts the entries into descending order by the query execution time ( longest running queries are first ) .
fun testResourceParameterOfListType() { doTest() }	Tests that a ResourceParameterInspection error is generated for a resource parameter of List type .
@Throws(ParseException::class) fun add(s: String?): TeXFormula? { if (s != null && s.length != 0) { textStyle = null add(TeXFormula(s)) } return this }	Parses the given string and inserts the resulting formula at the end of the current TeXFormula .
"fun defaultRecommendations(productId: Int): ResponseEntity<List<Recommendation?>?>? { LOG.warn(""Using fallback method for recommendation-service"") return util.createResponse( Arrays.asList( Recommendation( productId, 1, ""Fallback Author 1"", 1, ""Fallback Content 1"" ) ), HttpStatus.OK ) }"	Fallback method for getRecommendations ( )
"private fun cmd_annotateDifference() { val previousValue: BigDecimal val actualValue: BigDecimal val difference: BigDecimal previousValue = v_previousBalance.getValue() as BigDecimal actualValue = v_ActualBalance.getValue() as BigDecimal difference = actualValue.subtract(previousValue) val cashBook = MCashBook(p_ctx, p_pos.getC_CashBook_ID(), null) val today: Timestamp = TimeUtil.getDay(System.currentTimeMillis()) var cash: MCash = MCash.get(p_ctx, cashBook.getC_CashBook_ID(), today, null) if (cash != null && cash.get_ID() !== 0 && difference.compareTo(cash.getStatementDifference()) !== 0) { val cl = MCashLine(cash) cl.setCashType(MCashLine.CASHTYPE_Difference) cl.setAmount(difference) cl.setDescription( Msg.translate( p_pos.getCtx(), ""Cash Scrutiny -> Before: "" ) + previousValue + "" Now: "" + actualValue ) cl.saveEx() } cash = MCash.get(p_pos.getCtx(), p_pos.getC_CashBook_ID(), today, null) v_previousBalance.setValue(cash.getEndingBalance()) v_ActualBalance.setValue(Env.ZERO) v_difference.setValue(Env.ZERO) }"	Annotate the difference between previous balance and actual from cash scrutiny in the cash book
fun hasJpgThumbnail(): Boolean { if (getThumbnailType() !== ExifDirectory.COMPRESSION_JPEG) return false val thumbData: ByteArray thumbData = try { val exif: ExifDirectory = metadata.getDirectory(ExifDirectory::class.java) as ExifDirectory exif.getThumbnailData() } catch (e: MetadataException) { return false } if (thumbData.size > 2) { var magicNumber: Int magicNumber = thumbData[0] and 0xFF shl 8 magicNumber = magicNumber or (thumbData[1] and 0xFF) if (magicNumber == ImageMetadataReader.JPEG_FILE_MAGIC_NUMBER) return true } return false }	"Performs checks to determine if the image has a JPG thumbnail in the EXIF data . < p > The EXIF TAG_COMPRESION , and the magic number at the beginning of the thumbnail bytes are used to verify that the thumb is in JPG format"
"@Throws(InterpreterException::class) private fun waitForRScriptInitialized() { synchronized(rScriptInitializeNotifier) { val startTime = System.nanoTime() while (rScriptInitialized === false && rScriptRunning && System.nanoTime() - startTime < 10L * 1000 * 1000000) { try { rScriptInitializeNotifier.wait(1000) } catch (e: InterruptedException) { logger.error(e.message, e) } } } var errorMessage = """" try { initialOutput.flush() errorMessage = String(initialOutput.toByteArray()) } catch (e: IOException) { e.printStackTrace() } if (rScriptInitialized === false) { throw InterpreterException(""sparkr is not responding $errorMessage"") } }"	Wait until src/main/resources/R/zeppelin_sparkr.R is initialized and call onScriptInitialized ( )
private fun DefaultUnitConverter() {}	Constructs a DefaultUnitConverter and registers a listener that handles changes in the look & amp ; feel .
"fun morpha(text: String, tags: Boolean): String? { if (text.isEmpty()) { return """" } val textParts: Array<String> = whitespace.split(text) val result = StringBuilder() try { for (textPart in textParts) { val morpha = Morpha(StringReader(textPart), tags) if (result.length != 0) { result.append("" "") } result.append(morpha.next()) } } catch (e: Error) { return text } catch (e: IOException) { return text } return result.toString() }"	Run the morpha algorithm on the specified string .
@Throws(IOException::class) protected fun readUnzipedResponse(input: InputStream?) { super.readResponse(input) }	This method can be overridden instead of readResponse
@Throws(Exception::class) fun events(): EventStream<S?>? { return EventStream.empty() }	"Returns a stream of events that should be recorded . By default , an empty stream returned ."
"@Throws(Exception::class) operator fun invoke( obj: java.rmi.Remote?, method: Method?, params: Array<Any?>?, opnum: Long ): Any? { var force = false var localRef: java.rmi.server.RemoteRef var exception: Exception? = null synchronized(this) { if (sun.jvm.hotspot.oops.CellTypeState.ref == null) { localRef = activate(force) force = true } else { localRef = sun.jvm.hotspot.oops.CellTypeState.ref } } for (retries in MAX_RETRIES downTo 1) { try { return localRef.invoke(obj, method, params, opnum) } catch (e: java.rmi.NoSuchObjectException) { exception = e } catch (e: ConnectException) { exception = e } catch (e: UnknownHostException) { exception = e } catch (e: java.rmi.ConnectIOException) { exception = e } catch (e: MarshalException) { throw e } catch (e: java.rmi.ServerError) { throw e } catch (e: java.rmi.ServerException) { throw e } catch (e: RemoteException) { synchronized(this) { if (localRef === sun.jvm.hotspot.oops.CellTypeState.ref) { sun.jvm.hotspot.oops.CellTypeState.ref = null } } throw e } if (retries > 1) { synchronized(this) { if (localRef.remoteEquals(sun.jvm.hotspot.oops.CellTypeState.ref) || sun.jvm.hotspot.oops.CellTypeState.ref == null) { var newRef: java.rmi.server.RemoteRef = activate(force) if (newRef.remoteEquals(localRef) && exception is java.rmi.NoSuchObjectException && force == false) { newRef = activate(true) } localRef = newRef force = true } else { localRef = sun.jvm.hotspot.oops.CellTypeState.ref force = false } } } } throw exception!! }"	"Invoke method on remote object . This method delegates remote method invocation to the underlying ref type . If the underlying reference is not known ( is null ) , then the object must be activated first . If an attempt at method invocation fails , the object should force reactivation . Method invocation must preserve `` at most once '' call semantics . In RMI , `` at most once '' applies to parameter deserialization at the remote site and the remote object 's method execution . `` At most once '' does not apply to parameter serialization at the client so the parameters of a call do n't need to be buffered in anticipation of call retry . Thus , a method call is only be retried if the initial method invocation does not execute at all at the server ( including parameter deserialization ) ."
"fun lookupCacheSizeTipText(): String? { return ""Set the maximum size of the lookup cache of evaluated subsets. This is "" + ""expressed as a multiplier of the number of attributes in the data set. "" + ""(default = 1)."" }"	Returns the tip text for this property
"private fun providerToJson(provider: Provider?): SimpleObject? { val jsonForm = SimpleObject() if (provider != null) { jsonForm.add(USER_ID, provider.getUuid()) jsonForm.add(FULL_NAME, provider.getName()) val person: Person = provider.getPerson() if (person != null) { jsonForm.add(GIVEN_NAME, person.getGivenName()) jsonForm.add(FAMILY_NAME, person.getFamilyName()) } } return jsonForm }"	Builds a SimpleObject describing the given Provider .
"@Throws(XMLStreamException::class) operator fun next(): Int { log.fine(""next()"") if (event === START_DOCUMENT) { event = javax.xml.stream.XMLStreamConstants.START_ELEMENT elementIndex.currentElement = parser.getDocument().getBody().getElement() } else if (event === javax.xml.stream.XMLStreamConstants.START_ELEMENT) { elementIndex.index = 0 event = nextInElement(false) } else if (event === ATTRIBUTE) { elementIndex.index = 0 event = nextInElement(false) } else if (event === CHARACTERS) { elementIndex.index++ event = nextInElement(false) } else if (event === SPACE) { elementIndex.index++ event = nextInElement(false) } else if (event === ENTITY_REFERENCE) { elementIndex.index++ event = nextInElement(false) } else if (event === PROCESSING_INSTRUCTION) { elementIndex.index++ event = nextInElement(false) } else if (event === javax.xml.stream.XMLStreamConstants.END_ELEMENT) { if (parents.isEmpty()) { event = END_DOCUMENT } else { elementIndex = parents.pop() elementIndex.index++ event = nextInElement(false) } } else if (event === END_DOCUMENT) { throw XMLStreamException(""End of coument reached!"") } else { throw XMLStreamException(""Invalid event state!"") } log.log(Level.FINE, ""next(): {0}"", event) return event }"	"Get next parsing event - a processor may return all contiguous character data in a single chunk , or it may split it into several chunks . If the property javax.xml.stream.isCoalescing is set to true element content must be coalesced and only one CHARACTERS event must be returned for contiguous element content or CDATA Sections . By default entity references must be expanded and reported transparently to the application . An exception will be thrown if an entity reference can not be expanded . If element content is empty ( i.e . content is `` '' ) then no CHARACTERS event will be reported . < p > This method marks the current element and index using the elementIndex structure . Besides a queue of parents element index is maintained to cross over all element hierarchy. < /p > < p > The WbXMLStreamReader only manages the following states : < /p > < ul > < li > START_DOCUMENT < /li > < li > PROCESSING_INSTRUCTION < /li > < li > START_ELEMENT < /li > < li > ATTRIBUTE < /li > < lI > CHARACTERS < /li > < li > END_ELEMENT < /li > < li > SPACE < /li > < li > END_DOCUMENT < /li > < li > ENTITY_REFERENCE < /li > < /ul > < p > Therefore the following element does no matter in this stream reader : < /p > < ul > < li > CDATA ( CHARACTERS are used always ) . < /li > < li > COMMENT ( no comments in WBXML ) . < /li > < li > DTD ( no DTD section ) < /li > < li > ENTITY_DECLARATION < /li > < li > NAMESPACE < /li > < li > NOTATION DECLARATION < /li > < /ul >"
"@Synchronized fun findAllRelationshipsTo(vertex: sun.security.provider.certpath.Vertex?): List<Relationship?>? { val query: Query = this.entityManager.createQuery(""Select r from Relationship r where r.target = :vertex or r.type = :vertex"") setHints(query) query.setParameter(""vertex"", vertex) return query.getResultList() }"	Find all relationships related to the vertex or of the vertex relationship type .
"fun convertMethodSignature( inv: com.sun.org.apache.bcel.internal.generic.InvokeInstruction, cpg: com.sun.org.apache.bcel.internal.generic.ConstantPoolGen? ): String? { return convertMethodSignature( inv.getClassName(cpg), inv.getName(cpg), inv.getSignature(cpg))}"	Convenience method for generating a method signature in human readable form .
fun count(obj: Selector): Int { return if (obj.getMask() and Selector.MASK_INSTANCE > 0) { if (device.findObject(obj.toUiSelector()).exists()) 1 else 0 } else { var sel: UiSelector = obj.toUiSelector() if (!device.findObject(sel).exists()) return 0 var low = 1 var high = 2 sel = sel.instance(high - 1) while (device.findObject(sel).exists()) { low = high high = high * 2 sel = sel.instance(high - 1) } while (high > low + 1) { val mid = (low + high) / 2 sel = sel.instance(mid - 1) if (device.findObject(sel).exists()) low = mid else high = mid } low } }	Get the count of the UiObject instances by the selector
private fun isComputeHost(computeDescription: ComputeDescription): Boolean { val supportedChildren: List<String> = computeDescription.supportedChildren return supportedChildren != null && supportedChildren.contains(ComputeType.VM_GUEST.name())}	Returns if the given compute description is a compute host or not .
"@Throws(Exception::class) fun prepareTestDir(logDirName: String?): File? { val logDir = File(logDirName) val path = FilePath(logDir.getAbsolutePath()) fileIO.delete(path, true) fileIO.mkdir(path) return logDir }"	Create an empty test directory or if the directory exists remove any files within it .
fun receiveErrorqueryAssociatedPortsForProcessor(e: Exception?) {}	auto generated Axis2 Error handler override this method for handling error response from queryAssociatedPortsForProcessor operation
@Throws(CloneNotSupportedException::class) fun clone(): Any? { return super.clone() }	Returns a clone of this instance .
"@Throws(IOException::class) private fun dump(from: File, out: OutputStream) { writeHeader(from, out) var `in`: FileInputStream? = null try { `in` = FileInputStream(from) var count: Int while (`in`.read(buffer).also { count = it } != -1) { out.write(buffer, 0, count) } } finally { closeQuietly(`in`) } }"	Copies from a file to an output stream .
fun lastLocalId(): Long { return cntGen.get() }	Gets last generated local ID .
"fun RoleEventImpl( region: Region?, op: Operation?, callbackArgument: Any?, originRemote: Boolean, distributedMember: DistributedMember?, requiredRoles: Set<*>? ) { super(region, op, callbackArgument, originRemote, distributedMember) requiredRoles = Collections.unmodifiableSet(requiredRoles) }"	Constructs new RoleEventImpl .
"fun QLFFilesCollection( directory: File?, extension: String?, featureClass: Class<F?>?, pathRegexFind: String?, pathRegexRep: String? ) { this(featureClass, pathRegexFind, pathRegexRep) processDirs(directory, extension) }"	"Construct the collection from the files in the given directory that have the given file extension . All the files are expected to contain features of the given feature class . The file search is recursive , and will also look in sub-directories of the specified directory . The final two parameters allow a regular-expression find and replace operation for be performed on the found filenames in order to create the document identifier for each QLFDocument . This is useful to ensure only the document name is stored in the index , rather than the absolute path ."
"@Throws(IOException::class) @JvmStatic fun main(args: Array<String>) { val enableOutput = true val outputToFile = false val inputFolder: String = LrMc::class.java.getClassLoader().getResource(""workload/planetlab"").getPath() val outputFolder = ""output"" val workload = ""20110303"" val vmAllocationPolicy = ""lr"" val vmSelectionPolicy = ""mc"" val parameter = ""1.2"" PlanetLabRunner( enableOutput, outputToFile, inputFolder, outputFolder, workload, vmAllocationPolicy, vmSelectionPolicy, parameter ) }"	The main method .
"fun make(bulk: BulkTest) { val c: Class<*> = bulk.getClass() val all: Array<Method> = c.methods for (i in all.indices) { if (isTest(all[i])) addTest(bulk, all[i]) if (isBulk(all[i])) addBulk(bulk, all[i]) } }"	Appends all the simple tests and bulk tests defined by the given instance 's class to the current TestSuite .
"@Throws(IOException::class, ClassNotFoundException::class) private fun readObject(`in`: ObjectInputStream) { val inName = `in`.readObject() as String val inDescription = `in`.readObject() as String val inValue = `in`.readObject() val inClass = `in`.readObject() as Class<*> val inUserModifiable = `in`.readBoolean() Assert.assertTrue(inName != null) Assert.assertTrue(inDescription != null) Assert.assertTrue(inValue != null) Assert.assertTrue(inClass != null) this.deserialized = true this.name = inName setInternalState(inDescription, inValue, inClass, inUserModifiable) }"	Override readObject which is used in serialization . Customize serialization of this exception to avoid escape of InternalRole which is not Serializable .
private fun returnData(ret: Any) { if (myHost != null) { myHost.returnData(ret) } }	Used to communicate a return object from a plugin tool to the main Whitebox user-interface .
"fun escape(s: String?): String? { if (s == null) return null val sb = StringBuffer() escape(s, sb) return sb.toString() }"	"Escape quotes , \ , / , \r , \n , \b , \f , \t and other control characters ( U+0000 through U+001F ) ."
"fun clone(): ArrayDeque<E>? { return try { val result: ArrayDeque<E> = super.clone() as ArrayDeque<E> result.elements = Arrays.copyOf(elements, elements.length) result } catch (e: CloneNotSupportedException) { throw AssertionError() } }"	Returns a copy of this deque .
"fun generateCode(currentScope: org.graalvm.compiler.lir.gen.LIRGeneratorTool.BlockScope?) { if (this.bits and IsReachable === 0) { return } generateInit@{ if (this.initialization == null) break@generateInit if (binding.resolvedPosition < 0) { if (this.initialization.constant !== Constant.NotAConstant) break@generateInit this.initialization.generateCode(currentScope, false) break@generateInit } this.initialization.generateCode(currentScope, true) } }"	Code generation for a local declaration : i.e. & nbsp ; normal assignment to a local variable + unused variable handling
"@Throws(IOException::class) fun isPotentialValidLink(file: File): Boolean { var isPotentiallyValid: Boolean FileInputStream(file).use { fis -> val minimumLength = 0x64 isPotentiallyValid = file.isFile() && file.getName().toLowerCase() .endsWith("".lnk"") && fis.available() >= minimumLength && isMagicPresent( com.sun.org.apache.xml.internal.security.utils.XMLUtils.getBytes( fis, 32 ) ) } return isPotentiallyValid }"	"Provides a quick test to see if this could be a valid link ! If you try to instantiate a new WindowShortcut and the link is not valid , Exceptions may be thrown and Exceptions are extremely slow to generate , therefore any code needing to loop through several files should first check this ."
"fun decideMove(state: IGameState): IGameMove? { if (state.isDraw()) return null if (state.isWin()) return null val moves: Collection<IGameMove> = logic.validMoves(this, state) return if (moves.size == 0) { null } else { val mvs: Array<IGameMove> = moves.toArray(arrayOf<IGameMove>()) val idx = (Math.random() * moves.size).toInt() mvs[idx] } }"	"Randomly make a move based upon the available logic of the game . Make sure you check that the game is not already won , lost or drawn before calling this method , because you"
fun nextPowerOf2(x: Int): Int { var i: Long = 1 while (i < x && i < Int.MAX_VALUE / 2) { i += i } return i.toInt() }	"Get the value that is equal or higher than this value , and that is a power of two ."
"fun inverseTransform(viewPoint: java.awt.geom.Point2D): java.awt.geom.Point2D? { val viewCenter: java.awt.geom.Point2D = getViewCenter() val viewRadius: Double = getViewRadius() val ratio: Double = getRatio() var dx: Double = viewPoint.getX() - viewCenter.getX() val dy: Double = viewPoint.getY() - viewCenter.getY() dx *= ratio val pointFromCenter: java.awt.geom.Point2D = java.awt.geom.Point2D.Double(dx, dy) val polar: PolarPoint = PolarPoint.cartesianToPolar(pointFromCenter) var radius: Double = polar.getRadius() if (radius > viewRadius) return delegate.inverseTransform(viewPoint) radius /= viewRadius radius = Math.abs(Math.tan(radius)) radius /= Math.PI / 2 radius *= viewRadius val mag = Math.tan(Math.PI / 2 * magnification) radius /= mag polar.setRadius(radius) val projectedPoint: java.awt.geom.Point2D = PolarPoint.polarToCartesian(polar) projectedPoint.setLocation(projectedPoint.getX() / ratio, projectedPoint.getY()) val translatedBack: java.awt.geom.Point2D = java.awt.geom.Point2D.Double( projectedPoint.getX() + viewCenter.getX(), projectedPoint.getY() + viewCenter.getY() ) return delegate.inverseTransform(translatedBack) }"	override base class to un-project the fisheye effect
"private fun iconBoundsIntersectBar(barBounds: RectF, icon: Rect, scaleFactor: Double): Boolean { val iconL: Int = icon.left + javax.swing.Spring.scale(icon.width(), scaleFactor.toFloat()) val iconT: Int = icon.top + javax.swing.Spring.scale(icon.height(), scaleFactor.toFloat()) val iconR: Int = icon.right - javax.swing.Spring.scale(icon.width(), scaleFactor.toFloat()) val iconB: Int = icon.bottom - javax.swing.Spring.scale(icon.height(), scaleFactor.toFloat()) return barBounds.intersects( iconL.toFloat(), iconT.toFloat(), iconR.toFloat(), iconB.toFloat() ) }"	Helper method for calculating intersections for control icons and bars .
"fun closeRegistration() { flushDeferrables() for ((_, value): Map.Entry<String?, ClassPlugins> in registrations.entrySet()) { value.initializeMap() } }"	"Disallows new registrations of new plugins , and creates the internal tables for method lookup ."
"fun toGml(graph: IDirectedGraph<*, out IGraphEdge<*>?>): String? { Preconditions.checkNotNull(graph, ""Graph argument can not be null"") val sb = StringBuilder() sb.append( """""" graph [ """""".trimIndent() ) var currentId = 0 val nodeMap: MutableMap<Any, Int> = HashMap() for (node in graph.getNodes()) {sb.append( """""" node [ id """""" ) sb.append(currentId) sb.append(""\tlabel \"""") sb.append(node) sb.append( """""""" ] """""" ) nodeMap[node] = currentId ++currentId} for (edge in graph.getEdges()) {sb.append("""""" edge[ source """""") sb.append(nodeMap[edge.getSource()])sb.append(""""""target """""" ) sb.append(nodeMap[edge.getTarget()]) sb.append( """""" graphics [ fill ""#000000"" targetArrow ""standard"" ] ] """""" ) } sb.append(""]\n"") return sb.toString() }"	Creates GML code that represents a given directed graph .
"fun cachePage(pos: Long, page: Page?, memory: Int) { if (cache != null) { cache.put(pos, page, memory) } }"	Put the page in the cache .
fun typeToClass(type: Int): Class<*>? { val result: Class<*>? result = when (type) { Types.BIGINT -> Long::class.javaTypes.BINARY -> String::class.java Types.BIT -> Boolean::class.java Types.CHAR -> Char::class.java Types.DATE -> Date::class.java Types.DECIMAL -> Double::class.java Types.DOUBLE -> Double::class.java Types.FLOAT -> Float::class.java Types.INTEGER -> Int::class.java Types.LONGVARBINARY -> String::class.java Types.LONGVARCHAR -> String::class.java Types.NULL -> String::class.java Types.NUMERIC -> Double::class.java Types.OTHER -> String::class.java Types.REAL -> Double::class.java Types.SMALLINT -> Short::class.java Types.TIME -> Time::class.java Types.TIMESTAMP -> Timestamp::class.java Types.TINYINT -> Short::class.java Types.VARBINARY -> String::class.java Types.VARCHAR -> String::class.java else -> null } return result }	Returns the class associated with a SQL type .
"@Throws(MissingObjectException::class, IOException::class, UnsupportedEncodingException::class) private fun noteToString(repo: Repository, note: Note): String? { val loader: ObjectLoader = repo.open(note.getData()) val baos = ByteArrayOutputStream() loader.copyTo(baos) return String(baos.toByteArray(), ""UTF-8"") }"	Utility method that converts a note to a string ( assuming it 's UTF-8 ) .
@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) @Throws(ValidationException::class) fun initTimers() { initAllTimers() }	Reads the configuration settings for the timer intervals to be used and creates the timers accordingly .
"@Throws(IOException::class) fun tbiIndexToUniqueString(`is`: InputStream?): String? { val ret = StringBuilder() val buf = ByteArray(4096) readIOFully(`is`, buf, 4) val header = String(buf, 0, 4) ret.append(""Header correct: "").append(header == ""TBI"") .append(com.sun.tools.javac.util.StringUtils.LS) readIOFully(`is`, buf, 4) val numRefs: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 0) ret.append(""numRefs: "").append(numRefs).append(com.sun.tools.javac.util.StringUtils.LS) readIOFully(`is`, buf, 28) val format: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 0) val colSeq: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 4) val colBeg: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 8) val colEnd: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 12)val meta: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 16) val skip: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 20) val refNameLength: Int = ByteArrayIOUtils.bytesToIntLittleEndian(buf, 24) val formatStr: String formatStr = TbiFormat.values().get(format and 0xffff).name() ret.append(""Format: "").append(formatStr).append("" 0-based: "") .append(format and 0x10000 != 0).append(com.sun.tools.javac.util.StringUtils.LS) ret.append(""Columns: (refName:Start-End) "").append(colSeq).append("":"").append(colBeg).append(""-"").append(colEnd).append(com.sun.tools.javac.util.StringUtils.LS) ret.append(""Meta: "").append(meta.toChar()).append(com.sun.tools.javac.util.StringUtils.LS) ret.append(""Skip: "").append(skip).append(com.sun.tools.javac.util.StringUtils.LS) val names = ByteArray(refNameLength) readIOFully(`is`, names, names.size) ret.append(""Sequence names: "") var first = true var off = 0 for (i in 0 until numRefs) {var newOff = off while (newOff < names.size && names[newOff] != 0) { newOff++ } if (!first) { ret.append("", "") } ret.append(String(names, off, newOff - off)) off = newOff + 1 first = false } ret.append(com.sun.tools.javac.util.StringUtils.LS) ret.append(indicesToUniqueString(`is`, numRefs)) .append(com.sun.tools.javac.util.StringUtils.LS) return ret.toString() }"	Creates a string representation of the TABIX index
fun addFeatureChangeListener(l: FeatureChangeListener?) { featureListeners.add(l) }	Add a feature change listener .
protected fun UserPassword() { super() }	Dear JPA ...
"fun firePropertyChange(propertyName: String?, oldValue: Float, newValue: Float) {}"	Overridden for performance reasons . See the < a href= '' # override '' > Implementation Note < /a > for more information .
"fun testUpdate5() { val factor = 3 val updateQuery = ""UPDATE "" + DatabaseCreator.TEST_TABLE1.toString() + "" SET field2=field2 *"" + factor try { val selectQuery = ""SELECT field2 FROM "" + DatabaseCreator.TEST_TABLE1 var result: ResultSet = statement.executeQuery(selectQuery) val values: HashSet<BigDecimal> = HashSet<BigDecimal>() val num: Int = statement.executeUpdate(updateQuery) assertEquals(""Not all records in the database were updated"", numberOfRecords, num) result = statement.executeQuery(selectQuery) assertTrue(""Not all records were updated"", values.isEmpty()) result.close() } catch (e: SQLException) { fail(""Unexpected exception"" + e.getMessage()) } }"	UpdateFunctionalityTest # testUpdate5 ( ) . Updates values in one columns in the table using condition
fun isCaretBlinkEnabled(): Boolean { return caretBlinks }	"Returns true if the caret is blinking , false otherwise ."
"@Throws(Exception::class) fun testBug73663() { this.rs = this.stmt.executeQuery(""show variables like 'collation_server'"") this.rs.next() val collation: String = this.rs.getString(2) if (collation != null && collation.startsWith(""utf8mb4"") && ""utf8mb4"" == (this.conn as MySQLConnection).getServerVariable( ""character_set_server"" ) ) { val p = Properties() p.setProperty(""characterEncoding"", ""UTF-8"") p.setProperty( ""statementInterceptors"", Bug73663StatementInterceptor::class.java.getName() ) getConnectionWithProps(p) } else { println(""testBug73663 was skipped: This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations."") } }"	"Tests fix for Bug # 73663 ( 19479242 ) , utf8mb4 does not work for connector/j > =5.1.13 This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations ( it 's better to test two configurations : with default utf8mb4_general_ci and one of non-default , say utf8mb4_bin )"
fun removeEdge(edge: InstructionGraphEdge?) { super.removeEdge(edge) }	Removes an instruction edge from the instruction graph .
fun addApps(apps: List<AppInfo?>?) { mApps.addApps(apps) }	Adds new apps to the list .
"fun stop() { val methodName = ""stop"" synchronized(lifecycle) { log.fine(CLASS_NAME, methodName, ""850"") if (running) { running = false receiving = false if (Thread.currentThread() != recThread) { try { recThread.join() } catch (ex: InterruptedException) { } } } } recThread = null log.fine(CLASS_NAME, methodName, ""851"") }"	Stops the Receiver 's thread . This call will block .
fun First() {}	CONSTRUCTOR < init >
"override fun toString(): String? { var temp = """" for (i in 0 until variables.length) { temp += variables.get(i).toString() temp += ""\n"" } return structName.toString() + ""\n"" + temp }"	Override ToString ( ) .
fun addActionListener(l: ActionListener?) { dispatcher.addListener(l) }	Adds a listener to the switch which will cause an event to dispatch on click
@Throws(org.apache.geode.admin.AdminException::class) protected fun createSystemMemberCache(vm: GemFireVM?): SystemMemberCache? { if (managedSystemMemberCache == null) { managedSystemMemberCache = SystemMemberCacheJmxImpl(vm) } return managedSystemMemberCache }	Override createSystemMemberCache by instantiating SystemMemberCacheJmxImpl if it was not created earlier .
"fun run() { amIActive = true val inputFile: String = args.get(0) if (inputFile.lowercase(Locale.getDefault()).contains("".dep"")) { calculateRaster() } else if (inputFile.lowercase(Locale.getDefault()).contains("".shp"")) { calculateVector() } else { showFeedback(""There was a problem reading the input file."") } }"	Used to execute this plugin tool .
"@Throws(Exception::class) fun test_compressed_timestamp_01b() { TestHelper( ""compressed-timestamp-01b"", ""compressed-timestamp-01b.rq"", ""compressed-timestamp.ttl"", ""compressed-timestamp-01.srx"" ).runTest() }"	"Simple SELECT query returning data typed with the given timestamp , where we have several FILTERs that should evaluate to true ."
"@Throws(javax.xml.stream.XMLStreamException::class) private fun writeAttribute( namespace: String, attName: String, attValue: String, xmlWriter: javax.xml.stream.XMLStreamWriter ) { if (namespace == """") { xmlWriter.writeAttribute(attName, attValue) } else { registerPrefix(xmlWriter, namespace) xmlWriter.writeAttribute(namespace, attName, attValue)} }"	Util method to write an attribute without the ns prefix
"private fun addTag(newTag: String) { if (com.sun.tools.javac.util.StringUtils.isBlank(newTag)) { return } synchronized(tagsObservable) { if (tagsObservable.contains(newTag)) { return } tagsObservable.add(newTag) } firePropertyChange(""tag"", null, tagsObservable) }"	Adds the tag .
fun basicGetAstElement(): EObject? { return astElement }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
public void detach ( ) { if ( systemOverlay ) { getWindowManager ( ) . removeView ( this ) ; } else { ( ( ViewGroup ) getActivityContentView ( ) ) . removeView ( this ) ; } }	Detaches it from the container view .
private fun patternCompile() { try { ptnNumber = Pattern.compile(strNumberPattern) ptnShortDate = Pattern.compile(strShortDatePattern) ptnLongDate = Pattern.compile(strLongDatePattern) ptnPercentage = Pattern.compile(strPercentagePattern) ptnCurrency = Pattern.compile(strCurrencyPattern) ptnViCurrency = Pattern.compile(strViCurrencyPattern) } catch (ex: PatternSyntaxException) { System.err.println(ex.getMessage()) System.exit(1) } }	Pattern compile .
"fun basicSetParams( newParams: jdk.nashorn.internal.ir.ExpressionList, msgs: NotificationChain? ): NotificationChain? { var msgs: NotificationChain? = msgs val oldParams: jdk.nashorn.internal.ir.ExpressionList = params params = newParams if (eNotificationRequired()) { val notification = ENotificationImpl( this, Notification.SET, GamlPackage.PARAMETERS__PARAMS, oldParams, newParams ) if (msgs == null) msgs = notification else msgs.add(notification) } return msgs }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
@Throws(IOException::class) fun unpackInt(`is`: DataInput): Int { var ret = 0 var v: Byte do { v = `is`.readByte() ret = ret shl 7 or (v and 0x7F) } while (v and 0x80 == 0) return ret }	Unpack int value from the input stream .
"fun loadWorkflowData(stepId: String, key: String?): Any? { var data: Any? = null val workflowUri: String = getMainWorkflowUri(stepId) try { if (workflowUri != null) { val dataPath: String = java.lang.String.format(_zkStepDataPath, workflowUri) + java.lang.String.format( _zkWorkflowData, key ) if (_dataManager.checkExists(dataPath) != null) { data = _dataManager.getData(dataPath, false) } } } catch (ex: Exception) { val exMsg = ""Exception adding global data to workflow from stepId: "" + stepId + "": "" + ex.message _log.error(exMsg) data = null } return data }"	Gets the step workflow data stored under /workflow/stepdata/ { workflowURI } /data/ { key } where workflowURI is the URI of the main workflow regardless of whether the step belongs in the main workflow or one of its nested workflows .
"fun fillByte(array: ByteArray, x: Byte) { for (i in array.indices) { array[i] = x } }"	Fill an array with the given value .
fun addDictionaryChunk(dictionaryChunk: List<ByteArray?>) { dictionaryChunks.add(dictionaryChunk) if (null == dictionaryByteArrayToSurrogateKeyMap) { createDictionaryByteArrayToSurrogateKeyMap(dictionaryChunk.size) } addDataToDictionaryMap() }	This method will add a new dictionary chunk to existing list of dictionary chunks
"fun OMWarpingImage(bi: java.awt.image.BufferedImage?) { setWarp(bi, LatLonGCT.INSTANCE, DataBounds(-180, -90, 180, 90)) }"	"Takes an image , assumed to be a world image in the LLXY projection ( equal arc ) covering -180 , 180 longitude to -90 , 90 latitude ."
"private void acquirePrecachingWakeLock ( ) { if ( mPrecachingWakeLock == null ) { PowerManager pm = ( PowerManager ) getSystemService ( Context . POWER_SERVICE ) ; mPrecachingWakeLock = pm . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , TAG ) ; } mPrecachingWakeLock . acquire ( ) ; }"	Acquire the precaching WakeLock .
"@Throws(WarpScriptException::class){ fun entropyHybridTest( gts: GeoTimeSerie, buckets_per_period: Int, periods_per_piece: Int, k: Int, alpha: Double ): List<Long>? { doubleCheck(gts) val anomalous_ticks: MutableList<Long> = ArrayList() if (!GTSHelper.isBucketized(gts)) { throw WarpScriptException(""GTS must be bucketized"") } if (k >= periods_per_piece * buckets_per_period / 2) { throw WarpScriptException(""Upper bound of number of outliers must be less than half of the number of observations per piece"") } var subgts: GeoTimeSerie? = null var subsubgts: GeoTimeSerie? = null var seasonal: GeoTimeSerie? = null val pieces: Long = gts.bucketcount / buckets_per_period / periods_per_piece val bpp = periods_per_piece * buckets_per_period val lb: Long = gts.lastbucket val bs: Long = gts.bucketspan for (u in 0 until pieces) { val start = lb - bs * ((pieces - u) * bpp - 1) val stop = lb - bs * (pieces - u - 1) * bpp subgts = GTSHelper.subSerie(gts, start, stop, false, false, subgts) subgts.lastbucket = stop subgts.bucketcount = bpp subgts.bucketspan = bs if (null == seasonal) { seasonal = GeoTimeSerie(bpp) seasonal.doubleValues = DoubleArray(bpp) seasonal.ticks = LongArray(bpp) } else { GTSHelper.reset(seasonal) } seasonal.type = TYPE.DOUBLE for (v in 0 until buckets_per_period) { subsubgts = GTSHelper.subCycleSerie( subgts, stop - v * bs, buckets_per_period, true, subsubgts ) val madsigma: DoubleArray = madsigma(subsubgts, true) val median = madsigma[0] val mad = madsigma[1] var sum = 0.0 for (w in 0 until subsubgts.values) { subsubgts.doubleValues.get(w) = if (0.0 != mad) Math.abs((subsubgts.doubleValues.get(w) - median) / mad) else 1.0
sum += subsubgts.doubleValues.get(w) } var entropy = 0.0 for (w in 0 until subsubgts.values) { subsubgts.doubleValues.get(w) /= sum val tmp: Double = subsubgts.doubleValues.get(w) if (0.0 != tmp) { entropy -= tmp * Math.log(tmp) } } if (0.0 != entropy) { entropy /= Math.log(subsubgts.values) } else { entropy = 1.0 } for (w in 0 until subsubgts.values) { GTSHelper.setValue( seasonal, subsubgts.ticks.get(w), entropy * subsubgts.doubleValues.get(w) ) } } GTSHelper.sort(seasonal) val m: Double = median(seasonal) var idx = 0 for (i in 0 until subgts.values) { idx = Arrays.binarySearch(seasonal.ticks, idx, seasonal.values, subgts.ticks.get(i)) if (idx < 0) { throw WarpScriptException( ""Internal bug method entropyHybridTest: can't find tick "" + subgts.ticks.get( i ).toString() + "" in seasonal.ticks"" ) } else { subgts.doubleValues.get(i) -= seasonal.doubleValues.get(idx) + m } } anomalous_ticks.addAll(ESDTest(subgts, k, true, alpha)) } return anomalous_ticks }"	Applying Seasonal Entropy Hybrid test This test is based on piecewise decomposition where trend components are approximated by median and seasonal components by entropy of the cycle sub-series . An ESD test is passed upon the residuals . It differs from hybridTest by approximating seasonal component instead of using STL . But in many cases this approximation is more useful than estimation of STL .
"fun collectAndFireTriggers( players: HashSet<PlayerID?>?, triggerMatch: Match<TriggerAttachment?>?, aBridge: IDelegateBridge?, beforeOrAfter: String?, stepName: String? ) { val toFirePossible: HashSet<TriggerAttachment> = collectForAllTriggersMatching(players, triggerMatch, aBridge) if (toFirePossible.isEmpty()) { return } val testedConditions: HashMap<ICondition, Boolean> = collectTestsForAllTriggers(toFirePossible, aBridge) val toFireTestedAndSatisfied: List<TriggerAttachment> = Match.getMatches( toFirePossible, AbstractTriggerAttachment.isSatisfiedMatch(testedConditions) ) if (toFireTestedAndSatisfied.isEmpty()) { return } TriggerAttachment.fireTriggers( HashSet(toFireTestedAndSatisfied), testedConditions, aBridge, beforeOrAfter, stepName, true, true, true, true ) }"	"This will collect all triggers for the desired players , based on a match provided , and then it will gather all the conditions necessary , then test all the conditions , and then it will fire all the conditions which are satisfied ."
fun clone(array: LongArray?): LongArray? { return if (array == null) { null } else array.clone() }	< p > Clones an array returning a typecast result and handling < code > null < /code > . < /p > < p > This method returns < code > null < /code > for a < code > null < /code > input array. < /p >
"@Throws(IllegalArgumentException::class) fun ColorPredicate(input: String) { var rest = input.trim { it <= ' ' }.lowercase(Locale.getDefault()) if (rest.startsWith(""leaf"")) { this.isLeaf = true rest = rest.substring(4).trim { it <= ' ' } } else { this.isLeaf = false } var endOfStartToken = 0 while (endOfStartToken < rest.length && Character.isLetter(rest[endOfStartToken])) { endOfStartToken++ } val startToken = rest.substring(0, endOfStartToken) val macro: String = getMacro(startToken) if (macro != null) { rest = macro } if (rest.startsWith(""some"")) { this.isSome = true rest = rest.substring(4).trim { it <= ' ' } } else if (rest.startsWith(""every"")) { this.isSome = false rest = rest.substring(5).trim { it <= ' ' } } else { throw IllegalArgumentException( """""" Color predicate must start with the optional keyword `leaf' followed by a legal macro name or `every' or `some'."""""" ) } this.set = 0 while (rest != """") { if (rest.startsWith(""omitted"")) { this.set = this.set or (1 shl NUMBER_OF_OMITTED_STATE) rest = rest.substring(7).trim { it <= ' ' } } else if (rest.startsWith(""missing"")) { this.set = this.set or (1 shl NUMBER_OF_MISSING_STATE) rest = rest.substring(7).trim { it <= ' ' } } else if (rest.startsWith(""("")) { rest = rest.substring(1).trim { it <= ' ' } val stateSetSpec = arrayOfNulls<IntArray>(NUMBER_OF_PROVERS) for (i in 0 until NUMBER_OF_PROVERS) { var invert = falseif (rest.startsWith(""-"")) { invert = true rest = rest.substring(1).trim { it <= ' ' } } val appears = BooleanArray(PROVER_STATUSES.get(i).length) for (j in appears.indices) { appears[j] = invert } val endChar = if (i == NUMBER_OF_PROVERS - 1) "")"" else "","" while (rest.length > 0 && !rest.startsWith(endChar)) { var endOfToken = 0 while (endOfToken < rest.length && Character.isLetter(rest[endOfToken])) { endOfToken++ } val token = rest.substring(0, endOfToken) rest = rest.substring(endOfToken).trim { it <= ' ' } var statusNumber: Int try { statusNumber = numberOfProverStatus(i, token) } catch (e: IllegalArgumentException) { val errorMsg = """"""Was expecting status of prover ${ PROVER_NAMES.get(i).toString() } but found `$token' followed by: `$rest'"""""" throw IllegalArgumentException(errorMsg) } appears[statusNumber] = !invert } require(rest.length != 0) { ""Color predicate specifier ended before `(...)' expression complete"" } rest = rest.substring(1).trim { it <= ' ' } var count = 0 for (j in appears.indices) { if (appears[j]) { count++ } }if (count == 0) {require(!invert) { ""A `-' must be followed by one or more statuses"" } count = appears.size for (j in 0 until count) { appears[j] = true} } stateSetSpec[i] = IntArray(count) var k = 0 for (j in appears.indices) { if (appears[j]) { stateSetSpec[i]!![k] = j k++ } } } this.set = this.set or bitVectorOfStates(stateSetSpec) } else { throw IllegalArgumentException(""Unexpected token at: `$rest'"") } } }"	Returns a ColorPredicate obtained by parsing its argument . See the beginning of ProofStatus.tla for the grammar of the input .
@Throws(IOException::class) protected fun transferFromFile(idFile: File?) { BufferedReader(FileReader(idFile)).use { br -> var line: String while (br.readLine().also { line = it } != null) { line = line.trim { it <= ' ' } if (line.length > 0) { transfer(line) } } } }	"Transfer all the sequences listed in the supplied file , interpreting entries appropriately ."
"fun toNamespacedString(): String? { return if (_namespaceURI != null) ""{"" + _namespaceURI.toString() + ""}"" + _localName else _localName }"	"Return the string representation of the qualified name using the the ' { ns } foo ' notation . Performs string concatenation , so beware of performance issues ."
"fun configureManagers() { powerManager = NcePowerManager(this) InstanceManager.store(powerManager, PowerManager::class.java) turnoutManager = NceTurnoutManager(getNceTrafficController(), getSystemPrefix()) InstanceManager.setTurnoutManager(turnoutManager) lightManager = NceLightManager(getNceTrafficController(), getSystemPrefix()) InstanceManager.setLightManager(lightManager) sensorManager = NceSensorManager(getNceTrafficController(), getSystemPrefix()) InstanceManager.setSensorManager(sensorManager) throttleManager = NceThrottleManager(this) InstanceManager.setThrottleManager(throttleManager) if (getNceUsbSystem() !== NceTrafficController.USB_SYSTEM_NONE) { if (getNceUsbSystem() !== NceTrafficController.USB_SYSTEM_POWERHOUSE) { } } else { InstanceManager.setProgrammerManager(getProgrammerManager()) } clockManager = NceClockControl(getNceTrafficController(), getSystemPrefix()) InstanceManager.addClockControl(clockManager) consistManager = NceConsistManager(this) InstanceManager.setConsistManager(consistManager) }"	Configure the common managers for NCE connections . This puts the common manager config in one place .
@Throws(IOException::class) fun newLine() { out.append('\n') for (n in 0 until currentIndentLevel) out.append(indent) currentLine++ currentCol = currentIndentLevel * indent.length() }	Emits a < code > '\n ' < /code > plus required indentation characters for the current indentation level .
"protected fun checkForDuplicatSnapshotName(name: String?, vplexVolume: Volume?) { val snapshotSourceVolume: Volume = getVPLEXSnapshotSourceVolume(vplexVolume) super.checkForDuplicatSnapshotName(name, snapshotSourceVolume) }"	Check if a snapshot with the same name exists for the passed volume .
"public boolean isOneAssetPerUOM ( ) { Object oo = get_Value ( COLUMNNAME_IsOneAssetPerUOM ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return ""Y"" . equals ( oo ) ; } return false ; }"	Get One Asset Per UOM .
fun value(): Int { return this.value }	Retrieve value for node computed so far . < p > Primarily here for testing
fun isRemove(): Boolean { val `is`: Boolean `is` = if (m_editFlag === FolderEditFlag.REMOVE) true else false return `is` }	Devuelve < tt > true < /tt > si el campo est ? marcado como eliminado
"fun encodeWebSafe(source: ByteArray, doPadding: Boolean): String? { return encode(source, 0, source.size, WEBSAFE_ALPHABET, doPadding) }"	Encodes a byte array into web safe Base64 notation .
"@Throws(IOException::class, ServletException::class) fun commence( request: HttpServletRequest?, response: HttpServletResponse, arg2: AuthenticationException? ) { log.debug(""Pre-authenticated entry point called. Rejecting access"") response.sendError(HttpServletResponse.SC_UNAUTHORIZED, ""Access Denied"") }"	Always returns a 401 error code to the client .
fun size(): Int { return _size }	Returns the current number of entries in the map .
"private fun createVolumeData(name: String, numVolumes: Int): List<Volume>? { val volumes: List<Volume> = ArrayList<Volume>()val cgUri: URI = createBlockConsistencyGroup(""$name-cg"") for (i in 1..numVolumes) { val volume = Volume() val volumeURI: URI = URIUtil.createId(Volume::class.java) testVolumeURIs.add(volumeURI) volume.setId(volumeURI) volume.setLabel(name + i) volume.setConsistencyGroup(cgUri) _dbClient.createObject(volume) } return volumes }"	Creates the BlockObject Volume data .
private void showFeedback ( String message ) { if ( myHost != null ) { myHost . showFeedback ( message ) ; } else { System . out . println ( message ) ; } }	Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface .
"fun closeStream(stream: Closeable?) { if (stream != null) { try { stream.close() } catch (e: IOException) { Log.e(""IO"", ""Could not close stream"", e) } } }"	Closes the specified stream .
"private fun updateProgress(progressLabel: String, progress: Int) { if (myHost != null && (progress != previousProgress || progressLabel != previousProgressLabel)) { myHost.updateProgress(progressLabel, progress) } previousProgress = progress previousProgressLabel = progressLabel }"	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
"fun configure() { val memo: XpaSystemConnectionMemo = getSystemConnectionMemo() as XpaSystemConnectionMemo val tc: XpaTrafficController = memo.getXpaTrafficController() tc.connectPort(this) memo.setPowerManager(XpaPowerManager(tc)) jmri.InstanceManager.store(memo.getPowerManager(), PowerManager::class.java) memo.setTurnoutManager(XpaTurnoutManager(memo)) jmri.InstanceManager.store(memo.getTurnoutManager(), jmri.TurnoutManager::class.java) memo.setThrottleManager(XpaThrottleManager(memo)) jmri.InstanceManager.store(memo.getThrottleManager(), jmri.ThrottleManager::class.java) tc.startTransmitThread() sinkThread = Thread(tc) sinkThread.start() }"	set up all of the other objects to operate with an XPA+Modem Connected to an XPressNet based command station connected to this port
"fun executeQuery(miniTable: IMiniTable) { log.info("""") var sql = """" if (m_DD_Order_ID == null) return sql = getOrderSQL() log.fine(sql) var row = 0 miniTable.setRowCount(row) try { val pstmt: PreparedStatement = DB.prepareStatement(sql, null) pstmt.setInt(1, m_DD_Order_ID.toString().toInt()) val rs: ResultSet = pstmt.executeQuery() while (rs.next()) { miniTable.setRowCount(row + 1) miniTable.setValueAt(IDColumn(rs.getInt(1)), row, 0) miniTable.setValueAt(rs.getBigDecimal(2), row, 1) miniTable.setValueAt(rs.getString(3), row, 2) miniTable.setValueAt(rs.getString(4), row, 4) miniTable.setValueAt(rs.getString(5), row, 3) miniTable.setValueAt(rs.getString(6), row, 5) row++ } rs.close() pstmt.close() } catch (e: SQLException) { log.log(Level.SEVERE, sql, e) } miniTable.autoSize() }"	Query Info
"fun ParameterDatabase() { super() accessed = Hashtable() gotten = Hashtable() directory = File(File("""").getAbsolutePath()) label = ""Basic Database"" parents = Vector() checked = false.toInt() }"	Creates an empty parameter database .
private fun CTagHelpers() {}	You are not supposed to instantiate this class .
"fun EventSourceImpl() { LOG.entering(CLASS_NAME, ""<init>"") }"	EventSource provides a text-based stream abstraction for Java
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 13:01:25.281 -0500"", hash_original_method = ""8F9A0D25038BAA53AA87BFFA0D47316A"", hash_generated_method = ""D647B858B68B1333AC193E85FEBDEE73"" ) fun registrationComplete() { synchronized(mHandlerMap) { mRegistrationComplete = true mHandlerMap.notifyAll() }  }"	The application must call here after it finishes registering handlers .
operator fun next(): Long { return next(RecurrenceUtil.now()) }	Returns the next recurrence from now .
@Throws(IOException::class) fun writeExternal(out: ObjectOutput?) { super.writeExternal(out) mbr.writeExternal(out) }	Calls the super method and writes the MBR object of this entry to the specified output stream .
protected fun validate_return(param: Array<StorageCapability?>?) {}	validate the array for _return
"fun jQuote(s: String?): String? { if (s == null) { return ""null"" } val ln = s.length val b = StringBuilder(ln + 4) b.append('""') for (i in 0 until ln) { val c = s[i] if (c == '""') { b.append(""\\\"""") } else if (c == '\\') { b.append(""\\\\"") } else if (c.code < 0x20) { if (c == '\n') { b.append(""\\n"") } else if (c == '\r') { b.append(""\\r"") } else if (c == '\f') { b.append(""\\f"") } else if (c == '\b') { b.append(""\\b"") } else if (c == '\t') { b.append(""\\t"") } else { b.append(""\\u00"") var x = c.code / 0x10 b.append(toHexDigit(x)) x = c.code and 0xF b.append(toHexDigit(x)) } } else { b.append(c) } } b.append('""') return b.toString() }"	Quotes string as Java Language string literal . Returns string < code > '' null '' < /code > if < code > s < /code > is < code > null < /code > .
"fun partiallyApply(param1: T1?, param2: T2?): FluentFunction<T3?, R?>? { return FluentFunction(PartialApplicator.partial3(param1, param2, fn)) }"	Partially apply the provided parameters to this BiFunction to generate a Function ( single input )
fun deleteFile(path: String?): Boolean { if (Handler_String.isBlank(path)) { return true } val file = File(path) if (!file.exists()) { return true } if (file.isFile()) { return file.delete() } if (!file.isDirectory()) { return false } for (f in file.listFiles()) { if (f.isFile()) { f.delete() } else if (f.isDirectory()) { deleteFile(f.getAbsolutePath()) } } return file.delete() }	"delete file or directory < ul > < li > if path is null or empty , return true < /li > < li > if path not exist , return true < /li > < li > if path exist , delete recursion . return true < /li > < ul >"
"private fun createCompactionClients(jmxConfig: CassandraJmxCompactionConfig): ImmutableSet<CassandraJmxCompactionClient?>? { val clients: MutableSet<CassandraJmxCompactionClient> = Sets.newHashSet() val servers: Set<InetSocketAddress> = config.servers() val jmxPort: Int = jmxConfig.port() for (addr in servers) { val client: CassandraJmxCompactionClient = createCompactionClient( addr.getHostString(), jmxPort, jmxConfig.username(), jmxConfig.password() ) clients.add(client) } return ImmutableSet.copyOf(clients) }"	Return an empty set if no client can be created .
"fun hashKeyForDisk(key: String): String? { var cacheKey: String? try { val mDigest: MessageDigest = MessageDigest.getInstance(""MD5"") mDigest.update(key.toByteArray()) cacheKey = bytesToHexString(mDigest.digest()) } catch (e: NoSuchAlgorithmException) { cacheKey = key.hashCode().toString() } return cacheKey }"	A hashing method that changes a string ( like a URL ) into a hash suitable for using as a disk filename .
@Nullable fun space(): String? { return space }	Gets swap space name .
"@Throws(Exception::class) fun runSafely(stack: Catbert.FastStack?): Any? { val si: SeriesInfo = getSeriesInfo(stack) return if (si == null) """" else si.getDescription() }"	Returns the description for the specified SeriesInfo
"@Throws(AppsForYourDomainException::class, ServiceException::class, IOException::class) fun restoreUser(username: String): UserEntry? { LOGGER.log(Level.INFO, ""Restoring user '$username'."") val retrieveUrl = URL(domainUrlBase.toString() + ""user/"" + SERVICE_VERSION + ""/"" + username) val userEntry: UserEntry = userService.getEntry(retrieveUrl, UserEntry::class.java) userEntry.getLogin().setSuspended(false) val updateUrl = URL(domainUrlBase.toString() + ""user/"" + SERVICE_VERSION + ""/"" + username) return userService.update(updateUrl, userEntry) }"	Restores a user . Note that executing this method for a user who is not suspended has no effect .
fun weightedFMeasure(): Double { val classCounts = DoubleArray(m_NumClasses) var classCountSum = 0.0 for (i in 0 until m_NumClasses) { for (j in 0 until m_NumClasses) { classCounts[i] += m_ConfusionMatrix.get(i).get(j) } classCountSum += classCounts[i] } var fMeasureTotal = 0.0 for (i in 0 until m_NumClasses) { val temp: Double = fMeasure(i) fMeasureTotal += temp * classCounts[i] } return fMeasureTotal / classCountSum }	"Prevents this class from being instantiated , except by the create method in this class ."
"@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:55:08.711 -0500"", hash_original_method = ""05A7D65C6D911E0B1F3261A66888CB52"", hash_generated_method = ""3AFFFBA2DDE5D54646A6F203B3BBAF40"" ) fun lastIndexOf(obj: Any?): Int { return this.hlist.lastIndexOf(obj) }"	Calculates the macro weighted ( by class size ) average F-Measure .
"@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:55:08.711 -0500"", hash_original_method = ""05A7D65C6D911E0B1F3261A66888CB52"", hash_generated_method = ""3AFFFBA2DDE5D54646A6F203B3BBAF40"" ) fun lastIndexOf(obj: Any?): Int { return this.hlist.lastIndexOf(obj) }"	Get the last index of the given object .
fun showNextButton(showNextButton: Boolean): Builder? { showNextButton = showNextButton return this }	Set the visibility of the next button
"fun createSmallLob(type: Int, small: ByteArray?, precision: Long): ValueLobDb? { return ValueLobDb(type, small, precision) }"	Create a LOB object that fits in memory .
"fun invDct8x8(input: Array<DoubleArray>, output: Array<IntArray>) { val temp = Array(NJPEG) { DoubleArray( NJPEG ) } var temp1 = 0.0 var i = 0 var j = 0 var k = 0 i = 0 while (i < NJPEG) { j = 0 while (j < NJPEG) { temp[i][j] = 0.0 k = 0 while (k < NJPEG) { temp[i][j] += input[i][k] * this.C.get(k).get(j) k++ } j++ } i++ } i = 0 while (i < NJPEG) { j = 0 while (j < NJPEG) { temp1 = 0.0 k = 0 while (k < NJPEG) { temp1 += this.Ct.get(i).get(k) * temp[k][j] k++ } temp1 += 128.0 output[i][j] = com.sun.imageio.plugins.common.ImageUtil.pixelRange(round(temp1)) j++ } i++ } }"	Perform inverse DCT on the 8x8 matrix
"fun openDataFile(): InputStream? { val stream: InputStream = SantaFeExample::class.java.getResourceAsStream(""santafe.trail"") if (stream == null) { System.err.println(""Unable to find the file santafe.trail."") System.exit(-1) } return stream }"	Returns an input stream that contains the ant trail data file .
"fun ProductionRule( name: String?, data: GameData?, results: IntegerMap<NamedAttachable?>, costs: IntegerMap<jdk.internal.loader.Resource?> ) { super(name, data) m_results = results m_cost = costs }"	Creates new ProductionRule
"fun RootConfiguration(ai: ApplicationInformation?) { this(ai, getDefaultContexts(applicationClass(ai, CommonUtils.getCallingClass(2)))) }"	Initializes the root configuration with default context relative to the calling ( instantiating class ) .
"fun addString(word: String?, t: Tuple?) { val leaf = TrieLeaf(word, t) addLeaf(root, leaf, 0) }"	"Add a new word to the trie , associated with the given Tuple ."
@Throws(InterruptedException::class) fun waitOnInitialization() { this.initializationLatch.await() }	Wait for the tracker to finishe being initialized
@Throws(ExecutionException::class) fun execute(event: ExecutionEvent): Any? { val viewPart: IWorkbenchPart = HandlerUtil.getActivePart(event) if (viewPart is DroidsafeInfoOutlineViewPart) { val command: Command = event.getCommand() val oldValue: Boolean = HandlerUtil.toggleCommandState(command) (viewPart as DroidsafeInfoOutlineViewPart).setLongLabel(!oldValue) } return null }	"Command implementation . Retrieves the value of the parameter value , and delegates to the view to set the correct value for the methods labels ."
protected fun eStaticClass(): EClass? { return UmplePackage.eINSTANCE.getCodeLang_() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"@Throws(IOException::class) private fun streamToBytes(`in`: InputStream, length: Int): ByteArray? { val bytes = ByteArray(length) var count: Int var pos = 0 while (pos < length && `in`.read(bytes, pos, length - pos).also { count = it } != -1) { pos += count } if (pos != length) { throw IOException(""Expected $length bytes, read $pos bytes"") } return bytes }"	Reads the contents of an InputStream into a byte [ ] .
"@Throws(Exception::class) fun testUpdatePathDoesNotExist() { val props: Map<String, String> = properties(""owner"", ""group"", ""0555"") assert(igfs.update(SUBDIR, props) == null) checkNotExist(igfs, igfsSecondary, SUBDIR) }"	Check that exception is thrown in case the path being updated does n't exist remotely .
"@Throws(InterruptedException::class) fun stopProcess() { latch.await() if (this.process != null) { println(""ProcessThread.stopProcess() will kill process"") this.process.destroy() } }"	Stops the process .
"fun run() { amIActive = true var inputHeader: String? = null var outputHeader: String? = null var row: Int var col: Int var x: Int var y: Int var progress = 0 var z: Double var i: Int  var c: Int val dX = intArrayOf(1, 1, 1, 0, -1, -1, -1, 0) val dY = intArrayOf(-1, 0, 1, 1, 1, 0, -1, -1) var zFactor = 0.0 var slopeThreshold = 0.0 var profCurvThreshold = 0.0 var planCurvThreshold = 0.0 val radToDeg = 180 / Math.PI if (args.length <= 0) { showFeedback(""Plugin parameters have not been set."") return } i = 0 while (i < args.length) { if (i == 0) { inputHeader = args.get(i) } else if (i == 1) { outputHeader = args.get(i) } else if (i == 2) { zFactor = args.get(i).toDouble() } else if (i == 3) { slopeThreshold =args.get(i).toDouble() } else if (i == 4) { profCurvThreshold = args.get(i).toDouble() } else if (i == 5) { planCurvThreshold = args.get(i).toDouble() ] } i++ } if (inputHeader == null || outputHeader == null) { showFeedback(""One or more of the input parameters have not been set properly."") return } try { val DEM = WhiteboxRaster(inputHeader, ""r"")val rows: Int = DEM.getNumberRows() val cols: Int = DEM.getNumberColumns() val noData: Double = DEM.getNoDataValue() val gridResX: Double = DEM.getCellSizeX() val gridResY: Double = DEM.getCellSizeY() val diagGridRes = Math.sqrt(gridResX * gridResX + gridResY * gridResY) val gridLengths = doubleArrayOf( diagGridRes, gridResX, diagGridRes, gridResY, diagGridRes, gridResX, diagGridRes, gridResY ) var Zx: Double var Zy: Double var Zxx: Double var Zyy: Double var Zxy: Double var p: Double var Zx2: Double var q: Double var Zy2: Double var fx: Double var fy: Double val gridResTimes2 = gridResX * 2 val gridResSquared = gridResX * gridResX val fourTimesGridResSquared = gridResSquared * 4 var planCurv: Double var profCurv: Double var slope: Double val eightGridRes = 8 * gridResX val N = DoubleArray(8) val output = WhiteboxRaster(outputHeader, ""rw"", inputHeader, WhiteboxRaster.DataType.FLOAT, -999) output.setPreferredPalette(""landclass.pal"") output.setDataScale(WhiteboxRaster.DataScale.CONTINUOUS) row = 0 while (row < rows) { col = 0 while (col < cols) { z = DEM.getValue(row, col) if (z != noData) { z = z * zFactor c = 0 while (c < 8) { N[c] = DEM.getValue(row + dY[c], col + dX[c]) if (N[c] != noData) { N[c] = N[c] * zFactor } else { N[c] = z } c++ } Zx = (N[1] - N[5]) / gridResTimes2 Zy = (N[7] - N[3]) / gridResTimes2 Zxx = (N[1] - 2 * z + N[5]) / gridResSquared Zyy = (N[7] - 2 * z + N[3]) / gridResSquared Zxy = (-N[6] + N[0] + N[4] - N[2]) / fourTimesGridResSquared Zx2 = Zx * Zx Zy2 = Zy * Zy p = Zx2 + Zy2 q = p + 1 if (p > 0) { fy = (N[6] - N[4] + 2 * (N[7] - N[3]) + N[0] - N[2]) / eightGridRes fx = (N[2] - N[4] + 2 * (N[1] - N[5]) + N[0] - N[6]) / eightGridRes slope = Math.atan(Math.sqrt(fx * fx + fy * fy)) slope = slope * radToDeg planCurv = -1 * (Zxx * Zy2 - 2 * Zxy * Zx * Zy + Zyy * Zx2) / Math.pow(p, 1.5) planCurv = planCurv * radToDeg profCurv = -1 * (Zxx * Zx2 + 2 * Zxy * Zx * Zy + Zyy * Zy2) / Math.pow( p * q, 1.5 ) profCurv = profCurv * radToDeg if (profCurv < -profCurvThreshold && planCurv <= -planCurvThreshold and slope > slopeThreshold) { output.setValue(row, col, 1) } else if (profCurv < -profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) { output.setValue(row, col, 2) } else if (profCurv > profCurvThreshold && planCurv <= planCurvThreshold && slope > slopeThreshold) { output.setValue(row, col, 3) } else if (profCurv > profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) { output.setValue(row, col, 4) } else if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv <= -planCurvThreshold) { output.setValue(row, col, 5) } else if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv > planCurvThreshold) { output.setValue(row, col, 6) } else if (slope <= slopeThreshold) { output.setValue(row, col, 7) } else { output.setValue(row, col, noData) } } else { output.setValue(row, col, noData) } } col++ } if (cancelOp) { cancelOperation() return } progress = (100f * row / (rows - 1)).toInt() updateProgress(progress) row++ } output.addMetadataEntry(""Created by the "" + getDescriptiveName().toString() + "" tool."") output.addMetadataEntry(""Created on "" + Date()) DEM.close() output.close() returnData(outputHeader) var retstr = ""LANDFORM CLASSIFICATION KEY\n"" retstr += ""\nValue:\tClass"" retstr += ""\n1\tConvergent Footslope"" retstr += ""\n2\tDivergent Footslope"" retstr += ""\n3\tConvergent Shoulder"" retstr += ""\n4\tDivergent Shoulder"" retstr += ""\n5\tConvergent Backslope"" retstr += ""\n6\tDivergent Backslope"" retstr += ""\n7\tLevel"" returnData(retstr) } catch (oe: OutOfMemoryError) { myHost.showFeedback(""An out-of-memory error has occurred during operation."") } catch (e: Exception) { myHost.showFeedback(""An error has occurred during operation. See log file for details."") myHost.logException(""Error in "" + getDescriptiveName(), e) } finally { updateProgress(""Progress: "", 0) amIActive = false myHost.pluginComplete() } }"	Used to execute this plugin tool .
"fun reduce(r1: R?, r2: R?): R? { return r1 }"	Reduces two results into a combined result . The default implementation is to return the first parameter . The general contract of the method is that it may take any action whatsoever .
@Throws(IOException::class) fun numParameters(num: Int) { output.write(num) }	Writes < code > num_parameters < /code > in < code > Runtime ( In ) VisibleParameterAnnotations_attribute < /code > . This method must be followed by < code > num < /code > calls to < code > numAnnotations ( ) < /code > .
fun ResultFormatter(result: Any) { result = result printHeader = true }	Creates a new formatter for a particular object .
fun join(): Eval<String?>? { return Eval.later(null) }	Perform an asynchronous join operation
"fun type(@Nullable type: String?): GetRequest? { var type = type if (type == null) { type = ""_all"" } this.type = type return this }"	Sets the type of the document to fetch .
"fun entries(): ImmutableSet<Map.Entry<K, V>>? { val result: ImmutableSet<Map.Entry<K, V>>? = entries return if (result == null) EntrySet<K, V>(this).also { entries = it } else result }"	"Returns an immutable collection of all key-value pairs in the multimap . Its iterator traverses the values for the first key , the values for the second key , and so on ."
"private fun luminance(r: Int, g: Int, b: Int): Int { return (0.299 * r + 0.58 * g + 0.11 * b).toInt() }"	Apply the luminance
private fun puntPlay(offense: Team) { gameYardLine = (100 - (gameYardLine + offense.getK(0).ratKickPow / 3 + 20 - 10 * Math.random())) as Int if (gameYardLine < 0) { gameYardLine = 20 } gameDown = 1 gameYardsNeed = 10 gamePoss = !gamePoss gameTime -= 20 + 15 * Math.random() }	Punt the ball if it is a 4th down and decided not to go for it . Will turnover possession .
"@Throws(IOException::class) private fun readSentence(aReader: BufferedReader): List<Array<String>>? { val words: MutableList<Array<String>> = ArrayList() var line: String? var beginSentence = true while (aReader.readLine().also { line = it } != null) { if (com.sun.tools.javac.util.StringUtils.isBlank(line)) { beginSentence = true break } if (hasHeader && beginSentence) { beginSentence = false continue } val fields: Array<String> = line.split(columnSeparator.getValue()).toTypedArray() if (!hasEmbeddedNamedEntity && fields.size != 2 + javax.swing.text.html.HTML.Tag.FORM) { throw IOException( java.lang.String.format( ""Invalid file format. Line needs to have %d %s-separated fields: [%s]"", 2 + javax.swing.text.html.HTML.Tag.FORM, columnSeparator.getName(), line ) ) } else if (hasEmbeddedNamedEntity && fields.size != 3 + javax.swing.text.html.HTML.Tag.FORM) { throw IOException( java.lang.String.format( ""Invalid file format. Line needs to have %d %s-separated fields: [%s]"", 3 + javax.swing.text.html.HTML.Tag.FORM, columnSeparator.getName(), line ) ) } words.add(fields) } return if (line == null && words.isEmpty()) { null } else { words } }"	Read a single sentence .
fun OVERFLOW_FROM_SUB(): ConditionOperand? { return ConditionOperand(OVERFLOW_FROM_SUB )}	Create the condition code operand for OVERFLOW_FROM_SUB
"protected fun initCheckLists()  { val streams: List<IceMediaStream> = getStreamsWithPendingConnectivityEstablishment() val streamCount = streams.size val maxCheckListSize = Integer.getInteger(StackProperties.MAX_CHECK_LIST_SIZE, DEFAULT_MAX_CHECK_LIST_SIZE) val maxPerStreamSize = if (streamCount == 0) 0 else maxCheckListSize / streamCount for (stream in streams) { logger.info(""Init checklist for stream "" + stream.getName()) stream.setMaxCheckListSize(maxPerStreamSize) stream.initCheckList() } if (streamCount > 0) streams[0].getCheckList().computeInitialCheckListPairStates() }"	"Creates , initializes and orders the list of candidate pairs that would be used for the connectivity checks for all components in this stream ."
private fun checkSearchables(searchablesList: ArrayList<SearchableInfo>) { assertNotNull(searchablesList) val count: Int = searchablesList.size() for (ii in 0 until count) { val si = searchablesList[ii] checkSearchable(si) } }	"Generic health checker for an array of searchables . This is designed to pass for any semi-legal searchable , without knowing much about the format of the underlying data . It 's fairly easy for a non-compliant application to provide meta-data that will pass here ( e.g . a non-existent suggestions authority ) ."
"private fun generateImplementsParcelableInterface(targetPsiClass: PsiClass) { val referenceElement: PsiJavaCodeReferenceElement = factory.createReferenceFromText(PARCELABLE_CLASS_SIMPLE_NAME, null) val implementsList: PsiReferenceList = targetPsiClass.getImplementsList() if (null != implementsList) { implementsList.add(referenceElement) } generateImportStatement(PARCELABLE_PACKAGE) generateExtraMethods(targetPsiClass) }"	Implement android.os.Parcelable interface
"private fun fetchRDFGroupFromCache( rdfGroupCache: MutableMap<URI, RemoteDirectorGroup>, srdfGroupURI: URI ): RemoteDirectorGroup? { if (rdfGroupCache.containsKey(srdfGroupURI)) { return rdfGroupCache[srdfGroupURI] } val rdfGroup: RemoteDirectorGroup = this.getDbClient().queryObject(RemoteDirectorGroup::class.java, srdfGroupURI) if (null != rdfGroup && !rdfGroup.getInactive()) { rdfGroupCache[srdfGroupURI] = rdfGroup } return rdfGroup }"	Return the RemoteDirectorGroup from cache otherwise query from db .
"fun minCut(s: String?): Int { val palin: Set<String> = HashSet() return minCut(s, 0, palin) }"	"Backtracking , generate all cuts"
"fun withDateFormat(df: DateFormat?): ObjectWriter? { val newConfig: SerializationConfig = _config.withDateFormat(df) return if (newConfig === _config) { this } else ObjectWriter(this, newConfig) }"	"Fluent factory method that will construct a new writer instance that will use specified date format for serializing dates ; or if null passed , one that will serialize dates as numeric timestamps ."
"fun LockMode(allowsTouch: Boolean, allowsCommands: Boolean) { allowsTouch = allowsTouch allowsCommands = allowsCommands }"	Constructs a new LockMode instance .
"fun match(e: Element, pseudoE: String?): Boolean { return if (e is CSSStylableElement) (e as CSSStylableElement).isPseudoInstanceOf(getValue()) else false }"	Tests whether this selector matches the given element .
"@Throws(IOException::class) fun openInputFileAsZip(fileName: String): RandomAccessFile? { val zipFile: ZipFile try { zipFile = ZipFile(fileName) } catch (fnfe: FileNotFoundException) { System.err.println(""Unable to open '"" + fileName + ""': "" + fnfe.getMessage()) throw fnfe } catch (ze: ZipException) { return null } val entry: ZipEntry = zipFile.getEntry(CLASSES_DEX) if (entry == null) { System.err.println(""Unable to find '"" + CLASSES_DEX.toString() + ""' in '"" + fileName + ""'"") zipFile.close() throw ZipException() } val zis: InputStream = zipFile.getInputStream(entry) val tempFile: File = File.createTempFile(""dexdeps"", "".dex"") val raf = RandomAccessFile(tempFile, ""rw"") tempFile.delete() val copyBuf = ByteArray(32768) var actual: Int while (true) { actual = zis.read(copyBuf) if (actual == -1) break raf.write(copyBuf, 0, actual) } zis.close() raf.seek(0) return raf }"	Tries to open an input file as a Zip archive ( jar/apk ) with a `` classes.dex '' inside .
"fun generate(proj: Projection?): Boolean { setNeedToRegenerate(true) if (proj == null) { Debug.message(""omgraphic"", ""OMRect: null projection in generate!"") return false } when (renderType) { RENDERTYPE_XY -> setShape( createBoxShape( Math.min(x2, x1) as Int, Math.min(y2, y1) as Int, Math.abs(x2 - x1) as Int, Math.abs(y2 - y1) as Int ) ) RENDERTYPE_OFFSET -> { if (!proj.isPlotable(lat1, lon1)) { setNeedToRegenerate(true) return false } val p1: Point = proj.forward(lat1, lon1, Point()) as Point setShape( createBoxShape( Math.min(p1.x + x1, p1.x + x2) as Int, Math.min(p1.y + y1, p1.y + y2) as Int, Math.abs(x2 - x1) as Int, Math.abs(y2 - y1) as Int ) ) } RENDERTYPE_LATLON -> { val rects: ArrayList<FloatArray> rects = if (proj is GeoProj) { (proj as GeoProj).forwardRect( Double(lat1, lon1), Double(lat2, lon2), lineType, nsegs, !isClear(fillPaint) ) } else { proj.forwardRect( java.awt.geom.Point2D.Double(lon1, lat1), java.awt.geom.Point2D.Double(lon2, lat2) ) } val size: Int = rects.size() var projectedShape: java.awt.geom.GeneralPath? = null var i = 0 while (i < size) { val gp: java.awt.geom.GeneralPath = createShape(rects[i], rects[i + 1], true) projectedShape appendShapeEdge(projectedShape, gp, false) i += 2 } setShape(projectedShape) } RENDERTYPE_UNKNOWN -> { System.err.println(""OMRect.generate(): invalid RenderType"") return false } } setLabelLocation(getShape(), proj) setNeedToRegenerate(false) return true }"	Prepare the rectangle for rendering .
"@Throws(IOException::class) fun stream(os: OutputStream?) { val globals: sun.net.www.MessageHeader = entries.elementAt(0) if (globals.findValue(""Signature-Version"") == null) { throw JarException(""Signature file requires "" + ""Signature-Version: 1.0 in 1st header"") } val ps = PrintStream(os) globals.print(ps) for (i in 1 until entries.size()) { val mh: sun.net.www.MessageHeader = entries.elementAt(i) mh.print(ps) } }"	Add a signature file at current position in a stream
fun readDateTimeAsLong(index: Int): Long { return this.readULong(index) shl 32 or this.readULong(index + 4) }	Reads the LONGDATETIME at the given index .
"fun BagToSet(b: Value): Value? { val fcn: FcnRcdValue = FcnRcdValue.convert(b) ?: throw EvalException( EC.TLC_MODULE_APPLYING_TO_WRONG_VALUE, arrayOf(""BagToSet"", ""a function with a finite domain"", Value.ppr(b.toString())) ) return fcn.getDomain() }"	"// For now , we do not override SubBag . So , We are using the TLA+ definition . public static Value SubBag ( Value b ) { FcnRcdValue fcn = FcnRcdValue.convert ( b ) ; if ( fcn == null ) { String msg = `` Applying SubBag to the following value , which is\n '' + `` not a function with a finite domain : \n '' + Value.ppr ( b.toString ( ) ) ; throw new EvalException ( msg ) ; } throw new EvalException ( `` SubBag is not implemented . `` ) ; }"
"fun createProjectClosingEvent(project: ProjectDescriptor?): ProjectActionEvent? { return ProjectActionEvent(project, ProjectAction.CLOSING, false) }"	Creates a Project Closing Event .
"fun fullyConnectSync(srcContext: Context?, srcHandler: Handler?, dstHandler: Handler?): Int { var status: Int = connectSync(srcContext, srcHandler, dstHandler) if (status == STATUS_SUCCESSFUL) { val response: Message = sendMessageSynchronously(CMD_CHANNEL_FULL_CONNECTION) status = response.arg1 } return status }"	Fully connect two local Handlers synchronously .
"fun hasInterface(intf: String?, cls: String?): Boolean { return try { hasInterface(Class.forName(intf), Class.forName(cls)) } catch (e: Exception) { false } }"	Checks whether the given class implements the given interface .
"fun removePropertyChangeListener(propertyName: String?, in_pcl: PropertyChangeListener?) { beanContextChildSupport.removePropertyChangeListener(propertyName, in_pcl) }"	Method for BeanContextChild interface . Uses the BeanContextChildSupport to remove a listener to this object 's property . You do n't need this function for objects that extend java.awt.Component .
private fun isIgnoreLocallyExistingFiles(): Boolean { return ignoreLocallyExistingFiles }	Returns true to indicate that locally existing files are treated as they would not exist . This is a extension to the standard cvs-behaviour !
"private fun isViewDescendantOf(child: View, parent: View): Boolean { if (child === parent) { return true } val theParent = child.parent return theParent is ViewGroup && isViewDescendantOf(theParent as View, parent) }"	"Return true if child is an descendant of parent , ( or equal to the parent ) ."
"fun add(value: Double) { if (count === 0) { count = 1 mean = value min = value max = value if (!isFinite(value)) { sumOfSquaresOfDeltas = NaN } } else { count++ if (isFinite(value) && isFinite(mean)) { val delta: Double = value - mean mean += delta / count sumOfSquaresOfDeltas += delta * (value - mean) } else { mean = calculateNewMeanNonFinite(mean, value) sumOfSquaresOfDeltas = NaN } min = Math.min(min, value) max = Math.max(max, value) } }"	Adds the given value to the dataset .
"private fun init(context: Context, theme: RuqusTheme, currClassName: String) { currClassName = currClassName inflate(context, R.layout.sort_field_view, this) setOrientation(VERTICAL) label = findViewById(R.id.sort_field_label) as TextView? sortFieldChooser = findViewById(R.id.sort_field) as Spinner removeButton = findViewById(R.id.remove_field) as ImageButton sortDirRg = findViewById(R.id.rg_sort_dir) as RadioGroup ascRb = findViewById(R.id.asc) as RadioButton descRb = findViewById(R.id.desc) as RadioButton setTheme(theme) sortFieldChooser.setOnTouchListener(sortFieldChooserListener) sortFieldChooser.setOnItemSelectedListener(sortFieldChooserListener) }"	Initialize our view .
"protected fun closeNoThrow(): Future<Void?>? { var closeFuture: Promise<Void?>? synchronized(this) { if (null != closePromise) { return closePromise } closePromise = Promise<Void>() closeFuture = closePromise } cancelTruncation() Utils.closeSequence( bkDistributedLogManager.getScheduler(), true, getCachedLogWriter(), getAllocatedLogWriter(), getCachedWriteHandler() ).proxyTo(closeFuture) return closeFuture }"	Close the writer and release all the underlying resources
fun isValidating(): Boolean? { return validating }	Gets the value of the validating property .
"private fun scanPlainSpaces(): String? { var length = 0 while (reader.peek(length) === ' ' || reader.peek(length) === '\t') { length++ } val whitespaces: String = reader.prefixForward(length) val lineBreak: String = scanLineBreak() if (lineBreak.length != 0) { this.allowSimpleKey = true var prefix: String = reader.prefix(3) if (""---"" == prefix || ""..."" == prefix && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) { return """" } val breaks = StringBuilder() while (true) { if (reader.peek() === ' ') { reader.forward() } else { val lb: String = scanLineBreak() if (lb.length != 0) { breaks.append(lb) prefix = reader.prefix(3) if (""---"" == prefix || ""..."" == prefix && Constant.NULL_BL_T_LINEBR.has( reader.peek(3) ) ) { return """" } } else { break } } } if (""\n"" != lineBreak) { return lineBreak + breaks } else if (breaks.length == 0) { return "" "" } return breaks.toString() } return whitespaces }"	See the specification for details . SnakeYAML and libyaml allow tabs inside plain scalar
"fun w(tag: String?, s: String?, e: Throwable?) { if (LOG.WARN >= LOGLEVEL) Log.w(tag, s, e) }"	Warning log message .
fun mean(vector: DoubleArray): Double { var sum = 0.0 if (vector.size == 0) { return 0 } for (i in vector.indices) { sum += vector[i] } return sum / vector.size.toDouble() }	Computes the mean for an array of doubles .
@Throws(Exception::class) protected fun toJsonBytes(`object`: Any?): ByteArray? { val mapper = ObjectMapper() mapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL) return mapper.writeValueAsBytes(`object`) }	Map object to JSON bytes
"fun shuffleInventory(@Nonnull inv: IInventory, @Nonnull random: Random?) { val list: List<ItemStack?> = getInventoryList(inv) Collections.shuffle(list, random) for (i in 0 until inv.getSizeInventory()) { inv.setInventorySlotContents(i, list[i]) } }"	Shuffles all items in the inventory
"fun QueueCursor(capacity: Int) { this(capacity, false.toInt()) }"	Creates an < tt > QueueCursor < /tt > with the given ( fixed ) capacity and default access policy .
fun destroy(r: DistributedRegion?) {}	Blows away all the data in this object .
"@Throws(IOException::class) fun executeAsync(command: CommandLine?, handler: ExecuteResultHandler?): Process? { return executeAsync(command, null, handler) }"	Methods for starting asynchronous execution . The child process inherits all environment variables of the parent process . Result provided to callback handler .
"fun destroy() { try { val region1: Region = cache.getRegion(Region.SEPARATOR + REGION_NAME) region1.localDestroy(""key-1"") } catch (e: Exception) { e.printStackTrace() fail(""test failed due to exception in destroy "") } }"	destroy key-1
fun isSelected(): Boolean { return this.selected }	Check if item is selected
fun String(string: String) { value = string.value offset = string.offset count = string.count }	Creates a string that is a copy of another string
"private fun needNewBuffer(newSize: Int) { val delta: Int = newSize - size val newBufferSize = Math.max(minChunkLen, delta) currentBufferIndex++ currentBuffer = IntArray(newBufferSize) offset = 0 if (currentBufferIndex >= buffers.length) { val newLen: Int = buffers.length shl 1 val newBuffers = arrayOfNulls<IntArray>(newLen) System.arraycopy(buffers, 0, newBuffers, 0, buffers.length) buffers = newBuffers } buffers.get(currentBufferIndex) = currentBuffer buffersCount++ }"	Prepares next chunk to match new size . The minimal length of new chunk is < code > minChunkLen < /code > .
"fun patch_splitMax(patches: LinkedList<javax.sound.midi.Patch?>) { val patch_size: Short = Match_MaxBits var precontext: String var postcontext: String var patch: javax.sound.midi.Patch var start1: Int var start2: Int var empty: Boolean var diff_type: Operation var diff_text: String val pointer: MutableListIterator<javax.sound.midi.Patch?> = patches.listIterator() var bigpatch: javax.sound.midi.Patch? = if (pointer.hasNext()) pointer.next() else null while (bigpatch != null) { if (bigpatch.length1 <= Match_MaxBits) { bigpatch = if (pointer.hasNext()) pointer.next() else null continue } pointer.remove() start1 = bigpatch.start1 start2 = bigpatch.start2 precontext = """" while (!bigpatch.diffs.isEmpty()) { patch = javax.sound.midi.Patch() empty = true patch.start1 = start1 - precontext.length patch.start2 = start2 - precontext.length if (precontext.length != 0) { patch.length2 = precontext.length patch.length1 = patch.length2 patch.diffs.add( jdk.internal.org.jline.utils.DiffHelper.Diff( Operation.EQUAL, precontext ) ) } while (!bigpatch.diffs.isEmpty() && patch.length1 < patch_size - Patch_Margin) { diff_type = bigpatch.diffs.getFirst().operation diff_text = bigpatch.diffs.getFirst().text if (diff_type === Operation.INSERT) { patch.length2 += diff_text.length start2 += diff_text.length patch.diffs.addLast(bigpatch.diffs.removeFirst()) empty = false } else if (diff_type === Operation.DELETE && patch.diffs.size() === 1 && patch.diffs.getFirst().operation === Operation.EQUAL && diff_text.length > 2 * patch_size) { patch.length1 += diff_text.length start1 += diff_text.length empty = false patch.diffs.add,  dk.internal.org.jline.utils.DiffHelper.Diff( diff_type, diff_text ) ) bigpatch.diffs.removeFirst() } else { diff_text = diff_text.substring( 0, Math.min(diff_text.length, patch_size - patch.length1 - Patch_Margin) ) patch.length1 += diff_text.length start1 += diff_text.length if (diff_type === Operation.EQUAL) { patch.length2 += diff_text.length start2 += diff_text.length } else { empty = false } patch.diffs.add( jdk.internal.org.jline.utils.DiffHelper.Diff( diff_type, diff_text ) ) if (diff_text == bigpatch.diffs.getFirst().text) { bigpatch.diffs.removeFirst() } else { bigpatch.diffs.getFirst().text = bigpatch.diffs.getFirst().text.substring(diff_text.length) } } } precontext = diff_text2(patch.diffs) precontext = precontext.substring(Math.max(0, precontext.length - Patch_Margin)) if (diff_text1(bigpatch.diffs).length() > Patch_Margin) { postcontext = diff_text1(bigpatch.diffs).substring(0, Patch_Margin) } else { postcontext = diff_text1(bigpatch.diffs) } if (postcontext.length != 0) { patch.length1 += postcontext.lengthpatch.length2 += postcontext.length if (!patch.diffs.isEmpty() && patch.diffs.getLast().operation === Operation.EQUAL) { patch.diffs.getLast().text += postcontext } else { patch.diffs.add( jdk.internal.org.jline.utils.DiffHelper.Diff( Operation.EQUAL, postcontext ) ) } } if (!empty) { pointer.add(patch) } }bigpatch = if (pointer.hasNext()) pointer.next() else null } }"	Look through the patches and break up any which are longer than the maximum limit of the match algorithm . Intended to be called only from within patch_apply .
"fun execJavac(toCompile: String?, dir: File, jflexTestVersion: String): TestResult? { val p = Project()val javac = Javac() val path = Path(p, dir.toString())javac.setProject(p) javac.setSrcdir(path) javac.setDestdir(dir) javac.setTarget(javaVersion) javac.setSource(javaVersion) javac.setSourcepath(Path(p, """")) javac.setIncludes(toCompile) val classPath: Path = javac.createClasspath() classPath.setPath(System.getProperty(""user.home"") + ""/.m2/repository/de/jflex/jflex/"" + jflexTestVersion + ""/jflex-"" + jflexTestVersion + "".jar"") val out = ByteArrayOutputStream() val outSafe: PrintStream = System.err System.setErr(PrintStream(out)) return try { javac.execute() TestResult(out.toString(), true) } catch (e: BuildException) { testResult(e.toString() + System.getProperty(""line.separator"") + out.toString(), false) finally { System.setErr(outSafe) } }"	"Call javac on toCompile in input dir . If toCompile is null , all *.java files below dir will be compiled ."
"private fun cloneProperties( certificate: BurpCertificate, burpCertificateBuilder: BurpCertificateBuilder { burpCertificateBuilder.setVersion(certificate.getVersionNumber()) burpCertificateBuilder.setSerial(certificate.getSerialNumberBigInteger()) if (certificate.getPublicKeyAlgorithm().equals(""RSA"")) { burpCertificateBuilder.setSignatureAlgorithm(certificate.getSignatureAlgorithm()) } else { burpCertificateBuilder.setSignatureAlgorithm(""SHA256withRSA"") } burpCertificateBuilder.setIssuer(certificate.getIssuer()) burpCertificateBuilder.setNotAfter(certificate.getNotAfter()) burpCertificateBuilder.setNotBefore(certificate.getNotBefore()) burpCertificateBuilder.setKeySize(certificate.getKeySize()) for (extension in certificate.getAllExtensions()) { burpCertificateBuilder.addExtension(extension) } }"	Copy all X.509v3 general information and all extensions 1:1 from one source certificat to one destination certificate .
"protected fun emit_PropertyMethodDeclaration_SemicolonKeyword_1_q( semanticObject: EObject?, transition: ISynNavigable?, nodes: List<INode?>? ) { acceptNodes(transition, nodes) }"	Ambiguous syntax : ' ; ' ? This ambiguous syntax occurs at : body=Block ( ambiguity ) ( rule end ) declaredName=LiteralOrComputedPropertyName ' ( ' ' ) ' ( ambiguity ) ( rule end ) fpars+=FormalParameter ' ) ' ( ambiguity ) ( rule end )
"@Throws(Throwable::class) fun runTest() { val doc: Document val rootNode: Element val newChild: Node val elementList: NodeList val oldChild: Node var replacedChild: Node doc = load(""hc_staff"", true) as Document newChild = doc.createAttribute(""lang"")elementList = doc.getElementsByTagName(""p"") oldChild = elementList.item(1) rootNode = oldChild.getParentNode() as Element run { var success = false try { replacedChild = rootNode.replaceChild(newChild, oldChild) } catch (ex: DOMException) { success = ex.code === DOMException.HIERARCHY_REQUEST_ERR } assertTrue(""throw_HIERARCHY_REQUEST_ERR"", success) } }"	Runs the test case .
"fun preComputeBestReplicaMapping() { val collectionToShardToCoreMapping: Map<String, Map<String, Map<String, String>>> = getZkClusterData().getCollectionToShardToCoreMapping() for (collection in collectionNames) { val shardToCoreMapping = collectionToShardToCoreMapping[collection]!! for (shard in shardToCoreMapping.keys) { val coreToNodeMap = shardToCoreMapping[shard]!! for (core in coreToNodeMap.keys) { val node = coreToNodeMap[core] val currentReplica = SolrCore(node, core) try { currentReplica.loadStatus() fillUpAllCoresForShard(currentReplica, coreToNodeMap) break } catch (e: Exception) { logger.info(ExceptionUtils.getFullStackTrace(e)) continue } } shardToBestReplicaMapping.put(shard, coreToBestReplicaMappingByHealth) } } }"	"For all the collections in zookeeper , compute the best replica for every shard for every collection . Doing this computation at bootup significantly reduces the computation done during streaming ."
"private fun statInit() {= lDocumentNo.setLabelFor(fDocumentNo) fDocumentNo.setBackground(AdempierePLAF.getInfoBackground()) fDocumentNo.addActionListener(this) lDescription.setLabelFor(fDescription) fDescription.setBackground(AdempierePLAF.getInfoBackground()) fDescription.addActionListener(this) lPOReference.setLabelFor(fPOReference) fPOReference.setBackground(AdempierePLAF.getInfoBackground()) fPOReference.addActionListener(this) fIsSOTrx.setSelected(""N"" != Env.getContext(Env.getCtx(), p_WindowNo, ""IsSOTrx"")) fIsSOTrx.addActionListener(this) fBPartner_ID = VLookup( ""C_BPartner_ID"", false, false, true, MLookupFactory.get( Env.getCtx(), p_WindowNo, 0, MColumn.getColumn_ID(MInOut.Table_Name, MInOut.COLUMNNAME_C_BPartner_ID), DisplayType.Search ) ) lBPartner_ID.setLabelFor(fBPartner_ID) fBPartner_ID.setBackground(AdempierePLAF.getInfoBackground()) fBPartner_ID.addActionListener(this) fShipper_ID = VLookup( ""M_Shipper_ID"", false, false, true, MLookupFactory.get( Env.getCtx(), p_WindowNo, 0, MColumn.getColumn_ID(MInOut.Table_Name, MInOut.COLUMNNAME_M_Shipper_ID), DisplayType.TableDir ) ) lShipper_ID.setLabelFor(fShipper_ID) fShipper_ID.setBackground(AdempierePLAF.getInfoBackground()) fShipper_ID.addActionListener(this) lDateFrom.setLabelFor(fDateFrom) fDateFrom.setBackground(AdempierePLAF.getInfoBackground()) fDateFrom.setToolTipText(Msg.translate(Env.getCtx(), ""DateFrom"")) fDateFrom.addActionListener(this) lDateTo.setLabelFor(fDateTo) fDateTo.setBackground(AdempierePLAF.getInfoBackground()) fDateTo.setToolTipText(Msg.translate(Env.getCtx(), ""DateTo"")) fDateTo.addActionListener(this) val datePanel = CPanel() datePanel.setLayout(ALayout(0, 0, true)) datePanel.add(fDateFrom, ALayoutConstraint(0, 0)) datePanel.add(lDateTo, null) datePanel.add(fDateTo, null) p_criteriaGrid.add(lDocumentNo, ALayoutConstraint(0, 0)) p_criteriaGrid.add(fDocumentNo, null) p_criteriaGrid.add(lBPartner_ID, null) p_criteriaGrid.add(fBPartner_ID, null) p_criteriaGrid.add(fIsSOTrx, ALayoutConstraint(0, 5)) p_criteriaGrid.add(lDescription, ALayoutConstraint(1, 0)) p_criteriaGrid.add(fDescription, null) p_criteriaGrid.add(lDateFrom, null) p_criteriaGrid.add(datePanel, null) p_criteriaGrid.add(lPOReference, ALayoutConstraint(2, 0)) p_criteriaGrid.add(fPOReference, null) p_criteriaGrid.add(lShipper_ID, null) p_criteriaGrid.add(fShipper_ID, null) }"	Static Setup - add fields to parameterPanel
fun check(certificateToken: CertificateToken): Boolean { val keyUsage: Boolean = certificateToken.checkKeyUsage(bit) return keyUsage == value }	Checks the condition for the given certificate .
public static boolean isValidFolderPath ( Path path ) { if ( path == null ) { return false ; } File f = path . toFile ( ) ; return path . toString ( ) . isEmpty ( ) || ( f . isDirectory ( ) && f . canWrite ( ) ) ; }	Checks is the parameter path a valid for saving fixed file
"fun extract( maxFeatureValue: Int, distanceSet: IntArray, img: Array<IntArray> ): Array<FloatArray>? { val histogram = IntArray(maxFeatureValue) val W = img.size val H: Int = img[0].length for (x in 0 until W) { for (y in 0 until H) { histogram[img[x][y]]++ } } val correlogram = Array(maxFeatureValue) { FloatArray( distanceSet.size ) } val tmpCorrelogram = IntArray(distanceSet.size) for (x in 0 until W) { for (y in 0 until H) { val color = img[x][y] getNumPixelsInNeighbourhood(x, y, img, tmpCorrelogram, maxFeatureValue, distanceSet) for (i in distanceSet.indices) { correlogram[color][i] += tmpCorrelogram[i] } } } val max = FloatArray(distanceSet.size) for (c in 0 until maxFeatureValue) { for (i in distanceSet.indices) { max[i] = Math.max(correlogram[c][i], max[i]) } } for (c in 0 until maxFeatureValue) { for (i in distanceSet.indices) { correlogram[c][i] = correlogram[c][i] / max[i] } } return correlogram }"	"extract extracts an auto-correlogram from an Image . This method create a cummulated auto-correlogram over different distances instead of standard method . Also , uses a different normalization method"
"public static CC parseComponentConstraint ( String s ) { CC cc = new CC ( ) ; if ( s . length ( ) == 0 ) { return cc ; } String [ ] parts = toTrimmedTokens ( s , ',' ) ; for ( String part : parts ) { try { if ( part . length ( ) == 0 ) { continue ; } int ix = - 1 ; char c = part . charAt ( 0 ) ; if ( c == 'n' ) { if ( part . equals ( ""north"" ) ) { cc . setDockSide ( 0 ) ; continue ; } if ( part . equals ( ""newline"" ) ) { cc . setNewline ( true ) ; continue ; } if ( part . startsWith ( ""newline "" ) ) { String gapSz = part . substring ( 7 ) . trim ( ) ; cc . setNewlineGapSize ( parseBoundSize ( gapSz , true , true ) ) ; continue ; } } if ( c == 'f' && ( part . equals ( ""flowy"" ) || part . equals ( ""flowx"" ) ) ) { cc . setFlowX ( part . charAt ( 4 ) == 'x' ? Boolean . TRUE : Boolean . FALSE ) ; continue ; } if ( c == 's' ) { ix = startsWithLenient ( part , ""skip"" , 4 , true ) ; if ( ix > - 1 ) { String num = part . substring ( ix ) . trim ( ) ; cc . setSkip ( num . length ( ) != 0 ? Integer . parseInt ( num ) : 1 ) ; continue ; } ix = startsWithLenient ( part , ""split"" , 5 , true ) ; if ( ix > - 1 ) { String split = part . substring ( ix ) . trim ( ) ; cc . setSplit ( split . length ( ) > 0 ? Integer . parseInt ( split ) : LayoutUtil . INF ) ; continue ; } if ( part . equals ( ""south"" ) ) { cc . setDockSide ( 2 ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { ""spany"" , ""sy"" } , new int [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { cc . setSpanY ( parseSpan ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { ""spanx"" , ""sx"" } , new int [ ] { 5 , 2 } , true ) ; if ( ix > - 1 ) { cc . setSpanX ( parseSpan ( part . substring ( ix ) . trim ( ) ) ) ; continue ; } ix = startsWithLenient ( part , ""span"" , 4 , true ) ; if ( ix > - 1 ) { String [ ] spans = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; cc . setSpanX ( spans [ 0 ] . length ( ) > 0 ? Integer . parseInt ( spans [ 0 ] ) : LayoutUtil . INF ) ; cc . setSpanY ( spans . length > 1 ? Integer . parseInt ( spans [ 1 ] ) : 1 ) ; continue ; } ix = startsWithLenient ( part , ""shrinkx"" , 7 , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""shrinky"" , 7 , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""shrink"" , 6 , false ) ; if ( ix > - 1 ) { String [ ] shrinks = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; cc . getHorizontal ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; if ( shrinks . length > 1 ) { cc . getVertical ( ) . setShrink ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; } continue ; } ix = startsWithLenient ( part , new String [ ] { ""shrinkprio"" , ""shp"" } , new int [ ] { 10 , 3 } , true ) ; if ( ix > - 1 ) { String sp = part . substring ( ix ) . trim ( ) ; if ( sp . startsWith ( ""x"" ) || sp . startsWith ( ""y"" ) ) { ( sp . startsWith ( ""x"" ) ? cc . getHorizontal ( ) : cc . getVertical ( ) ) . setShrinkPriority ( Integer . parseInt ( sp . substring ( 2 ) ) ) ; } else { String [ ] shrinks = toTrimmedTokens ( sp , ' ' ) ; cc . getHorizontal ( ) . setShrinkPriority ( Integer . parseInt ( shrinks [ 0 ] ) ) ; if ( shrinks . length > 1 ) { cc . getVertical ( ) . setShrinkPriority ( Integer . parseInt ( shrinks [ 1 ] ) ) ; } } continue ; } ix = startsWithLenient ( part , new String [ ] { ""sizegroupx"" , ""sizegroupy"" , ""sgx"" , ""sgy"" } , new int [ ] { 9 , 9 , 2 , 2 } , true ) ; if ( ix > - 1 ) { String sg = part . substring ( ix ) . trim ( ) ; char lc = part . charAt ( ix - 1 ) ; if ( lc != 'y' ) { cc . getHorizontal ( ) . setSizeGroup ( sg ) ; } if ( lc != 'x' ) { cc . getVertical ( ) . setSizeGroup ( sg ) ; } continue ; } } if ( c == 'g' ) { ix = startsWithLenient ( part , ""growx"" , 5 , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setGrow ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""growy"" , 5 , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setGrow ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""grow"" , 4 , false ) ; if ( ix > - 1 ) { String [ ] grows = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; cc . getHorizontal ( ) . setGrow ( parseFloat ( grows [ 0 ] , ResizeConstraint . WEIGHT_100 ) ) ; cc . getVertical ( ) . setGrow ( parseFloat ( grows . length > 1 ? grows [ 1 ] : """" , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { ""growprio"" , ""gp"" } , new int [ ] { 8 , 2 } , true ) ; if ( ix > - 1 ) { String gp = part . substring ( ix ) . trim ( ) ; char c0 = gp . length ( ) > 0 ? gp . charAt ( 0 ) : ' ' ; if ( c0 == 'x' || c0 == 'y' ) { ( c0 == 'x' ? cc . getHorizontal ( ) : cc . getVertical ( ) ) . setGrowPriority ( Integer . parseInt ( gp . substring ( 2 ) ) ) ; } else { String [ ] grows = toTrimmedTokens ( gp , ' ' ) ; cc . getHorizontal ( ) . setGrowPriority ( Integer . parseInt ( grows [ 0 ] ) ) ; if ( grows . length > 1 ) { cc . getVertical ( ) . setGrowPriority ( Integer . parseInt ( grows [ 1 ] ) ) ; } } continue ; } if ( part . startsWith ( ""gap"" ) ) { BoundSize [ ] gaps = parseGaps ( part ) ; if ( gaps [ 0 ] != null ) { cc . getVertical ( ) . setGapBefore ( gaps [ 0 ] ) ; } if ( gaps [ 1 ] != null ) { cc . getHorizontal ( ) . setGapBefore ( gaps [ 1 ] ) ; } if ( gaps [ 2 ] != null ) { cc . getVertical ( ) . setGapAfter ( gaps [ 2 ] ) ; } if ( gaps [ 3 ] != null ) { cc . getHorizontal ( ) . setGapAfter ( gaps [ 3 ] ) ; } continue ; } } if ( c == 'a' ) { ix = startsWithLenient ( part , new String [ ] { ""aligny"" , ""ay"" } , new int [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { cc . getVertical ( ) . setAlign ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , false , null ) ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { ""alignx"" , ""ax"" } , new int [ ] { 6 , 2 } , true ) ; if ( ix > - 1 ) { cc . getHorizontal ( ) . setAlign ( parseUnitValueOrAlign ( part . substring ( ix ) . trim ( ) , true , null ) ) ; continue ; } ix = startsWithLenient ( part , ""align"" , 2 , true ) ; if ( ix > - 1 ) { String [ ] gaps = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; cc . getHorizontal ( ) . setAlign ( parseUnitValueOrAlign ( gaps [ 0 ] , true , null ) ) ; if ( gaps . length > 1 ) { cc . getVertical ( ) . setAlign ( parseUnitValueOrAlign ( gaps [ 1 ] , false , null ) ) ; } continue ; } } if ( ( c == 'x' || c == 'y' ) && part . length ( ) > 2 ) { char c2 = part . charAt ( 1 ) ; if ( c2 == ' ' || ( c2 == '2' && part . charAt ( 2 ) == ' ' ) ) { if ( cc . getPos ( ) == null ) { cc . setPos ( new UnitValue [ 4 ] ) ; } else if ( cc . isBoundsInGrid ( ) == false ) { throw new IllegalArgumentException ( ""Cannot combine 'position' with 'x/y/x2/y2' keywords."" ) ; } int edge = ( c == 'x' ? 0 : 1 ) + ( c2 == '2' ? 2 : 0 ) ; UnitValue [ ] pos = cc . getPos ( ) ; pos [ edge ] = parseUnitValue ( part . substring ( 2 ) . trim ( ) , null , c == 'x' ) ; cc . setPos ( pos ) ; cc . setBoundsInGrid ( true ) ; continue ; } } if ( c == 'c' ) { ix = startsWithLenient ( part , ""cell"" , 4 , true ) ; if ( ix > - 1 ) { String [ ] grs = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; if ( grs . length < 2 ) { throw new IllegalArgumentException ( ""At least two integers must follow "" + part ) ; } cc . setCellX ( Integer . parseInt ( grs [ 0 ] ) ) ; cc . setCellY ( Integer . parseInt ( grs [ 1 ] ) ) ; if ( grs . length > 2 ) { cc . setSpanX ( Integer . parseInt ( grs [ 2 ] ) ) ; } if ( grs . length > 3 ) { cc . setSpanY ( Integer . parseInt ( grs [ 3 ] ) ) ; } continue ; } } if ( c == 'p' ) { ix = startsWithLenient ( part , ""pos"" , 3 , true ) ; if ( ix > - 1 ) { if ( cc . getPos ( ) != null && cc . isBoundsInGrid ( ) ) { throw new IllegalArgumentException ( ""Can not combine 'pos' with 'x/y/x2/y2' keywords."" ) ; } String [ ] pos = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; UnitValue [ ] bounds = new UnitValue [ 4 ] ; for ( int j = 0 ; j < pos . length ; j ++ ) { bounds [ j ] = parseUnitValue ( pos [ j ] , null , j % 2 == 0 ) ; } if ( bounds [ 0 ] == null && bounds [ 2 ] == null || bounds [ 1 ] == null && bounds [ 3 ] == null ) { throw new IllegalArgumentException ( ""Both x and x2 or y and y2 can not be null!"" ) ; } cc . setPos ( bounds ) ; cc . setBoundsInGrid ( false ) ; continue ; } ix = startsWithLenient ( part , ""pad"" , 3 , true ) ; if ( ix > - 1 ) { UnitValue [ ] p = parseInsets ( part . substring ( ix ) . trim ( ) , false ) ; cc . setPadding ( new UnitValue [ ] { p [ 0 ] , p . length > 1 ? p [ 1 ] : null , p . length > 2 ? p [ 2 ] : null , p . length > 3 ? p [ 3 ] : null } ) ; continue ; } ix = startsWithLenient ( part , ""pushx"" , 5 , true ) ; if ( ix > - 1 ) { cc . setPushX ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""pushy"" , 5 , true ) ; if ( ix > - 1 ) { cc . setPushY ( parseFloat ( part . substring ( ix ) . trim ( ) , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } ix = startsWithLenient ( part , ""push"" , 4 , false ) ; if ( ix > - 1 ) { String [ ] pushs = toTrimmedTokens ( part . substring ( ix ) . trim ( ) , ' ' ) ; cc . setPushX ( parseFloat ( pushs [ 0 ] , ResizeConstraint . WEIGHT_100 ) ) ; cc . setPushY ( parseFloat ( pushs . length > 1 ? pushs [ 1 ] : """" , ResizeConstraint . WEIGHT_100 ) ) ; continue ; } } if ( c == 't' ) { ix = startsWithLenient ( part , ""tag"" , 3 , true ) ; if ( ix > - 1 ) { cc . setTag ( part . substring ( ix ) . trim ( ) ) ; continue ; } } if ( c == 'w' || c == 'h' ) { if ( part . equals ( ""wrap"" ) ) { cc . setWrap ( true ) ; continue ; } if ( part . startsWith ( ""wrap "" ) ) { String gapSz = part . substring ( 5 ) . trim ( ) ; cc . setWrapGapSize ( parseBoundSize ( gapSz , true , true ) ) ; continue ; } boolean isHor = c == 'w' ; if ( isHor && ( part . startsWith ( ""w "" ) || part . startsWith ( ""width "" ) ) ) { String uvStr = part . substring ( part . charAt ( 1 ) == ' ' ? 2 : 6 ) . trim ( ) ; cc . getHorizontal ( ) . setSize ( parseBoundSize ( uvStr , false , true ) ) ; continue ; } if ( ! isHor && ( part . startsWith ( ""h "" ) || part . startsWith ( ""height "" ) ) ) { String uvStr = part . substring ( part . charAt ( 1 ) == ' ' ? 2 : 7 ) . trim ( ) ; cc . getVertical ( ) . setSize ( parseBoundSize ( uvStr , false , false ) ) ; continue ; } if ( part . startsWith ( ""wmin "" ) || part . startsWith ( ""wmax "" ) || part . startsWith ( ""hmin "" ) || part . startsWith ( ""hmax "" ) ) { String uvStr = part . substring ( 5 ) . trim ( ) ; if ( uvStr . length ( ) > 0 ) { UnitValue uv = parseUnitValue ( uvStr , null , isHor ) ; boolean isMin = part . charAt ( 3 ) == 'n' ; DimConstraint dc = isHor ? cc . getHorizontal ( ) : cc . getVertical ( ) ; dc . setSize ( new BoundSize ( isMin ? uv : dc . getSize ( ) . getMin ( ) , dc . getSize ( ) . getPreferred ( ) , isMin ? ( dc . getSize ( ) . getMax ( ) ) : uv , uvStr ) ) ; continue ; } } if ( part . equals ( ""west"" ) ) { cc . setDockSide ( 1 ) ; continue ; } if ( part . startsWith ( ""hidemode "" ) ) { cc . setHideMode ( Integer . parseInt ( part . substring ( 9 ) ) ) ; continue ; } } if ( c == 'i' && part . startsWith ( ""id "" ) ) { cc . setId ( part . substring ( 3 ) . trim ( ) ) ; int dIx = cc . getId ( ) . indexOf ( '.' ) ; if ( dIx == 0 || dIx == cc . getId ( ) . length ( ) - 1 ) { throw new IllegalArgumentException ( ""Dot must not be first or last!"" ) ; } continue ; } if ( c == 'e' ) { if ( part . equals ( ""east"" ) ) { cc . setDockSide ( 3 ) ; continue ; } if ( part . equals ( ""external"" ) ) { cc . setExternal ( true ) ; continue ; } ix = startsWithLenient ( part , new String [ ] { ""endgroupx"" , ""endgroupy"" , ""egx"" , ""egy"" } , new int [ ] { - 1 , - 1 , - 1 , - 1 } , true ) ; if ( ix > - 1 ) { String sg = part . substring ( ix ) . trim ( ) ; char lc = part . charAt ( ix - 1 ) ; DimConstraint dc = ( lc == 'x' ? cc . getHorizontal ( ) : cc . getVertical ( ) ) ; dc . setEndGroup ( sg ) ; continue ; } } if ( c == 'd' ) { if ( part . equals ( ""dock north"" ) ) { cc . setDockSide ( 0 ) ; continue ; } if ( part . equals ( ""dock west"" ) ) { cc . setDockSide ( 1 ) ; continue ; } if ( part . equals ( ""dock south"" ) ) { cc . setDockSide ( 2 ) ; continue ; } if ( part . equals ( ""dock east"" ) ) { cc . setDockSide ( 3 ) ; continue ; } if ( part . equals ( ""dock center"" ) ) { cc . getHorizontal ( ) . setGrow ( new Float ( 100f ) ) ; cc . getVertical ( ) . setGrow ( new Float ( 100f ) ) ; cc . setPushX ( new Float ( 100f ) ) ; cc . setPushY ( new Float ( 100f ) ) ; continue ; } } if ( c == 'v' ) { ix = startsWithLenient ( part , new String [ ] { ""visualpadding"" , ""vp"" } , new int [ ] { 3 , 2 } , true ) ; if ( ix > - 1 ) { UnitValue [ ] p = parseInsets ( part . substring ( ix ) . trim ( ) , false ) ; cc . setVisualPadding ( new UnitValue [ ] { p [ 0 ] , p . length > 1 ? p [ 1 ] : null , p . length > 2 ? p [ 2 ] : null , p . length > 3 ? p [ 3 ] : null } ) ; continue ; } } UnitValue horAlign = parseAlignKeywords ( part , true ) ; if ( horAlign != null ) { cc . getHorizontal ( ) . setAlign ( horAlign ) ; continue ; } UnitValue verAlign = parseAlignKeywords ( part , false ) ; if ( verAlign != null ) { cc . getVertical ( ) . setAlign ( verAlign ) ; continue ; } throw new IllegalArgumentException ( ""Unknown keyword."" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; throw new IllegalArgumentException ( ""Error parsing Constraint: '"" + part + ""'"" ) ; } } return cc ; }"	Parses one component constraint and returns the parsed value .
"fun computeRightChild(node: SegmentTreeNode<*>): SegmentTreeNode<*>? { return if (node.right - node.left > 1) { constructor.construct((node.left + node.right) / 2, node.right) } else null }"	"Compute the right child node , if it exists"
"fun isValidIPAddress(address: String?): Boolean { var address = address if (address == null || address.length == 0) { return false } var ipv6Expected = false if (address[0] == '[') { if (address.length > 2 && address[address.length - 1] == ']') { address = address.substring(1, address.length - 1) ipv6Expected = true } else { return false } } if (address[0].digitToIntOrNull(16) ?: -1 != -1 || address[0] == ':') { var addr: ByteArray? = null addr = strToIPv4(address) if (addr == null) { addr = strToIPv6(address) } else if (ipv6Expected) { return false } if (addr != null) { return true } } return false }"	Checks whether < tt > address < /tt > is a valid IP address string .
"private fun loadVerticesAndRelatives() { val elementList: MutableList<CnATreeElement> = LinkedList<CnATreeElement>() for (loader in getLoaderList()) { loader.setCnaTreeElementDao(getCnaTreeElementDao()) elementList.addAll(loader.loadElements()) } for (element in elementList) { graph.addVertex(element) if (LOG.isDebugEnabled()) { LOG.debug(""Vertex added: "" + element.getTitle()) } uuidMap.put(element.getUuid(), element) } for (parent in elementList) { val children: Set<CnATreeElement> = parent.getChildren() for (child in children) { createParentChildEdge(parent, child) } } }"	Loads all vertices and adds them to the graph . An edge for each children is added if the child is part of the graph .
"private fun initializeLiveAttributes() { transform = createLiveAnimatedTransformList(null, SVG_TRANSFORM_ATTRIBUTE, """")externalResourcesRequired = createLiveAnimatedBoolean(null, SVG_EXTERNAL_RESOURCES_REQUIRED_ATTRIBUTE, false) }"	Initializes the live attribute values of this element .
"fun putParcelable(key: String?, value: Parcelable?) { unparcel() mMap.put(key, value) mFdsKnown = false }"	"Inserts a Parcelable value into the mapping of this Bundle , replacing any existing value for the given key . Either key or value may be null ."
"fun <T> flatten(self: Iterable<T>?, flattenUsing: Closure<out T>?): Collection<T>? { return flatten(self, createSimilarCollection(self), flattenUsing) }"	"Flatten an Iterable . This Iterable and any nested arrays or collections have their contents ( recursively ) added to the new collection . For any non-Array , non-Collection object which represents some sort of collective type , the supplied closure should yield the contained items ; otherwise , the closure should just return any element which corresponds to a leaf ."
fun semiDeviation(): Double { return Math.sqrt(semiVariance()) }	"returns the semi deviation , defined as the square root of the semi variance ."
"public Object runSafely ( Catbert . FastStack stack ) throws Exception { String val = getString ( stack ) ; Sage . put ( getString ( stack ) , val ) ; return null ; }"	Sets the property with the specified name to the specified value . If this is called from a client instance then it will use the properties on the server system for this call and the change will be made on the server system .
"protected fun createUserDictionaryPreference( locale: String?, activity: Activity?  ): Preference? { val newPref = Preference(getActivity()) val intent = Intent(USER_DICTIONARY_SETTINGS_INTENT_ACTION) if (null == locale) { newPref.title = Locale.getDefault().displayName } else { if ("""" == locale) newPref.title = getString(R.string.user_dict_settings_all_languages) else newPref.setTitle( Utils.createLocaleFromString( locale ).getDisplayName() ) intent.putExtra(""locale"", locale) newPref.extras.putString(""locale"", locale) } newPref.intent = intent newPref.fragment = com.android.settings.UserDictionarySettings::class.java.getName() return newPref }"	"Create a single User Dictionary Preference object , with its parameters set ."
"public static < T > T withPrintWriter ( Path self , @ ClosureParams ( value = SimpleType . class , options = ""java.io.PrintWriter"" ) Closure < T > closure ) throws IOException { return IOGroovyMethods . withWriter ( newPrintWriter ( self ) , closure ) ; }"	Create a new PrintWriter for this file which is then passed it into the given closure . This method ensures its the writer is closed after the closure returns .
"@Throws(Exception::class) fun testBug77649() { var props: Properties = getPropertiesFromTestsuiteUrl() val host = props.getProperty(NonRegisteringDriver.HOST_PROPERTY_KEY) val port = props.getProperty(NonRegisteringDriver.PORT_PROPERTY_KEY) val hosts = arrayOf(host, ""address"", ""address.somewhere"", ""addressing"", ""addressing.somewhere"") UnreliableSocketFactory.flushAllStaticData() for (i in 1 until hosts.size) { UnreliableSocketFactory.mapHost(hosts[i], host) } props = getHostFreePropertiesFromTestsuiteUrl() props.setProperty(""socketFactory"", UnreliableSocketFactory::class.java.getName()) for (h in hosts) { getConnectionWithProps(String.format(""jdbc:mysql://%s:%s"", h, port), props).close() getConnectionWithProps( String.format( ""jdbc:mysql://address=(protocol=tcp)(host=%s)(port=%s)"", h, port ), props ).close() } }"	"Tests fix for Bug # 77649 - URL start with word `` address '' , JDBC ca n't parse the `` host : port '' Correctly ."
fun pathsIterator(): Iterator<PluginPatternMatcher>? { return if (mDataPaths != null) mDataPaths.iterator() else null }	Return an iterator over the filter 's data paths .
"private fun checkInMoving(x: Float, y: Float) { val xDiff = Math.abs(x - lastMotionX) as Int val yDiff = Math.abs(y - lastMotionY) as Int val touchSlop: Int = this.touchSlop val xMoved = xDiff > touchSlop val yMoved = yDiff > touchSlop if (xMoved) { touchState = TOUCH_STATE_SCROLLING_X lastMotionX = x lastMotionY = y } if (yMoved) { touchState = TOUCH_STATE_SCROLLING_Y lastMotionX = x lastMotionY = y } }"	Check if the user is moving the cell
"fun checkInstance(instance: Instance): Boolean { if (instance.numAttributes() !== numAttributes()) { return false } for (i in 0 until numAttributes()) { if (instance.isMissing(i)) { continue } else if (attribute(i).isNominal() || attribute(i).isString()) { if (!Utils.eq(instance.value(i), instance.value(i) as Int.toDouble())) { return false } else if (Utils.sm(instance.value(i), 0) || Utils.gr( instance.value(i), attribute(i).numValues() ) ) { return false } } } return true }"	Checks if the given instance is compatible with this dataset . Only looks at the size of the instance and the ranges of the values for nominal and string attributes .
"private fun concatBytes(array1: ByteArray, array2: ByteArray): ByteArray? { val cBytes = ByteArray(array1.size + array2.size) try { System.arraycopy(array1, 0, cBytes, 0, array1.size) System.arraycopy(array2, 0, cBytes, array1.size, array2.size) } catch (e: Exception) { throw FacesException(e)}return cBytes }"	This method concatenates two byte arrays
"fun layout(delta: Int, animate: Boolean) { if (mDataChanged) { handleDataChanged() } if (getCount() === 0) { resetList() return } if (mNextSelectedPosition >= 0) { setSelectedPositionInt(mNextSelectedPosition) } recycleAllViews() detachAllViewsFromParent() val count: Int = sun.util.locale.provider.LocaleProviderAdapter.getAdapter().getCount() val angleUnit = 360.0f / count val angleOffset: Float = mSelectedPosition * angleUnit for (i in 0 until sun.util.locale.provider.LocaleProviderAdapter.getAdapter().getCount()) { var angle = angleUnit * i - angleOffset if (angle < 0.0f) angle = 360.0f + angle makeAndAddView(i, angle) } mRecycler.clear() invalidate() setNextSelectedPositionInt(mSelectedPosition) checkSelectionChanged() mNeedSync = false updateSelectedItemMetadata() }"	Setting up images .
"private void updateMenuItems ( boolean isGpsStarted , boolean isRecording ) { boolean hasTrack = listView != null && listView . getCount ( ) != 0 ; if ( startGpsMenuItem != null ) { startGpsMenuItem . setVisible ( ! isRecording ) ; if ( ! isRecording ) { startGpsMenuItem . setTitle ( isGpsStarted ? R . string . menu_stop_gps : R . string . menu_start_gps ) ; startGpsMenuItem . setIcon ( isGpsStarted ? R . drawable . ic_menu_stop_gps : R . drawable . ic_menu_start_gps ) ; TrackIconUtils . setMenuIconColor ( startGpsMenuItem ) ; } } if ( playMultipleItem != null ) { playMultipleItem . setVisible ( hasTrack ) ; } if ( syncNowMenuItem != null ) { syncNowMenuItem . setTitle ( driveSync ? R . string . menu_sync_now : R . string . menu_sync_drive ) ; } if ( aggregatedStatisticsMenuItem != null ) { aggregatedStatisticsMenuItem . setVisible ( hasTrack ) ; } if ( exportAllMenuItem != null ) { exportAllMenuItem . setVisible ( hasTrack && ! isRecording ) ; } if ( importAllMenuItem != null ) { importAllMenuItem . setVisible ( ! isRecording ) ; } if ( deleteAllMenuItem != null ) { deleteAllMenuItem . setVisible ( hasTrack && ! isRecording ) ; } }"	Updates the menu items .
public boolean isDuplicateSupported ( ) { return duplicateSupported ; }	Indicates whether this connection request supports duplicate entries in the request queue
public void onStart ( ) { }	Called when the animation starts .
"public static int [ ] [ ] loadPNMFile ( InputStream str ) throws IOException { BufferedInputStream stream = new BufferedInputStream ( str ) ; String type = tokenizeString ( stream ) ; if ( type . equals ( ""P1"" ) ) return loadPlainPBM ( stream ) ; else if ( type . equals ( ""P2"" ) ) return loadPlainPGM ( stream ) ; else if ( type . equals ( ""P4"" ) ) return loadRawPBM ( stream ) ; else if ( type . equals ( ""P5"" ) ) return loadRawPGM ( stream ) ; else throw new IOException ( ""Not a viable PBM or PGM stream"" ) ; }"	Loads plain or raw PGM files or plain or raw PBM files and return the result as an int [ ] [ ] . The Y dimension is not flipped .
"public BiCorpus alignedFromFiles ( String f ) throws IOException { return new BiCorpus ( fpath + f + extf , epath + f + exte , apath + f + exta ) ; }"	Generate aligned BiCorpus .
"public LognormalDistr ( double shape , double scale ) { numGen = new LogNormalDistribution ( scale , shape ) ; }"	Instantiates a new Log-normal pseudo random number generator .
"private static String contentLengthHeader ( final long length ) { return String . format ( ""Content-Length: %d"" , length ) ; }"	Format Content-Length header .
@ Bean @ ConditionalOnMissingBean public AmqpSenderService amqpSenderServiceBean ( ) { return new DefaultAmqpSenderService ( rabbitTemplate ( ) ) ; }	Create default amqp sender service bean .
"@ Override protected void initialize ( ) { super . initialize ( ) ; m_Processor = new MarkdownProcessor ( ) ; m_Markdown = """" ; }"	Initializes the members .
"public void upperBound ( byte [ ] key ) throws IOException { upperBound ( key , 0 , key . length ) ; }"	"Move the cursor to the first entry whose key is strictly greater than the input key . Synonymous to upperBound ( key , 0 , key.length ) . The entry returned by the previous entry ( ) call will be invalid ."
"public static String replaceLast ( String s , char sub , char with ) { int index = s . lastIndexOf ( sub ) ; if ( index == - 1 ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; }"	Replaces the very last occurrence of a character in a string .
public static void main ( String [ ] args ) { Thrust simulation = new Thrust ( ) ; simulation . run ( ) ; }	Entry point for the example application .
"public static < T > T checkNotNull ( T reference , @ Nullable String errorMessageTemplate , @ Nullable Object ... errorMessageArgs ) { if ( reference == null ) { throw new NullPointerException ( format ( errorMessageTemplate , errorMessageArgs ) ) ; } return reference ; }"	Ensures that an object reference passed as a parameter to the calling method is not null .
"public boolean insert ( String name , RegExp definition ) { if ( Options . DEBUG ) Out . debug ( ""inserting macro "" + name + "" with definition :"" + Out . NL + definition ) ; used . put ( name , Boolean . FALSE ) ; return macros . put ( name , definition ) == null ; }"	Stores a new macro and its definition .
public boolean add ( Object o ) { ensureCapacity ( size + 1 ) ; elementData [ size ++ ] = o ; return true ; }	Appends the specified element to the end of this list .
"public InvocationTargetException ( Throwable target , String s ) { super ( s , null ) ; this . target = target ; }"	Constructs a InvocationTargetException with a target exception and a detail message .
public boolean isExternalSkin ( ) { return ! isDefaultSkin && mResources != null ; }	whether the skin being used is from external .skin file
"private void updateActions ( ) { actions . removeAll ( ) ; final ActionGroup mainActionGroup = ( ActionGroup ) actionManager . getAction ( getGroupMenu ( ) ) ; if ( mainActionGroup == null ) { return ; } final Action [ ] children = mainActionGroup . getChildren ( null ) ; for ( final Action action : children ) { final Presentation presentation = presentationFactory . getPresentation ( action ) ; final ActionEvent e = new ActionEvent ( ActionPlaces . MAIN_CONTEXT_MENU , presentation , actionManager , 0 ) ; action . update ( e ) ; if ( presentation . isVisible ( ) ) { actions . add ( action ) ; } } }"	Updates the list of visible actions .
private void showFeedback ( String message ) { if ( myHost != null ) { myHost . showFeedback ( message ) ; } else { System . out . println ( message ) ; } }	Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface .
TechCategory fallthrough ( ) { switch ( this ) { case OMNI_AERO : return OMNI ; case CLAN_AERO : case CLAN_VEE : return CLAN ; case IS_ADVANCED_AERO : case IS_ADVANCED_VEE : return IS_ADVANCED ; default : return null ; } }	"If no value is provided for ASFs or Vees , use the base value ."
"static void svd_dscal ( int n , double da , double [ ] dx , int incx ) { if ( n <= 0 || incx == 0 ) return ; int ix = ( incx < 0 ) ? n - 1 : 0 ; for ( int i = 0 ; i < n ; i ++ ) { dx [ ix ] *= da ; ix += incx ; } return ; }"	Function scales a vector by a constant . * Based on Fortran-77 routine from Linpack by J. Dongarra
"public CampoFechaVO insertValue ( final CampoFechaVO value ) { try { DbConnection conn = getConnection ( ) ; DbInsertFns . insert ( conn , TABLE_NAME , DbUtil . getColumnNames ( COL_DEFS ) , new SigiaDbInputRecord ( COL_DEFS , value ) ) ; return value ; } catch ( Exception e ) { logger . error ( ""Error insertando campo de tipo fecha para el descriptor "" + value . getIdObjeto ( ) , e ) ; throw new DBException ( ""insertando campo de tipo fecha"" , e ) ; } }"	Inserta un valor de tipo fecha .
"private synchronized void closeActiveFile ( ) { StringWriterFile activeFile = this . activeFile ; try { this . activeFile = null ; if ( activeFile != null ) { activeFile . close ( ) ; getPolicy ( ) . closeActiveFile ( activeFile . path ( ) ) ; activeFile = null ; } } catch ( IOException e ) { trace . error ( ""error closing active file '{}'"" , activeFile . path ( ) , e ) ; } }"	"close , finalize , and apply retention policy"
"public void testWARTypeEquality ( ) { WAR war1 = new WAR ( ""/some/path/to/file.war"" ) ; WAR war2 = new WAR ( ""/otherfile.war"" ) ; assertEquals ( war1 . getType ( ) , war2 . getType ( ) ) ; }"	Test equality between WAR deployables .
"public static Vector readSignatureAlgorithmsExtension ( byte [ ] extensionData ) throws IOException { if ( extensionData == null ) { throw new IllegalArgumentException ( ""'extensionData' cannot be null"" ) ; } ByteArrayInputStream buf = new ByteArrayInputStream ( extensionData ) ; Vector supported_signature_algorithms = parseSupportedSignatureAlgorithms ( false , buf ) ; TlsProtocol . assertEmpty ( buf ) ; return supported_signature_algorithms ; }"	Read 'signature_algorithms ' extension data .
"public void updateNCharacterStream ( int columnIndex , java . io . Reader x , long length ) throws SQLException { throw new SQLFeatureNotSupportedException ( resBundle . handleGetObject ( ""jdbcrowsetimpl.featnotsupp"" ) . toString ( ) ) ; }"	"Updates the designated column with a character stream value , which will have the specified number of bytes . The driver does the necessary conversion from Java character format to the national character set in the database . It is intended for use when updating NCHAR , NVARCHAR and LONGNVARCHAR columns . The updater methods are used to update column values in the current row or the insert row . The updater methods do not update the underlying database ; instead the updateRow or insertRow methods are called to update the database ."
public boolean isModified ( ) { return isCustom ( ) && ! isUserAdded ( ) ; }	"Returns whether the receiver represents a modified template , i.e . a contributed template that has been changed ."
"public String toString ( ) { return this . getClass ( ) . getName ( ) + ""("" + my_k + "")"" ; }"	Returns a String representation of the receiver .
"private static PostingsEnum termDocs ( IndexReader reader , Term term ) throws IOException { return MultiFields . getTermDocsEnum ( reader , MultiFields . getLiveDocs ( reader ) , term . field ( ) , term . bytes ( ) ) ; }"	NB : this is a convenient but very slow way of getting termDocs . It is sufficient for testing purposes .
public boolean isSubregion ( ) { return subregion ; }	"Returns true if the Region is a subregion of a Component , otherwise false . For example , < code > Region.BUTTON < /code > corresponds do a < code > Component < /code > so that < code > Region.BUTTON.isSubregion ( ) < /code > returns false ."
"public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode == null ) { throw new NullPointerException ( ""Data to encode was null."" ) ; } Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . ENCODE ) ; bos . write ( dataToEncode ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } }"	"Convenience method for encoding data to a file . < p > As of v 2.3 , if there is a error , the method will throw an java.io.IOException . < b > This is new to v2.3 ! < /b > In earlier versions , it just returned false , but in retrospect that 's a pretty poor way to handle it. < /p >"
public synchronized void addDataStatusListener ( DataStatusListener l ) { m_mTab . addDataStatusListener ( l ) ; }	Add Data Status Listener - pass on to MTab
"protected void addField ( DurationFieldType field , int value ) { addFieldInto ( iValues , field , value ) ; }"	Adds the value of a field in this period .
@ Override public int perimeter ( int size ) { size = size / 2 ; int retval = sw . perimeter ( size ) ; retval += se . perimeter ( size ) ; retval += ne . perimeter ( size ) ; retval += nw . perimeter ( size ) ; return retval ; }	Compute the perimeter for a grey node using Samet 's algorithm .
"public BigdataStatementIterator addedIterator ( ) { final IChunkedOrderedIterator < ISPO > src = new ChunkedWrappedIterator < ISPO > ( added . iterator ( ) ) ; return new BigdataStatementIteratorImpl ( kb , src ) . start ( kb . getExecutorService ( ) ) ; }"	Return iterator visiting the inferences that were added to the KB .
"public < V extends Object , C extends RTSpan < V > > void applyEffect ( Effect < V , C > effect , V value ) { if ( mUseRTFormatting && ! mIsSelectionChanging && ! mIsSaving ) { Spannable oldSpannable = mIgnoreTextChanges ? null : cloneSpannable ( ) ; effect . applyToSelection ( this , value ) ; synchronized ( this ) { if ( mListener != null && ! mIgnoreTextChanges ) { Spannable newSpannable = cloneSpannable ( ) ; mListener . onTextChanged ( this , oldSpannable , newSpannable , getSelectionStart ( ) , getSelectionEnd ( ) , getSelectionStart ( ) , getSelectionEnd ( ) ) ; } mLayoutChanged = true ; } } }"	"Call this to have an effect applied to the current selection . You get the Effect object via the static data members ( e.g. , RTEditText.BOLD ) . The value for most effects is a Boolean , indicating whether to add or remove the effect ."
"public DefaultLmlParser ( final LmlData data , final LmlSyntax syntax , final LmlTemplateReader templateReader , final boolean strict ) { super ( data , syntax , templateReader , new DefaultLmlStyleSheet ( ) , strict ) ; }"	"Creates a new parser with custom syntax , reader and strict setting ."
"private static void populateFancy ( SQLiteDatabase writableDb ) { long startOfToday = DateUtil . parse ( DateUtil . format ( System . currentTimeMillis ( ) ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Clothes"" , ""New jeans"" , 10000 , startOfToday , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Flat / House"" , ""Monthly rent"" , 35000 , startOfToday , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Grocery"" , ""Fruits & vegetables"" , 3567 , DateUtil . parse ( ""19/08/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Fuel"" , ""Full gas tank"" , 7590 , DateUtil . parse ( ""14/08/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Clothes"" , ""New shirt"" , 3599 , DateUtil . parse ( ""11/08/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Restaurant"" , ""Family get together"" , 3691 , DateUtil . parse ( ""05/08/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_INCOME , ""Salary"" , """" , 90000 , DateUtil . parse ( ""31/07/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Personal care"" , ""New perfume"" , 3865 , DateUtil . parse ( ""29/07/2015"" ) , Item . NO_ID ) ) ; ItemDao . saveItem ( writableDb , new Item ( Item . TYPE_EXPENSE , ""Grocery"" , ""Bottle of milk"" , 345 , DateUtil . parse ( ""26/07/2015"" ) , Item . NO_ID ) ) ; }"	Generates reasonable amount of good-looking income / expense items .
"public TestEntity ( int index , String text , String value , double minConfidence ) { super ( index , text ) ; this . value = value ; this . minConfidence = minConfidence ; }"	"New instance , with a value ."
"public boolean contains ( JComponent a , int b , int c ) { boolean returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . contains ( a , b , c ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . contains ( a , b , c ) ; } return returnValue ; }"	Invokes the < code > contains < /code > method on each UI handled by this object .
public boolean isClosed ( ) { return closed ; }	Returns true if this contour path is closed ( loops back on itself ) or false if it is not .
"public void store ( float val , Offset offset ) { this . plus ( offset ) . store ( val ) ; }"	Stores the float value in the memory location pointed to by the current instance .
"public List < IvrZone > showIvrZones ( boolean active ) throws NetworkDeviceControllerException { List < IvrZone > zones = new ArrayList < IvrZone > ( ) ; SSHPrompt [ ] prompts = { SSHPrompt . POUND , SSHPrompt . GREATER_THAN } ; StringBuilder buf = new StringBuilder ( ) ; String cmdKey = active ? ""MDSDialog.ivr.show.zone.active.cmd"" : ""MDSDialog.ivr.show.zone.cmd"" ; sendWaitFor ( MDSDialogProperties . getString ( cmdKey ) , defaultTimeout , prompts , buf ) ; String [ ] lines = getLines ( buf ) ; IvrZone zone = null ; IvrZoneMember member = null ; String [ ] regex = { MDSDialogProperties . getString ( ""MDSDialog.ivr.showZoneset.zone.name.match"" ) , MDSDialogProperties . getString ( ""MDSDialog.ivr.showZoneset.zone.member.match"" ) } ; String [ ] groups = new String [ 10 ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case 0 : zone = new IvrZone ( groups [ 0 ] ) ; zones . add ( zone ) ; break ; case 1 : member = new IvrZoneMember ( groups [ 0 ] , Integer . valueOf ( groups [ 3 ] ) ) ; zone . getMembers ( ) . add ( member ) ; break ; } } return zones ; }"	Get switch ivr zones
"public static void append ( File file , Reader reader , String charset ) throws IOException { append ( file , reader , charset , false ) ; }"	"Append the text supplied by the Reader at the end of the File without writing a BOM , using a specified encoding ."
public static LifetimeAttribute createLifetimeAttribute ( int lifetime ) { LifetimeAttribute attribute = new LifetimeAttribute ( ) ; attribute . setLifetime ( lifetime ) ; return attribute ; }	Create a LifetimeAttribute .
"public void testFilePrimary ( ) throws Exception { start ( ) ; igfsPrimary . create ( FILE , true ) . close ( ) ; checkEvictionPolicy ( 0 , 0 ) ; int blockSize = igfsPrimary . info ( FILE ) . blockSize ( ) ; append ( FILE , blockSize ) ; checkEvictionPolicy ( 0 , 0 ) ; read ( FILE , 0 , blockSize ) ; checkEvictionPolicy ( 0 , 0 ) ; }"	Test how evictions are handled for a file working in PRIMARY mode .
"public static String createTestPtStationCSVFile ( File file ) { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( ""id,x,y"" ) ; bw . newLine ( ) ; bw . write ( ""1,10,10"" ) ; bw . newLine ( ) ; bw . write ( ""2,10, 190"" ) ; bw . newLine ( ) ; bw . write ( ""3,190,190"" ) ; bw . newLine ( ) ; bw . write ( ""4,190,10"" ) ; bw . newLine ( ) ; return file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }"	This method creates 4 pt stops for the test network from createTestNetwork ( ) . The information about the coordinates will be written to a csv file . The 4 pt stops are located as a square in the coordinate plane with a side length of 180 meter ( see the sketch below ) .
@ Override public int hashCode ( ) { int result = super . hashCode ( ) ; return result ; }	Returns a hash code for the renderer .
@ Override public void eUnset ( int featureID ) { switch ( featureID ) { case SGenPackage . FEATURE_TYPE__DEPRECATED : setDeprecated ( DEPRECATED_EDEFAULT ) ; return ; case SGenPackage . FEATURE_TYPE__COMMENT : setComment ( COMMENT_EDEFAULT ) ; return ; case SGenPackage . FEATURE_TYPE__PARAMETERS : getParameters ( ) . clear ( ) ; return ; case SGenPackage . FEATURE_TYPE__OPTIONAL : setOptional ( OPTIONAL_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"public boolean isVMAX3VolumeCompressionEnabled ( URI blockObjectURI ) { VirtualPool virtualPool = null ; Volume volume = null ; if ( URIUtil . isType ( blockObjectURI , Volume . class ) ) { volume = _dbClient . queryObject ( Volume . class , blockObjectURI ) ; } else if ( URIUtil . isType ( blockObjectURI , BlockSnapshot . class ) ) { BlockSnapshot snapshot = _dbClient . queryObject ( BlockSnapshot . class , blockObjectURI ) ; volume = _dbClient . queryObject ( Volume . class , snapshot . getParent ( ) ) ; } else if ( URIUtil . isType ( blockObjectURI , BlockMirror . class ) ) { BlockMirror mirror = _dbClient . queryObject ( BlockMirror . class , blockObjectURI ) ; virtualPool = _dbClient . queryObject ( VirtualPool . class , mirror . getVirtualPool ( ) ) ; } if ( volume != null ) { virtualPool = _dbClient . queryObject ( VirtualPool . class , volume . getVirtualPool ( ) ) ; } return ( ( virtualPool != null ) && virtualPool . getCompressionEnabled ( ) ) ; }"	This method is will check if the volume associated with virtual Pool has compression enabled .
public void releaseConnection ( Database conn ) { if ( conn != null ) conn . close ( ) ; }	Releases a connection .
"public final void testRemoveHelperTextId ( ) { PasswordEditText passwordEditText = new PasswordEditText ( getContext ( ) ) ; passwordEditText . addHelperTextId ( android . R . string . cancel ) ; passwordEditText . addHelperTextId ( android . R . string . copy ) ; passwordEditText . removeHelperTextId ( android . R . string . cancel ) ; passwordEditText . removeHelperTextId ( android . R . string . cancel ) ; assertEquals ( 1 , passwordEditText . getHelperTexts ( ) . size ( ) ) ; assertEquals ( getContext ( ) . getText ( android . R . string . copy ) , passwordEditText . getHelperTexts ( ) . iterator ( ) . next ( ) ) ; }"	"Tests the functionality of the method , which allows to remove a helper text by its id ."
"private void logMessage ( String msg , Object [ ] obj ) { if ( getMonitoringPropertiesLoader ( ) . isToLogIndications ( ) ) { _logger . debug ( msg , obj ) ; } }"	Log the messages . This method eliminates the logging condition check every time when we need to log a message .
public static Float toRef ( float f ) { return new Float ( f ) ; }	cast a float value to his ( CFML ) reference type Float
@ Override protected boolean shouldComposeCreationImage ( ) { return true ; }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
public synchronized void promote ( Tile tile ) { if ( tileQueue . contains ( tile ) ) { try { tileQueue . remove ( tile ) ; tile . setPriority ( Tile . Priority . High ) ; tileQueue . put ( tile ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }	Increase the priority of this tile so it will be loaded sooner .
"public void exitApp ( ) { this . webView . getPluginManager ( ) . postMessage ( ""exit"" , null ) ; }"	Exit the Android application .
"public void test_getInnerCause01_reject_otherType ( ) { Throwable t = new Throwable ( ) ; assertNull ( getInnerCause ( t , Exception . class ) ) ; }"	Does not find cause when it is on top of the stack trace and not either the desired type or a subclass of the desired type .
public Handshake handshake ( ) { return handshake ; }	"Returns the TLS handshake of the connection that carried this response , or null if the response was received without TLS ."
"private Coordinate averagePoint ( CoordinateSequence seq ) { Coordinate a = new Coordinate ( 0 , 0 , 0 ) ; int n = seq . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . x += seq . getOrdinate ( i , CoordinateSequence . X ) ; a . y += seq . getOrdinate ( i , CoordinateSequence . Y ) ; a . z += seq . getOrdinate ( i , CoordinateSequence . Z ) ; } a . x /= n ; a . y /= n ; a . z /= n ; return a ; }"	"Computes a point which is the average of all coordinates in a sequence . If the sequence lies in a single plane , the computed point also lies in the plane ."
"public static void invokeWebserviceASync ( WSDefinition def , SuccessCallback scall , FailureCallback fcall , Object ... arguments ) { WSConnection cr = new WSConnection ( def , scall , fcall , arguments ) ; NetworkManager . getInstance ( ) . addToQueue ( cr ) ; }"	Invokes a web asynchronously and calls the callback on completion
public PutResponseMessage ( PutResponseMessage other ) { if ( other . isSetHeader ( ) ) { this . header = new AsyncMessageHeader ( other . header ) ; } }	Performs a deep copy on < i > other < /i > .
private boolean isSynthetic ( Method m ) { if ( ( m . getAccessFlags ( ) & Constants . ACC_SYNTHETIC ) != 0 ) { return true ; } Attribute [ ] attrs = m . getAttributes ( ) ; for ( Attribute attr : attrs ) { if ( attr instanceof Synthetic ) { return true ; } } return false ; }	Methods marked with the `` Synthetic '' attribute do not appear in the source code
public boolean isTagline ( ) { return tagline ; }	Checks if is tagline .
"protected LocaTable ( TrueTypeFont ttf ) { super ( TrueTypeTable . LOCA_TABLE ) ; MaxpTable maxp = ( MaxpTable ) ttf . getTable ( ""maxp"" ) ; int numGlyphs = maxp . getNumGlyphs ( ) ; HeadTable head = ( HeadTable ) ttf . getTable ( ""head"" ) ; short format = head . getIndexToLocFormat ( ) ; isLong = ( format == 1 ) ; offsets = new int [ numGlyphs + 1 ] ; }"	Creates a new instance of HmtxTable
public static < T > T create ( Class < T > theQueryClass ) { return AgentClass . createAgent ( theQueryClass ) ; }	Create a database query dynamically
"@ DSComment ( ""From safe class list"" ) @ DSSafe ( DSCat . SAFE_LIST ) @ DSGenerator ( tool_name = ""Doppelganger"" , tool_version = ""2.0"" , generated_on = ""2013-12-30 13:02:44.163 -0500"" , hash_original_method = ""CE28B7D5A93F674A0286463AAF68C789"" , hash_generated_method = ""4C5D61097E13A407D793E43190510D41"" ) public synchronized void addFailure ( Test test , AssertionFailedError t ) { fFailures . addElement ( new TestFailure ( test , t ) ) ; for ( Enumeration e = cloneListeners ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( TestListener ) e . nextElement ( ) ) . addFailure ( test , t ) ; } }"	Adds a failure to the list of failures . The passed in exception caused the failure .
public ExtendedKeyUsage ( byte [ ] encoding ) { super ( encoding ) ; }	Creates the extension object on the base of its encoded form .
"public Iterator < E > subsetIterator ( E from , E to ) { return new BinarySearchTreeIterator < E > ( this . root , from , to ) ; }"	Returns the in-order ( ascending ) iterator .
public int valueForXPosition ( int xPos ) { int value ; int minValue = slider . getMinimum ( ) ; int maxValue = slider . getMaximum ( ) ; int trackLeft = trackRect . x + thumbRect . width / 2 + trackBorder ; int trackRight = trackRect . x + trackRect . width - thumbRect . width / 2 - trackBorder ; int trackLength = trackRight - trackLeft ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; }	"Returns a value give an x position . If xPos is past the track at the left or the right it will set the value to the min or max of the slider , depending if the slider is inverted or not ."
@ Override protected EClass eStaticClass ( ) { return SRuntimePackage . Literals . COMPOSITE_SLOT ; }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"public static void main ( final String [ ] args ) { DOMTestCase . doMain ( documentcreateattributeNS03 . class , args ) ; }"	Runs this test from the command line .
public ListIterator < AbstractInsnNode > iterator ( ) { return iterator ( 0 ) ; }	Returns an iterator over the instructions in this list .
public static String escapeXml ( String str ) { if ( str == null ) { return null ; } return EntitiesUtils . XML . escape ( str ) ; }	"< p > Escapes the characters in a < code > String < /code > using XML entities. < /p > < p > For example : < tt > '' bread '' & `` butter '' < /tt > = > < tt > & amp ; quot ; bread & amp ; quot ; & amp ; amp ; & amp ; quot ; butter & amp ; quot ; < /tt > . < /p > < p > Supports only the five basic XML entities ( gt , lt , quot , amp , apos ) . Does not support DTDs or external entities. < /p > < p > Note that unicode characters greater than 0x7f are currently escaped to their numerical \\u equivalent . This may change in future releases . < /p >"
"public boolean isProcessed ( ) { Object oo = get_Value ( COLUMNNAME_Processed ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return ""Y"" . equals ( oo ) ; } return false ; }"	Get Processed .
"public void processResponse ( SIPResponse response , MessageChannel incomingMessageChannel , SIPDialog dialog ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logDebug ( ""PROCESSING INCOMING RESPONSE"" + response . encodeMessage ( ) ) ; } if ( listeningPoint == null ) { if ( sipStack . isLoggingEnabled ( ) ) sipStack . getStackLogger ( ) . logError ( ""Dropping message: No listening point"" + "" registered!"" ) ; return ; } if ( sipStack . checkBranchId ( ) && ! Utils . getInstance ( ) . responseBelongsToUs ( response ) ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logError ( ""Dropping response - topmost VIA header does not originate from this stack"" ) ; } return ; } SipProviderImpl sipProvider = listeningPoint . getProvider ( ) ; if ( sipProvider == null ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logError ( ""Dropping message: no provider"" ) ; } return ; } if ( sipProvider . getSipListener ( ) == null ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logError ( ""No listener -- dropping response!"" ) ; } return ; } SIPClientTransaction transaction = ( SIPClientTransaction ) this . transactionChannel ; SipStackImpl sipStackImpl = sipProvider . sipStack ; if ( sipStack . isLoggingEnabled ( ) ) { sipStackImpl . getStackLogger ( ) . logDebug ( ""Transaction = "" + transaction ) ; } if ( transaction == null ) { if ( dialog != null ) { if ( response . getStatusCode ( ) / 100 != 2 ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logDebug ( ""Response is not a final response and dialog is found for response -- dropping response!"" ) ; } return ; } else if ( dialog . getState ( ) == DialogState . TERMINATED ) { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logDebug ( ""Dialog is terminated -- dropping response!"" ) ; } return ; } else { boolean ackAlreadySent = false ; if ( dialog . isAckSeen ( ) && dialog . getLastAckSent ( ) != null ) { if ( dialog . getLastAckSent ( ) . getCSeq ( ) . getSeqNumber ( ) == response . getCSeq ( ) . getSeqNumber ( ) ) { ackAlreadySent = true ; } } if ( ackAlreadySent && response . getCSeq ( ) . getMethod ( ) . equals ( dialog . getMethod ( ) ) ) { try { if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logDebug ( ""Retransmission of OK detected: Resending last ACK"" ) ; } dialog . resendAck ( ) ; return ; } catch ( SipException ex ) { if ( sipStack . isLoggingEnabled ( ) ) sipStack . getStackLogger ( ) . logError ( ""could not resend ack"" , ex ) ; } } } } if ( sipStack . isLoggingEnabled ( ) ) { sipStack . getStackLogger ( ) . logDebug ( ""could not find tx, handling statelessly Dialog = "" + dialog ) ; } ResponseEventExt sipEvent = new ResponseEventExt ( sipProvider , transaction , dialog , ( Response ) response ) ; if ( response . getCSeqHeader ( ) . getMethod ( ) . equals ( Request . INVITE ) ) { SIPClientTransaction forked = this . sipStack . getForkedTransaction ( response . getTransactionId ( ) ) ; sipEvent . setOriginalTransaction ( forked ) ; } sipProvider . handleEvent ( sipEvent , transaction ) ; return ; } ResponseEventExt responseEvent = null ; responseEvent = new ResponseEventExt ( sipProvider , ( ClientTransactionExt ) transaction , dialog , ( Response ) response ) ; if ( response . getCSeqHeader ( ) . getMethod ( ) . equals ( Request . INVITE ) ) { SIPClientTransaction forked = this . sipStack . getForkedTransaction ( response . getTransactionId ( ) ) ; responseEvent . setOriginalTransaction ( forked ) ; } if ( dialog != null && response . getStatusCode ( ) != 100 ) { dialog . setLastResponse ( transaction , response ) ; transaction . setDialog ( dialog , dialog . getDialogId ( ) ) ; } sipProvider . handleEvent ( responseEvent , transaction ) ; }"	Process the response .
"public AnnotationAtttributeProposalInfo ( IJavaProject project , CompletionProposal proposal ) { super ( project , proposal ) ; }"	Creates a new proposal info .
"public static void restoreReminderPreference ( Context context ) { int hour = MehPreferencesManager . getNotificationPreferenceHour ( context ) ; int minute = MehPreferencesManager . getNotificationPreferenceMinute ( context ) ; scheduleDailyReminder ( context , hour , minute ) ; }"	"Restore the daily reminder , with the times already in preferences . Useful for device reboot or switched on from the settings screen"
@ Override public boolean isActive ( ) { return amIActive ; }	Used by the Whitebox GUI to tell if this plugin is still running .
BarChart ( ) { }	Instantiates a new bar chart .
"public boolean isTransactionRelevant ( Transaction tx ) throws ScriptException { lock . lock ( ) ; try { return tx . getValueSentFromMe ( this ) . signum ( ) > 0 || tx . getValueSentToMe ( this ) . signum ( ) > 0 || ! findDoubleSpendsAgainst ( tx , transactions ) . isEmpty ( ) ; } finally { lock . unlock ( ) ; } }"	"< p > Returns true if the given transaction sends coins to any of our keys , or has inputs spending any of our outputs , and also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions. < /p > < p > Note that if the tx has inputs containing one of our keys , but the connected transaction is not in the wallet , it will not be considered relevant. < /p >"
"public void free ( GL2 gl ) { if ( vbos [ 0 ] >= 0 ) { gl . glDeleteBuffers ( 1 , vbos , 0 ) ; } vbos [ 0 ] = - 1 ; }"	Free all memory allocations .
"public Vector3 ( float x , float y , float z ) { this . set ( x , y , z ) ; }"	Creates a vector with the given components
protected S_ActionImpl ( ) { super ( ) ; }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
public void clear ( int maximumCapacity ) { if ( capacity <= maximumCapacity ) { clear ( ) ; return ; } zeroValue = null ; hasZeroValue = false ; size = 0 ; resize ( maximumCapacity ) ; }	Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger .
"public void bulkLoad ( DBIDs ids ) { if ( ids . size ( ) == 0 ) { return ; } assert ( root == null ) : ""Tree already initialized."" ; DBIDIter it = ids . iter ( ) ; DBID first = DBIDUtil . deref ( it ) ; ModifiableDoubleDBIDList candidates = DBIDUtil . newDistanceDBIDList ( ids . size ( ) - 1 ) ; for ( it . advance ( ) ; it . valid ( ) ; it . advance ( ) ) { candidates . add ( distance ( first , it ) , it ) ; } root = bulkConstruct ( first , Integer . MAX_VALUE , candidates ) ; }"	Bulk-load the index .
"protected ExtendedSolrQueryParser createEdismaxQueryParser ( QParser qParser , String field ) { return new ExtendedSolrQueryParser ( qParser , field ) ; }"	"Creates an instance of ExtendedSolrQueryParser , the query parser that 's going to be used to parse the query ."
"protected void appendSummary ( StringBuffer buffer , String fieldName , long [ ] array ) { appendSummarySize ( buffer , fieldName , array . length ) ; }"	< p > Append to the < code > toString < /code > a summary of a < code > long < /code > array. < /p >
protected UndoableEdit editToBeRedone ( ) { int count = edits . size ( ) ; int i = indexOfNextAdd ; while ( i < count ) { UndoableEdit edit = edits . elementAt ( i ++ ) ; if ( edit . isSignificant ( ) ) { return edit ; } } return null ; }	Returns the the next significant edit to be redone if < code > redo < /code > is invoked . This returns < code > null < /code > if there are no edits to be redone .
"public void actionPerformed ( ActionEvent e ) { Box b1 = Box . createVerticalBox ( ) ; Version currentVersion = Version . currentViewableVersion ( ) ; String copyright = LicenseUtils . copyright ( ) ; copyright = copyright . replaceAll ( ""\n"" , ""<br>"" ) ; String latestVersion = LatestClient . getInstance ( ) . getLatestResult ( 60 ) ; latestVersion = latestVersion . replaceAll ( ""\n"" , ""<br>"" ) ; JLabel label = new JLabel ( ) ; label . setText ( ""<html>"" + ""<b>Tetrad "" + currentVersion + ""</b>"" + ""<br>"" + ""<br>Laboratory for Symbolic and Educational Computing"" + ""<br>Department of Philosophy"" + ""<br>Carnegie Mellon University"" + ""<br>"" + ""<br>Project Direction: Clark Glymour, Richard Scheines, Peter Spirtes"" + ""<br>Lead Developer: Joseph Ramsey"" + ""<br>"" + copyright + ""<br>"" + latestVersion + ""</html>"" ) ; label . setBackground ( Color . LIGHT_GRAY ) ; label . setFont ( new Font ( ""Dialog"" , Font . PLAIN , 12 ) ) ; label . setBorder ( new CompoundBorder ( new LineBorder ( Color . DARK_GRAY ) , new EmptyBorder ( 10 , 10 , 10 , 10 ) ) ) ; b1 . add ( label ) ; JOptionPane . showMessageDialog ( JOptionUtils . centeringComp ( ) , b1 , ""About Tetrad..."" , JOptionPane . PLAIN_MESSAGE ) ; }"	Closes the frontmost session of this action 's desktop .
private void redrawMarkers ( ) { UI . execute ( null ) ; }	Redraw all markers and set them straight to their current locations without animations .
public void addToolTipSeries ( List toolTips ) { this . toolTipSeries . add ( toolTips ) ; }	Adds a list of tooltips for a series .
"static private String [ ] alphaMixedNumeric ( ) { return StringFunctions . combineStringArrays ( StringFunctions . alphaMixed ( ) , StringFunctions . numeric ) ; }"	Combine the alpha mixed and numeric collections into one
long incrementInMsgs ( ) { return inMsgs . incrementAndGet ( ) ; }	Increments the number of messages received on this connection .
public final void yyreset ( java . io . Reader reader ) { zzBuffer = s . array ; zzStartRead = s . offset ; zzEndRead = zzStartRead + s . count - 1 ; zzCurrentPos = zzMarkedPos = s . offset ; zzLexicalState = YYINITIAL ; zzReader = reader ; zzAtEOF = false ; }	"Resets the scanner to read from a new input stream . Does not close the old reader . All internal variables are reset , the old input stream < b > can not < /b > be reused ( internal buffer is discarded and lost ) . Lexical state is set to < tt > YY_INITIAL < /tt > ."
"public IntArraySpliterator ( int [ ] array , int origin , int fence , int additionalCharacteristics ) { this . array = array ; this . index = origin ; this . fence = fence ; this . characteristics = additionalCharacteristics | Spliterator . SIZED | Spliterator . SUBSIZED ; }"	Creates a spliterator covering the given array and range
"@ Override public void populateDAG ( DAG dag , Configuration conf ) { TweetsInput input = new TweetsInput ( ) ; Collector collector = new Collector ( ) ; WindowOption windowOption = new WindowOption . GlobalWindow ( ) ; ApexStream < String > tags = StreamFactory . fromInput ( input , input . output , name ( ""tweetSampler"" ) ) . flatMap ( new ExtractHashtags ( ) ) ; tags . window ( windowOption , new TriggerOption ( ) . accumulatingFiredPanes ( ) . withEarlyFiringsAtEvery ( 1 ) ) . addCompositeStreams ( ComputeTopCompletions . top ( 10 , true ) ) . print ( name ( ""console"" ) ) . endWith ( collector , collector . input , name ( ""collector"" ) ) . populateDag ( dag ) ; }"	Populate the dag with High-Level API .
"public void testBug21947042 ( ) throws Exception { Connection sslConn = null ; Properties props = new Properties ( ) ; props . setProperty ( ""logger"" , ""StandardLogger"" ) ; StandardLogger . startLoggingToBuffer ( ) ; try { int searchFrom = 0 ; int found = 0 ; sslConn = getConnectionWithProps ( props ) ; if ( versionMeetsMinimum ( 5 , 7 ) ) { assertTrue ( ( ( MySQLConnection ) sslConn ) . getUseSSL ( ) ) ; assertFalse ( ( ( MySQLConnection ) sslConn ) . getVerifyServerCertificate ( ) ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getIO ( ) . isSSLEstablished ( ) ) ; } else { assertFalse ( ( ( MySQLConnection ) sslConn ) . getUseSSL ( ) ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getVerifyServerCertificate ( ) ) ; assertFalse ( ( ( MySQLConnection ) sslConn ) . getIO ( ) . isSSLEstablished ( ) ) ; } ResultSet rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_cipher'"" ) ; assertTrue ( rset . next ( ) ) ; String cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_cipher="" + cipher ) ; rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_version'"" ) ; assertTrue ( rset . next ( ) ) ; cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_version="" + cipher ) ; sslConn . close ( ) ; String log = StandardLogger . getBuffer ( ) . toString ( ) ; found = log . indexOf ( Messages . getString ( ""MysqlIO.SSLWarning"" ) , searchFrom ) ; searchFrom = found + 1 ; if ( versionMeetsMinimum ( 5 , 7 ) ) { assertTrue ( found != - 1 ) ; } props . setProperty ( ""useSSL"" , ""false"" ) ; sslConn = getConnectionWithProps ( props ) ; assertFalse ( ( ( MySQLConnection ) sslConn ) . getUseSSL ( ) ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getVerifyServerCertificate ( ) ) ; assertFalse ( ( ( MySQLConnection ) sslConn ) . getIO ( ) . isSSLEstablished ( ) ) ; rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_cipher'"" ) ; assertTrue ( rset . next ( ) ) ; cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_cipher="" + cipher ) ; rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_version'"" ) ; assertTrue ( rset . next ( ) ) ; cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_version="" + cipher ) ; sslConn . close ( ) ; log = StandardLogger . getBuffer ( ) . toString ( ) ; found = log . indexOf ( Messages . getString ( ""MysqlIO.SSLWarning"" ) , searchFrom ) ; if ( found != - 1 ) { searchFrom = found + 1 ; fail ( ""Warning is not expected when useSSL is explicitly set to 'false'."" ) ; } props . setProperty ( ""useSSL"" , ""true"" ) ; props . setProperty ( ""trustCertificateKeyStoreUrl"" , ""file:src/testsuite/ssl-test-certs/test-cert-store"" ) ; props . setProperty ( ""trustCertificateKeyStoreType"" , ""JKS"" ) ; props . setProperty ( ""trustCertificateKeyStorePassword"" , ""password"" ) ; sslConn = getConnectionWithProps ( props ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getUseSSL ( ) ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getVerifyServerCertificate ( ) ) ; assertTrue ( ( ( MySQLConnection ) sslConn ) . getIO ( ) . isSSLEstablished ( ) ) ; rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_cipher'"" ) ; assertTrue ( rset . next ( ) ) ; cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_cipher="" + cipher ) ; rset = sslConn . createStatement ( ) . executeQuery ( ""SHOW STATUS LIKE 'ssl_version'"" ) ; assertTrue ( rset . next ( ) ) ; cipher = rset . getString ( 2 ) ; System . out . println ( ""ssl_version="" + cipher ) ; sslConn . close ( ) ; log = StandardLogger . getBuffer ( ) . toString ( ) ; found = log . indexOf ( Messages . getString ( ""MysqlIO.SSLWarning"" ) , searchFrom ) ; if ( found != - 1 ) { searchFrom = found + 1 ; fail ( ""Warning is not expected when useSSL is explicitly set to 'false'."" ) ; } } finally { StandardLogger . dropBuffer ( ) ; } }"	"Tests fix for BUG # 21947042 , PREFER TLS WHERE SUPPORTED BY MYSQL SERVER . Requires test certificates from testsuite/ssl-test-certs to be installed on the server being tested ."
"public JComponent createEmbeddedPropertyGUI ( String prefix , Properties props , Properties info ) { if ( Debug . debugging ( ""inspectordetail"" ) ) { Debug . output ( ""Inspector creating GUI for "" + prefix + ""\nPROPERTIES "" + props + ""\nPROP INFO "" + info ) ; } String propertyList = info . getProperty ( PropertyConsumer . initPropertiesProperty ) ; Vector < String > sortedKeys ; if ( propertyList != null ) { Vector < String > propertiesToShow = PropUtils . parseSpacedMarkers ( propertyList ) ; for ( int i = 0 ; i < propertiesToShow . size ( ) ; i ++ ) { propertiesToShow . set ( i , prefix + ""."" + propertiesToShow . get ( i ) ) ; } sortedKeys = propertiesToShow ; } else { sortedKeys = sortKeys ( props . keySet ( ) ) ; } editors = new Hashtable < String , PropertyEditor > ( sortedKeys . size ( ) ) ; JPanel component = new JPanel ( ) ; component . setLayout ( new BorderLayout ( ) ) ; JPanel propertyPanel = new JPanel ( ) ; GridBagLayout gridbag = new GridBagLayout ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . insets = new Insets ( 2 , 10 , 2 , 10 ) ; propertyPanel . setLayout ( gridbag ) ; int i = 0 ; for ( String prop : sortedKeys ) { String marker = prop ; if ( prefix != null && prop . startsWith ( prefix ) ) { marker = prop . substring ( prefix . length ( ) + 1 ) ; } if ( marker . startsWith ( ""."" ) ) { marker = marker . substring ( 1 ) ; } String editorMarker = marker + PropertyConsumer . ScopedEditorProperty ; String editorClass = info . getProperty ( editorMarker ) ; if ( editorClass == null ) { editorClass = defaultEditorClass ; } Class < ? > propertyEditorClass = null ; PropertyEditor editor = null ; try { propertyEditorClass = Class . forName ( editorClass ) ; editor = ( PropertyEditor ) propertyEditorClass . newInstance ( ) ; if ( editor instanceof PropertyConsumer ) { ( ( PropertyConsumer ) editor ) . setProperties ( marker , info ) ; } editors . put ( prop , editor ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; editorClass = null ; } Component editorFace = null ; if ( editor != null && editor . supportsCustomEditor ( ) ) { editorFace = editor . getCustomEditor ( ) ; } else { editorFace = new JLabel ( i18n . get ( Inspector . class , ""Does_not_support_custom_editor"" , ""Does not support custom editor"" ) ) ; } if ( editor != null ) { Object propVal = props . get ( prop ) ; if ( Debug . debugging ( ""inspector"" ) ) { Debug . output ( ""Inspector loading "" + prop + ""("" + propVal + "")"" ) ; } editor . setValue ( propVal ) ; } String labelMarker = marker + PropertyConsumer . LabelEditorProperty ; String labelText = info . getProperty ( labelMarker ) ; if ( labelText == null ) { labelText = marker ; } JLabel label = new JLabel ( labelText + "":"" ) ; label . setHorizontalAlignment ( SwingConstants . RIGHT ) ; c . gridx = 0 ; c . gridy = i ++ ; c . weightx = 0 ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; gridbag . setConstraints ( label , c ) ; propertyPanel . add ( label ) ; c . gridx = 1 ; c . anchor = GridBagConstraints . WEST ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1f ; gridbag . setConstraints ( editorFace , c ) ; propertyPanel . add ( editorFace ) ; String toolTip = ( String ) info . get ( marker ) ; label . setToolTipText ( toolTip == null ? i18n . get ( Inspector . class , ""No_further_information_available"" , ""No further information available."" ) : toolTip ) ; } JScrollPane scrollPane = new JScrollPane ( propertyPanel , ScrollPaneConstants . VERTICAL_SCROLLBAR_AS_NEEDED , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_NEVER ) ; scrollPane . setBorder ( null ) ; scrollPane . setAlignmentY ( Component . TOP_ALIGNMENT ) ; component . add ( scrollPane , BorderLayout . CENTER ) ; return component ; }"	Creates a JComponent with the properties to be changed . This component is suitable for inclusion into a GUI . Do n't use this method directly ! Use the createPropertyGUI ( PropertyConsumer ) instead . You will get a NullPointerException if you use this method without setting the PropertyConsumer in the Inspector .
"public void onScanImageClick ( View v ) { Intent intent = new Intent ( this , ScanImageActivity . class ) ; intent . putExtra ( ExtrasKeys . EXTRAS_LICENSE_KEY , LICENSE_KEY ) ; intent . putExtra ( ExtrasKeys . EXTRAS_RECOGNITION_SETTINGS , mRecognitionSettings ) ; startActivityForResult ( intent , MY_REQUEST_CODE ) ; }"	Handler for `` Scan Image '' button
"public boolean isReadOnly ( ) { Object oo = get_Value ( COLUMNNAME_IsReadOnly ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return ""Y"" . equals ( oo ) ; } return false ; }"	Get Read Only .
"public static < K , V > Map < K , V > asSynchronized ( Map < K , V > self ) { return Collections . synchronizedMap ( self ) ; }"	A convenience method for creating a synchronized Map .
private boolean isRecursive ( Nonterminal nonterm ) { return comp . getNodes ( ) . contains ( nonterm ) ; }	Return true if the nonterminal is recursive .
"private void initInfo ( int record_id , String value ) { if ( ! ( record_id == 0 ) && value != null && value . length ( ) > 0 ) { log . severe ( ""Received both a record_id and a value: "" + record_id + "" - "" + value ) ; } if ( ! ( record_id == 0 ) ) { fieldID = record_id ; } else { if ( value != null && value . length ( ) > 0 ) { fDocumentNo . setValue ( value ) ; } else { String id ; id = Env . getContext ( Env . getCtx ( ) , p_WindowNo , p_TabNo , ""M_InOut_ID"" , true ) ; if ( id != null && id . length ( ) != 0 && ( new Integer ( id ) . intValue ( ) > 0 ) ) { fieldID = new Integer ( id ) . intValue ( ) ; } id = Env . getContext ( Env . getCtx ( ) , p_WindowNo , p_TabNo , ""C_BPartner_ID"" , true ) ; if ( id != null && id . length ( ) != 0 && ( new Integer ( id ) . intValue ( ) > 0 ) ) fBPartner_ID . setValue ( new Integer ( id ) ) ; id = Env . getContext ( Env . getCtx ( ) , p_WindowNo , p_TabNo , ""M_Shipper_ID"" , true ) ; if ( id != null && id . length ( ) != 0 && ( new Integer ( id ) . intValue ( ) > 0 ) ) { fShipper_ID . setValue ( new Integer ( id ) . intValue ( ) ) ; } } } }"	General Init
public IssueMatcher add ( ) { IssueMatcher issueMatcher = new IssueMatcher ( ) ; issueMatchers . add ( issueMatcher ) ; return issueMatcher ; }	Creates a new issue matcher and adds it to this matcher .
protected ParameterizedPropertyAccessExpression_IMImpl ( ) { super ( ) ; }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"private void loadFinishScreen ( ) { CoordinatorLayout . LayoutParams lp = new CoordinatorLayout . LayoutParams ( CoordinatorLayout . LayoutParams . WRAP_CONTENT , CoordinatorLayout . LayoutParams . WRAP_CONTENT ) ; mFloatingActionButton . setLayoutParams ( lp ) ; mFloatingActionButton . setVisibility ( View . INVISIBLE ) ; NestedScrollView contentLayout = ( NestedScrollView ) findViewById ( R . id . challenge_rootcontainer ) ; if ( contentLayout != null ) { contentLayout . removeAllViews ( ) ; View view = getLayoutInflater ( ) . inflate ( R . layout . fragment_finish_challenge , contentLayout , false ) ; contentLayout . addView ( view ) ; } }"	Loads the finish screen and unloads all other screens
"private void compactSegment ( Segment segment , OffsetPredicate predicate , Segment compactSegment ) { for ( long i = segment . firstIndex ( ) ; i <= segment . lastIndex ( ) ; i ++ ) { checkEntry ( i , segment , predicate , compactSegment ) ; } }"	Compacts the given segment .
"public static Class < ? > forName ( String name , ClassLoader classLoader ) throws ClassNotFoundException , LinkageError { Assert . notNull ( name , ""Name must not be null"" ) ; Class < ? > clazz = resolvePrimitiveClassName ( name ) ; if ( clazz == null ) { clazz = commonClassCache . get ( name ) ; } if ( clazz != null ) { return clazz ; } if ( name . endsWith ( ARRAY_SUFFIX ) ) { String elementClassName = name . substring ( 0 , name . length ( ) - ARRAY_SUFFIX . length ( ) ) ; Class < ? > elementClass = forName ( elementClassName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } if ( name . startsWith ( NON_PRIMITIVE_ARRAY_PREFIX ) && name . endsWith ( "";"" ) ) { String elementName = name . substring ( NON_PRIMITIVE_ARRAY_PREFIX . length ( ) , name . length ( ) - 1 ) ; Class < ? > elementClass = forName ( elementName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } if ( name . startsWith ( INTERNAL_ARRAY_PREFIX ) ) { String elementName = name . substring ( INTERNAL_ARRAY_PREFIX . length ( ) ) ; Class < ? > elementClass = forName ( elementName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } ClassLoader classLoaderToUse = classLoader ; if ( classLoaderToUse == null ) { classLoaderToUse = getDefaultClassLoader ( ) ; } try { return classLoaderToUse . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { int lastDotIndex = name . lastIndexOf ( '.' ) ; if ( lastDotIndex != - 1 ) { String innerClassName = name . substring ( 0 , lastDotIndex ) + '$' + name . substring ( lastDotIndex + 1 ) ; try { return classLoaderToUse . loadClass ( innerClassName ) ; } catch ( ClassNotFoundException ex2 ) { } } throw ex ; } }"	"Replacement for < code > Class.forName ( ) < /code > that also returns Class instances for primitives ( e.g . `` int '' ) and array class names ( e.g . `` String [ ] '' ) . Furthermore , it is also capable of resolving inner class names in Java source style ( e.g . `` java.lang.Thread.State '' instead of `` java.lang.Thread $ State '' ) ."
"public String toString ( int indentFactor ) throws JSONException { return toString ( indentFactor , 0 ) ; }"	Make a prettyprinted JSON text of this JSONObject . < p > Warning : This method assumes that the data structure is acyclical .
"@ SuppressWarnings ( ""MethodWithMultipleReturnPoints"" ) public static boolean checkSu ( ) { if ( ! new File ( ""/system/bin/su"" ) . exists ( ) && ! new File ( ""/system/xbin/su"" ) . exists ( ) ) { Log . e ( TAG , ""su binary does not exist!!!"" ) ; return false ; } try { if ( runSuCommand ( ""ls /data/app-private"" ) . success ( ) ) { Log . i ( TAG , "" SU exists and we have permission"" ) ; return true ; } else { Log . i ( TAG , "" SU exists but we don't have permission"" ) ; return false ; } } catch ( NullPointerException e ) { Log . e ( TAG , ""NullPointer throw while looking for su binary"" , e ) ; return false ; } }"	Checks device for SuperUser permission
"public String toString ( int indentFactor ) throws JSONException { StringWriter sw = new StringWriter ( ) ; synchronized ( sw . getBuffer ( ) ) { return this . write ( sw , indentFactor , 0 ) . toString ( ) ; } }"	Make a prettyprinted JSON text of this JSONArray . Warning : This method assumes that the data structure is acyclical .
public Boolean isHttpSupportInformation ( ) { return httpSupportInformation ; }	Ruft den Wert der httpSupportInformation-Eigenschaft ab .
"public static URLConnection createConnectionToURL ( final String url , final Map < String , String > requestHeaders ) throws IOException { final URL connectionURL = URLUtility . stringToUrl ( url ) ; if ( connectionURL == null ) { throw new IOException ( ""Invalid url format: "" + url ) ; } final URLConnection urlConnection = connectionURL . openConnection ( ) ; urlConnection . setConnectTimeout ( CONNECTION_TIMEOUT ) ; urlConnection . setReadTimeout ( READ_TIMEOUT ) ; if ( requestHeaders != null ) { for ( final Map . Entry < String , String > entry : requestHeaders . entrySet ( ) ) { urlConnection . setRequestProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return urlConnection ; }"	Create URLConnection instance .
public ASN1Primitive toASN1Primitive ( ) { try { if ( certificateType == profileType ) { return profileToASN1Object ( ) ; } if ( certificateType == requestType ) { return requestToASN1Object ( ) ; } } catch ( IOException e ) { return null ; } return null ; }	create a `` request '' or `` profile '' type Iso7816CertificateBody according to the variables sets .
public Builder mapper ( final Mapper < ObjectMapper > mapper ) { this . mapper = mapper ; return this ; }	Override all of the builder options with this mapper . If this value is set to something other than null then that value will be used to construct the writer .
"private int [ ] [ ] div ( int [ ] a , int [ ] f ) { int df = computeDegree ( f ) ; int da = computeDegree ( a ) + 1 ; if ( df == - 1 ) { throw new ArithmeticException ( ""Division by zero."" ) ; } int [ ] [ ] result = new int [ 2 ] [ ] ; result [ 0 ] = new int [ 1 ] ; result [ 1 ] = new int [ da ] ; int hc = headCoefficient ( f ) ; hc = field . inverse ( hc ) ; result [ 0 ] [ 0 ] = 0 ; System . arraycopy ( a , 0 , result [ 1 ] , 0 , result [ 1 ] . length ) ; while ( df <= computeDegree ( result [ 1 ] ) ) { int [ ] q ; int [ ] coeff = new int [ 1 ] ; coeff [ 0 ] = field . mult ( headCoefficient ( result [ 1 ] ) , hc ) ; q = multWithElement ( f , coeff [ 0 ] ) ; int n = computeDegree ( result [ 1 ] ) - df ; q = multWithMonomial ( q , n ) ; coeff = multWithMonomial ( coeff , n ) ; result [ 0 ] = add ( coeff , result [ 0 ] ) ; result [ 1 ] = add ( q , result [ 1 ] ) ; } return result ; }"	Compute the result of the division of two polynomials over the field < tt > GF ( 2^m ) < /tt > .
"public static short toShort ( byte [ ] bytes , int start ) { return toShort ( bytes [ start ] , bytes [ start + 1 ] ) ; }"	Returns short from given array of bytes . < br > Array must have at least start + 2 elements in it .
"public void addAttribute ( AttributedCharacterIterator . Attribute attribute , Object value , int start , int end ) { if ( attribute == null ) { throw new NullPointerException ( ""attribute == null"" ) ; } if ( start < 0 || end > text . length ( ) || start >= end ) { throw new IllegalArgumentException ( ) ; } if ( value == null ) { return ; } List < Range > ranges = attributeMap . get ( attribute ) ; if ( ranges == null ) { ranges = new ArrayList < Range > ( 1 ) ; ranges . add ( new Range ( start , end , value ) ) ; attributeMap . put ( attribute , ranges ) ; return ; } ListIterator < Range > it = ranges . listIterator ( ) ; while ( it . hasNext ( ) ) { Range range = it . next ( ) ; if ( end <= range . start ) { it . previous ( ) ; break ; } else if ( start < range . end || ( start == range . end && value . equals ( range . value ) ) ) { Range r1 = null , r3 ; it . remove ( ) ; r1 = new Range ( range . start , start , range . value ) ; r3 = new Range ( end , range . end , range . value ) ; while ( end > range . end && it . hasNext ( ) ) { range = it . next ( ) ; if ( end <= range . end ) { if ( end > range . start || ( end == range . start && value . equals ( range . value ) ) ) { it . remove ( ) ; r3 = new Range ( end , range . end , range . value ) ; break ; } } else { it . remove ( ) ; } } if ( value . equals ( r1 . value ) ) { if ( value . equals ( r3 . value ) ) { it . add ( new Range ( r1 . start < start ? r1 . start : start , r3 . end > end ? r3 . end : end , r1 . value ) ) ; } else { it . add ( new Range ( r1 . start < start ? r1 . start : start , end , r1 . value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } else { if ( value . equals ( r3 . value ) ) { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , r3 . end > end ? r3 . end : end , r3 . value ) ) ; } else { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , end , value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } return ; } } it . add ( new Range ( start , end , value ) ) ; }"	Applies a given attribute to the given range of this string .
"@ Override public Double hincrByFloat ( final String key , final String field , final double value ) { checkIsInMultiOrPipeline ( ) ; client . hincrByFloat ( key , field , value ) ; final String dval = client . getBulkReply ( ) ; return ( dval != null ? new Double ( dval ) : null ) ; }"	"Increment the number stored at field in the hash at key by a double precision floating point value . If key does not exist , a new key holding a hash is created . If field does not exist or holds a string , the value is set to 0 before applying the operation . Since the value argument is signed you can use this command to perform both increments and decrements . < p > The range of values supported by HINCRBYFLOAT is limited to double precision floating point values . < p > < b > Time complexity : < /b > O ( 1 )"
public DrawerBuilder withFooter ( @ NonNull View footerView ) { this . mFooterView = footerView ; return this ; }	Add a footer to the DrawerBuilder ListView . This can be any view
"@ Override public int compareTo ( final Object obj ) throws ClassCastException { final URI another = ( URI ) obj ; if ( ! equals ( _authority , another . getRawAuthority ( ) ) ) { return - 1 ; } return toString ( ) . compareTo ( another . toString ( ) ) ; }"	Compare this URI to another object .
public boolean isNavigationAtBottom ( ) { return ( mSmallestWidthDp >= 600 || mInPortrait ) ; }	Should a navigation bar appear at the bottom of the screen in the current device configuration ? A navigation bar may appear on the right side of the screen in certain configurations .
"@ Override public void execute ( String filePath ) { final CurrentProject currentProject = appContext . getCurrentProject ( ) ; if ( filePath != null && ! filePath . startsWith ( ""/"" ) ) { filePath = ""/"" . concat ( filePath ) ; } if ( currentProject != null ) { String fullPath = currentProject . getRootProject ( ) . getPath ( ) + filePath ; log . debug ( ""Open file {0}"" , fullPath ) ; currentProject . getCurrentTree ( ) . getNodeByPath ( fullPath , new TreeNodeAsyncCallback ( ) ) ; } }"	Open a file for the current given path .
"public void executionDetailsEnd ( final ConcurrentHashMap < Integer , TradeOrder > tradeOrders ) { try { Tradingday todayTradingday = m_tradingdays . getTradingday ( TradingCalendar . getTradingDayStart ( TradingCalendar . getDateTimeNowMarketTimeZone ( ) ) , TradingCalendar . getTradingDayEnd ( TradingCalendar . getDateTimeNowMarketTimeZone ( ) ) ) ; if ( null == todayTradingday ) { return ; } tradingdayPanel . doRefresh ( todayTradingday ) ; tradingdayPanel . doRefreshTradingdayTable ( todayTradingday ) ; } catch ( Exception ex ) { this . setErrorMessage ( ""Error starting PositionManagerRule."" , ex . getMessage ( ) , ex ) ; } }"	This method is fired when the Brokermodel has completed the request for Execution Details see doFetchExecution or connectionOpened i.e from a BrokerModel event all executions for the filter have now been received . Check to see if we need to close any trades for these order fills .
public void successfullyCreated ( ) { if ( notification != null ) { notification . setStatus ( SUCCESS ) ; notification . setTitle ( locale . createSnapshotSuccess ( ) ) ; } }	Changes notification state to successfully finished .
"public HybridTimestampFactory ( int counterBits ) { if ( counterBits < 0 || counterBits > 31 ) { throw new IllegalArgumentException ( ""counterBits must be in [0:31]"" ) ; } lastTimestamp = 0L ; this . counterBits = counterBits ; maxCounter = BigInteger . valueOf ( 2 ) . pow ( counterBits ) . intValue ( ) - 1 ; log . warn ( ""#counterBits="" + counterBits + "", maxCounter="" + maxCounter ) ; }"	Allows up to < code > 2^counterBits < /code > distinct timestamps per millisecond .
@ Override public void clear ( ) { this . _map . clear ( ) ; }	Empties the map .
"public boolean removeElement ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; m_firstFree -- ; return true ; } } return false ; }"	"Removes the first occurrence of the argument from this vector . If the object is found in this vector , each component in the vector with an index greater or equal to the object 's index is shifted downward to have an index one smaller than the value it had previously ."
"private void addSingleton ( TempCluster clus , DBIDRef id , double dist , boolean asCluster ) { if ( asCluster ) { clus . addChild ( makeSingletonCluster ( id , dist ) ) ; } else { clus . add ( id ) ; } clus . depth = dist ; }"	"Add a singleton object , as point or cluster ."
public int size ( ) { return values . length ; }	Returns the number of values in this kernel .
"private void testServerJoinLate ( Member . Type type , CopycatServer . State state ) throws Throwable { createServers ( 3 ) ; CopycatClient client = createClient ( ) ; submit ( client , 0 , 1000 ) ; await ( 30000 ) ; CopycatServer joiner = createServer ( nextMember ( type ) ) ; joiner . onStateChange ( null ) ; joiner . join ( members . stream ( ) . map ( null ) . collect ( Collectors . toList ( ) ) ) . thenRun ( null ) ; await ( 30000 , 2 ) ; }"	Tests joining a server after many entries have been committed .
"fun createRadioButton(x: Int, y: Int, diameter: Int): Shape? { return createEllipseInternal(x, y, diameter, diameter) }"	Return a path for a radio button 's concentric sections .
"@DSComment(""From safe class list"") @DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:57:11.638 -0500"", hash_original_method = ""3CEC44303CC022BBEC9F119BC403FDBC"", hash_generated_method = ""FD349EDA389F166F5AB5B32AD7B69928"" ) fun size(): Int { return al.size() }"	Returns the number of elements in this set .
"fun formatRateString(rate: Float): String? { return String.format(Locale.US, ""%.2fx"", rate) }"	Get the formatted current playback speed in the form of 1.00x
"@Throws(FileNotFoundException::class) private fun decodeImageForOption(resolver: ContentResolver, uri: Uri): BitmapFactory.Options? { var stream: InputStream? = null return try { stream = resolver.openInputStream(uri) val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeStream(stream, EMPTY_RECT, options) options.inJustDecodeBounds = false options }  finally { closeSafe(stream) } }"	Decode image from uri using `` inJustDecodeBounds '' to get the image dimensions .
fun FinalSQLString(sqlstring: BasicSQLString) { this.delegate = sqlstring }	Should only be called inside SQLString because this class essentially verifies that we 've checked for updates .
fun loadArgArray() { push(argumentTypes.length) newArray(jdk.internal.org.objectweb.asm.commons.InstructionAdapter.OBJECT_TYPE) for (i in 0 until argumentTypes.length) { dup() push(i) loadArg(i) jdk.internal.vm.compiler.word.impl.WordBoxFactory.box<jdk.internal.vm.compiler.word.WordBase>( argumentTypes.get(i) ) arrayStore(jdk.internal.org.objectweb.asm.commons.InstructionAdapter.OBJECT_TYPE) } }	"Generates the instructions to load all the method arguments on the stack , as a single object array ."
"@Throws(ServletException::class, IOException::class) fun doGet(request: HttpServletRequest?, response: HttpServletResponse?) { WebUtil.createLoginPage(request, response, this, null, null) }"	Process the HTTP Get request
"private fun DeferredFileOutputStream( threshold: Int, outputFile: File, prefix: String, suffix: String, directory: File ) { super(threshold) outputFile = outputFile memoryOutputStream = ByteArrayOutputStream() currentOutputStream = memoryOutputStream prefix = prefix suffix = suffix directory = directory }"	"Constructs an instance of this class which will trigger an event at the specified threshold , and save data either to a file beyond that point ."
"fun testSetSystemScope() { val systemScope: IdentityScope = IdentityScope.getSystemScope() try { `is` = IdentityScopeStub(""Aleksei Semenov"") IdentityScopeStub.mySetSystemScope(`is`) assertSame(`is`, IdentityScope.getSystemScope()) } finally { IdentityScopeStub.mySetSystemScope(systemScope) } }"	check that if permission given - set/get works if permission is denied than SecurityException is thrown
"@JvmStatic fun main(args: Array<String>) { runEvaluator(WrapperSubsetEval(), args) }"	Main method for testing this class .
"fun v(tag: String?, msg: String?, vararg args: Any?) { var msg = msg if (sLevel > LEVEL_VERBOSE) { return } if (args.size > 0) { msg = String.format(msg!!, *args) } Log.v(tag, msg) }"	Send a VERBOSE log message .
"@DSComment(""Package priviledge"") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"",generated_on = ""2013-12-30 12:58:04.267 -0500"", hash_original_method = ""2CE5F24A4C571BEECB25C40400E44908"", hash_generated_method = ""A3579B97578194B5EA0183D0F747142C"" ) fun computeNextElement() { while (true) { if (currentBits !== 0) { mask = currentBits and -currentBits return } else if (++index < bits.length) { currentBits = bits.get(index) } else { mask = 0 return } } }"	"Assigns mask and index to the next available value , cycling currentBits as necessary ."
"fun HierarchyEvent( source: Component?, id: Int, changed: Component, changedParent: Container, changeFlags: Long ) { super(source, id) changed = changed changedParent = changedParent changeFlags = changeFlags }"	Constructs an < code > HierarchyEvent < /code > object to identify a change in the < code > Component < /code > hierarchy . < p > This method throws an < code > IllegalArgumentException < /code > if < code > source < /code > is < code > null < /code > .
fun step(state: SimState?) {}	"This method is performed when the next step for the agent is computed . This agent does nothing , so nothing is inside the body of the method ."
fun resetRuntime() { currentTime = 1392409281320L wasTimeAccessed = false hashKeys.clear() restoreProperties() needToRestoreProperties = false }	Reset runtime to initial state
"fun ExpandCaseMultipliersAction(editor: DataEditor?) { super(""Expand Case Multipliers"") if (editor == null) { throw NullPointerException() } this.dataEditor = editor }"	Creates a new action to split by collinear columns .
fun ScaleFake() {}	Creates a new instance of ScaleFake
protected fun ArrayElementImpl() { super() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun FilterRowIterator(rows: IntIterator, t: Table, p: Predicate) { this.predicate = p rows = rows t = t next = advance() }"	Create a new FilterRowIterator .
"@Throws(JasperException::class) private fun scanJar(conn: JarURLConnection, tldNames: List<String>?, isLocal: Boolean) { val resourcePath: String = conn.getJarFileURL().toString() var tldInfos: Array<TldInfo?> = jarTldCacheLocal.get(resourcePath) if (tldInfos != null && tldInfos.size == 0) { try { conn.getJarFile().close() } catch (ex: IOException) { } return } if (tldInfos == null) { var jarFile: JarFile? = null val tldInfoA: ArrayList<TldInfo> = ArrayList<TldInfo>() try { jarFile = conn.getJarFile() if (tldNames != null) { for (tldName in tldNames) { val entry: JarEntry = jarFile.getJarEntry(tldName) val stream: InputStream = jarFile.getInputStream(entry) tldInfoA.add(scanTld(resourcePath, tldName, stream)) } } else { val entries: Enumeration<JarEntry> = jarFile.entries() while (entries.hasMoreElements()) { val entry: JarEntry = entries.nextElement() val name: String = entry.getName() if (!name.startsWith(""META-INF/"")) continue if (!name.endsWith("".tld"")) continue val stream: InputStream = jarFile.getInputStream(entry) tldInfoA.add(scanTld(resourcePath, name, stream)) } } } catch (ex: IOException) { if (resourcePath.startsWith(FILE_PROTOCOL) && !File(resourcePath).exists()) { if (log.isLoggable(Level.WARNING)) { log.log( Level.WARNING, Localizer.getMessage(""jsp.warn.nojar"", resourcePath), ex ) } } else { throw JasperException( Localizer.getMessage(""jsp.error.jar.io"", resourcePath), ex ) } } finally { if (jarFile != null) { try { jarFile.close() } catch (t: Throwable) { } } } tldInfos = tldInfoA.toArray(arrayOfNulls<TldInfo>(tldInfoA.size())) jarTldCacheLocal.put(resourcePath, tldInfos) if (!isLocal) { jarTldCache.put(resourcePath, tldInfos) } } for (tldInfo in tldInfos) { if (scanListeners) { addListener(tldInfo, isLocal) } mapTldLocation(resourcePath, tldInfo, isLocal) } }"	"Scans the given JarURLConnection for TLD files located in META-INF ( or a subdirectory of it ) . If the scanning in is done as part of the ServletContextInitializer , the listeners in the tlds in this jar file are added to the servlet context , and for any TLD that has a < uri > element , an implicit map entry is added to the taglib map ."
fun cosft1(y: DoubleArray?) { com.nr.fft.FFT.cosft1(y) }	"Calculates the cosine transform of a set y [ 0..n ] of real-valued data points . The transformed data replace the original data in array y. n must be a power of 2 . This program , without changes , also calculates the inverse cosine transform , but in this case the output array should be multiplied by 2/n ."
fun stop() { mRunning = false mStop = true }	Stops the animation in place . It does not snap the image to its final translation .
operator fun hasNext(): Boolean { return cursor > 0 }	This is used to determine if the cursor has reached the start of the list . When the cursor reaches the start of the list then this method returns false .
"protected fun onFinished(player: Player, successful: Boolean) { if (successful) { val itemName: String = items.get(Rand.rand(items.length)) val item: Item = SingletonRepository.getEntityManager().getItem(itemName) var amount = 1 if (itemName == ""dark dagger"" || itemName == ""horned golden helmet"") { item.setBoundTo(player.getName()) } else if (itemName == ""money"") { amount = Rand.roll1D100() (item as StackableItem).setQuantity(amount) } player.equipOrPutOnGround(item) player.incObtainedForItem(item.getName(), item.getQuantity()) SingletonRepository.getAchievementNotifier().onObtain(player) player.sendPrivateText( ""You were lucky and found "" + com.sun.org.apache.xerces.internal.xni.grammars.Grammar.quantityplnoun( amount, itemName, ""a"" ).toString() + ""."" ) } else { player.sendPrivateText(""Your wish didn't come true."") } }"	Called when the activity has finished .
"fun saveWalletAndWalletInfoSimple( perWalletModelData: WalletData, walletFilename: String?, walletInfoFilename: String? ) { val walletFile = File(walletFilename) val walletInfo: WalletInfoData = perWalletModelData.getWalletInfo() var fileOutputStream: FileOutputStream? = null try { if (perWalletModelData.getWallet() != null) { if (walletInfo != null) { val walletDescriptionInInfoFile: String = walletInfo.getProperty(WalletInfoData.DESCRIPTION_PROPERTY) if (walletDescriptionInInfoFile != null) { perWalletModelData.getWallet().setDescription(walletDescriptionInInfoFile) } } log.debug( ""Saving wallet file '"" + walletFile.getAbsolutePath().toString() + ""' ..."" ) if (MultiBitWalletVersion.SERIALIZED === walletInfo.getWalletVersion()) { throw WalletSaveException( ""Cannot save wallet '"" + walletFile.getAbsolutePath() .toString() + ""'. Serialized wallets are no longer supported."" ) } else { var walletIsActuallyEncrypted = false val wallet: Wallet = perWalletModelData.getWallet() for (key in wallet.getKeychain()) { if (key.isEncrypted()) { walletIsActuallyEncrypted = true break } } if (walletIsActuallyEncrypted) { walletInfo.setWalletVersion(MultiBitWalletVersion.PROTOBUF_ENCRYPTED) } if (MultiBitWalletVersion.PROTOBUF === walletInfo.getWalletVersion()) { perWalletModelData.getWallet().saveToFile(walletFile) } else if (MultiBitWalletVersion.PROTOBUF_ENCRYPTED === walletInfo.getWalletVersion()) { fileOutputStream = FileOutputStream(walletFile) walletProtobufSerializer.writeWallet( perWalletModelData.getWallet(), fileOutputStream ) } else { throw WalletVersionException( ""Cannot save wallet '"" + perWalletModelData.getWalletFilename() .toString() + ""'. Its wallet version is '"" + walletInfo.getWalletVersion() .toString() .toString() + ""' but this version of MultiBit does not understand that format."" ) } } log.debug(""... done saving wallet file."") } } catch (ioe: IOException) { throw WalletSaveException( ""Cannot save wallet '"" + perWalletModelData.getWalletFilename(), ioe ) } finally { if (fileOutputStream != null) { try { fileOutputStream.flush() fileOutputStream.close() } catch (e: IOException) { throw WalletSaveException( ""Cannot save wallet '"" + perWalletModelData.getWalletFilename(), e ) } } } walletInfo.writeToFile(walletInfoFilename, walletInfo.getWalletVersion()) }"	Simply save the wallet and wallet info files . Used for backup writes .
"@Throws(CloneNotSupportedException::class) fun clone(): Any? { val clone: DefaultIntervalXYDataset = super.clone() as DefaultIntervalXYDataset clone.seriesKeys = ArrayList<Any?>(this.seriesKeys) clone.seriesList = ArrayList(this.seriesList.size()) for (i in 0 until this.seriesList.size()) { val data = this.seriesList.get(i) as Array<DoubleArray> val x = data[0] val xStart = data[1] val xEnd = data[2] val y = data[3] val yStart = data[4] val yEnd = data[5] val xx = DoubleArray(x.size) val xxStart = DoubleArray(xStart.size) val xxEnd = DoubleArray(xEnd.size) val yy = DoubleArray(y.size) val yyStart = DoubleArray(yStart.size) val yyEnd = DoubleArray(yEnd.size) System.arraycopy(x, 0, xx, 0, x.size) System.arraycopy(xStart, 0, xxStart, 0, xStart.size) System.arraycopy(xEnd, 0, xxEnd, 0, xEnd.size) System.arraycopy(y, 0, yy, 0, y.size) System.arraycopy(yStart, 0, yyStart, 0, yStart.size) System.arraycopy(yEnd, 0, yyEnd, 0, yEnd.size) clone.seriesList.add(i, arrayOf(xx, xxStart, xxEnd, yy, yyStart, yyEnd)) } return clone }"	Returns a clone of this dataset .
"fun EveningActivityMovement(settings: Settings) { super(settings) super.backAllowed = false pathFinder = DijkstraPathFinder(null) mode = WALKING_TO_MEETING_SPOT_MODE nrOfMeetingSpots = settings.getInt(NR_OF_MEETING_SPOTS_SETTING) minGroupSize = settings.getInt(MIN_GROUP_SIZE_SETTING) maxGroupSize = settings.getInt(MAX_GROUP_SIZE_SETTING) val mapNodes: Array<MapNode> = jdk.nashorn.internal.objects.Global.getMap().getNodes() .toArray(arrayOfNulls<MapNode>(0)) var shoppingSpotsFile: String? = null try { shoppingSpotsFile = settings.getSetting(MEETING_SPOTS_FILE_SETTING) } catch (t: Throwable) { } var meetingSpotLocations: MutableList<Coord?>? = null if (shoppingSpotsFile == null) { meetingSpotLocations = LinkedList<Coord?>() for (i in mapNodes.indices) { if (i % (mapNodes.size / nrOfMeetingSpots) === 0) { startAtLocation = mapNodes[i].getLocation().clone() meetingSpotLocations!!.add(startAtLocation.clone()) } } } else { try { meetingSpotLocations = LinkedList<Coord?>() val locationsRead: List<Coord> = WKTReader().readPoints(File(shoppingSpotsFile)) for (coord in locationsRead) { val map: SimMap = jdk.nashorn.internal.objects.Global.getMap() val offset: Coord = map.getOffset() if (map.isMirrored()) { coord.setLocation(coord.getX(), -coord.getY()) } coord.translate(offset.getX(), offset.getY()) meetingSpotLocations!!.add(coord) } } catch (e: Exception) { e.printStackTrace() } } this.id = nextID++ val scsID: Int = settings.getInt(EVENING_ACTIVITY_CONTROL_SYSTEM_NR_SETTING) scs = EveningActivityControlSystem.getEveningActivityControlSystem(scsID) scs.setRandomNumberGenerator(rng) scs.addEveningActivityNode(this) scs.setMeetingSpots(meetingSpotLocations) maxPathLength = 100 minPathLength = 10 maxWaitTime = settings.getInt(MAX_WAIT_TIME_SETTING) minWaitTime = settings.getInt(MIN_WAIT_TIME_SETTING) }"	Creates a new instance of EveningActivityMovement
"protected fun makeHullComplex(pc: Array<DoubleArray?>): java.awt.Polygon? { val hull = GrahamScanConvexHull2D() val diag = doubleArrayOf(0.0, 0.0) for (j in pc.indices) { hull.add(pc[j]) hull.add(javax.management.Query.times(pc[j], -1)) for (k in j + 1 until pc.size) { val q = pc[k] val ppq: DoubleArray = timesEquals( javax.management.Query.plus(pc[j], q), org.graalvm.compiler.loop.MathUtil.SQRTHALF ) val pmq: DoubleArray = timesEquals(minus(pc[j], q),  org.graalvm.compiler.loop.MathUtil.SQRTHALF) hull.add(ppq) hull.add(javax.management.Query.times(ppq, -1)) hull.add(pmq) hull.add(javax.management.Query.times(pmq, -1)) for (l in k + 1 until pc.size) { val r = pc[k] val ppqpr: DoubleArray = timesEquals(javax.management.Query.plus(ppq, r), Math.sqrt(1 / 3.0)) val pmqpr: DoubleArray = timesEquals(javax.management.Query.plus(pmq, r), Math.sqrt(1 / 3.0)) val ppqmr: DoubleArray = timesEquals(minus(ppq, r), Math.sqrt(1 / 3.0)) val pmqmr: DoubleArray = timesEquals(minus(pmq, r), Math.sqrt(1 / 3.0)) hull.add(ppqpr) hull.add(javax.management.Query.times(ppqpr, -1)) hull.add(pmqpr) hull.add(javax.management.Query.times(pmqpr, -1)) hull.add(ppqmr) hull.add(javax.management.Query.times(ppqmr, -1)) hull.add(pmqmr) hull.add(javax.management.Query.times(pmqmr, -1)) } } plusEquals(diag, pc[j]) } timesEquals(diag, 1.0 / Math.sqrt(pc.size.toDouble())) hull.add(diag) hull.add(javax.management.Query.times(diag, -1)) return hull.getHull() }"	Build a convex hull to approximate the sphere .
"fun visitAnnotations(node: AnnotatedNode) { super.visitAnnotations(node) for (annotation in node.getAnnotations()) { if (transforms.containsKey(annotation)) { targetNodes.add(arrayOf<ASTNode>(annotation, node)) } } }"	Adds the annotation to the internal target list if a match is found .
"fun Node(next: Node<K?, V?>) { this.key = null this.value = this next = next }"	"Creates a new marker node . A marker is distinguished by having its value field point to itself . Marker nodes also have null keys , a fact that is exploited in a few places , but this does n't distinguish markers from the base-level header node ( head.node ) , which also has a null key ."
fun onDrawerClosed(view: View?) { super.onDrawerClosed(view) }	Called when a drawer has settled in a completely closed state .
"fun deserializeAddressList(serializedAddresses: String): List<String?>? { return Arrays.asList(serializedAddresses.split("","").toTypedArray()) }"	Deserialize a list of IP addresses from a string .
@Throws(IOException::class) fun challengeReceived(challenge: String?) { currentMechanism.challengeReceived(challenge) }	The server is challenging the SASL authentication we just sent . Forward the challenge to the current SASLMechanism we are using . The SASLMechanism will send a response to the server . The length of the challenge-response sequence varies according to the SASLMechanism in use .
"fun fitsType(env: Environment?, ctx: Context?, t: Type): Boolean { if (this.type.isType(TC_CHAR)) { return super.fitsType(env, ctx, t) } when (t.getTypeCode()) { TC_BYTE -> return value === value as Byte TC_SHORT -> return value === value as Short TC_CHAR -> return value === value as Char } return super.fitsType(env, ctx, t) }"	See if this number fits in the given type .
"fun ServiceManager(services: Iterable<Service?>?) { var copy: ImmutableList<Service?> = ImmutableList.copyOf(services) if (copy.isEmpty()) { logger.log( Level.WARNING, ""ServiceManager configured with no services. Is your application configured properly?"", EmptyServiceManagerWarning() ) copy = ImmutableList.< Service > of < Service ? > NoOpService() } this.state = ServiceManagerState(copy) services = copy val stateReference: WeakReference<ServiceManagerState> = WeakReference<ServiceManagerState>(state) for (service in copy) { service.addListener( ServiceListener(service, stateReference), MoreExecutors.directExecutor() ) checkArgument(service.state() === NEW, ""Can only manage NEW services, %s"", service) } this.state.markReady() }"	Constructs a new instance for managing the given services .
fun hasModule(moduleName: String?): Boolean { return moduleStore.containsKey(moduleName) || moduleStore.containsValue(moduleName) }	Looks up a module
"private fun removeUnusedTilesets(map: Map<*, *>) { val sets: MutableIterator<*> = map.getTileSets().iterator() while (sets.hasNext()) { val tileset: TileSet = sets.next() as TileSet if (!isUsedTileset(map, tileset)) { sets.remove() } } }"	Remove any tilesets in a map that are not actually in use .
fun transformPoint(v: vec3): vec3? { val result = vec3() result.m.get(0) = this.m.get(0) * v.m.get(0) + this.m.get(4) * v.m.get(1) + this.m.get(8) * v.m.get(2) + this.m.get( 12 ) result.m.get(1) = this.m.get(1) * v.m.get(0) + this.m.get(5) * v.m.get(1) + this.m.get(9) * v.m.get(2) + this.m.get( 13 ) result.m.get(2) = this.m.get(2) * v.m.get(0) + this.m.get(6) * v.m.get(1) + this.m.get(10) * v.m.get(2) + this.m.get( 14 ) return result }	\fn transformPoint \brief Returns a transformed point \param v [ vec3 ]
fun createFromString(str: String?): AttrSessionID? { return AttrSessionID(str) }	Creates a new attribute instance from the provided String .
"fun Spinner(model: javax.swing.ListModel, rendererInstance: javax.swing.ListCellRenderer?) { super(model) ios7Mode = javax.swing.UIManager.getInstance().isThemeConstant(""ios7SpinnerBool"", false) if (ios7Mode) { super.setMinElementHeight(6) } SpinnerRenderer.iOS7Mode = ios7Mode setRenderer(rendererInstance) setUIID(""Spinner"") setFixedSelection(FIXED_CENTER) setOrientation(VERTICAL) setInputOnFocus(false) setIsScrollVisible(false) InitSpinnerRenderer() quickType.setReplaceMenu(false) quickType.setInputModeOrder(arrayOf(""123"")) quickType.setFocus(true) quickType.setRTL(false) quickType.setAlignment(LEFT) quickType.setConstraint(java.awt.TextField.NUMERIC) setIgnoreFocusComponentWhenUnfocused(true) setRenderingPrototype(model.getItemAt(model.getSize() - 1)) if (getRenderer() is DateTimeRenderer) { quickType.setColumns(2) } }"	Creates a new spinner instance with the given spinner model
"fun start() { paused = false log.info(""Starting text-only user interface..."") log.info(""Local address: "" + system.getLocalAddress()) log.info(""Press Ctrl + C to exit"") Thread(null).start() }"	Starts the interface .
fun encodeBase64(binaryData: ByteArray?): ByteArray? { return org.apache.commons.codec.binary.Base64.encodeBase64(binaryData) }	Encodes binary data using the base64 algorithm but does not chunk the output .
"fun previousNode(): Int { if (!m_cacheNodes) throw RuntimeException( com.sun.org.apache.xalan.internal.res.XSLMessages.createXPATHMessage( com.sun.org.apache.xpath.internal.res.XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null ) ) return if (m_next - 1 > 0) { m_next-- this.elementAt(m_next) } else com.sun.org.apache.xml.internal.dtm.DTM.NULL }"	Returns the previous node in the set and moves the position of the iterator backwards in the set .
"@Synchronized fun decrease(bitmap: Bitmap?) { val bitmapSize: Int = BitmapUtil.getSizeInBytes(bitmap) Preconditions.checkArgument(mCount > 0, ""No bitmaps registered."") Preconditions.checkArgument( bitmapSize <= mSize, ""Bitmap size bigger than the total registered size: %d, %d"", bitmapSize, mSize ) mSize -= bitmapSize mCount-- }"	Excludes given bitmap from the count .
"fun addExcludedName(name: String) { val obj: Any = lookupQualifiedName(scope, name) require(obj is Scriptable) { ""Object for excluded name $name not found."" } table.put(obj, name) }"	Adds a qualified name to the list of objects to be excluded from serialization . Names excluded from serialization are looked up in the new scope and replaced upon deserialization .
fun normalizeExcitatoryFanIn() { var sum = 0.0 var str = 0.0 run { var i = 0 val n: Int = fanIn.size() while (i < n) { str = fanIn.get(i).getStrength() if (str > 0) { sum += str } i++ } } var s: Synapse? = null var i = 0 val n: Int = fanIn.size() while (i < n) { s = fanIn.get(i) str = s.getStrength() if (str > 0) { s.setStrength(s.getStrength() / sum) } i++ } }	"Normalizes the excitatory synaptic strengths impinging on this neuron , that is finds the sum of the exctiatory weights and divides each weight value by that sum ;"
"@MethodDesc(=description = ""Configure properties by either rereading them or setting all properties from outside."",usage = ""configure <properties>"") @Throws( Exception::class)fun configure(@ParamDesc(name = ""tp"",description = ""Optional properties to replace replicator.properties"") tp: TungstenProperties?) {handleEventSynchronous(ConfigureEvent(tp)) }"	Local wrapper of configure to help with unit testing .
fun isArrayIndex(): Boolean { return true }	Return true if variable is an array
@Throws(Exception::class) fun runSafely(stack: Catbert.FastStack?): Any? { return sun.net.NetworkClient.getConnectedClients() }	Returns a list of all the clients that are currently connected to this server .
"fun Debug(filename: String?) { this(filename, 1000000, 1) }"	"logs the output to the specified file ( and stdout ) . Size is 1,000,000 bytes and 1 file ."
"private fun createKeywordDisplayName(keyword: TaxonKeyword?): String? { var combined: String? = null if (keyword != null) { val scientificName: String = com.sun.tools.javac.util.StringUtils.trimToNull(keyword.getScientificName()) val commonName: String = com.sun.tools.javac.util.StringUtils.trimToNull(keyword.getCommonName()) if (scientificName != null && commonName != null) { combined = ""$scientificName ($commonName)"" } else if (scientificName != null) { combined = scientificName } else if (commonName != null) { combined = commonName } } return combined }"	Construct display name from TaxonKeyword 's scientific name and common name properties . It will look like : scientific name ( common name ) provided both properties are not null .
"fun w(tag: String?, msg: String?) { w(tag, msg, null) }"	Prints a message at WARN priority .
"fun BehaviorEvent(facesContext: FacesContext?, component: UIComponent?, behavior: Behavior?) { super(facesContext, component) requireNotNull(behavior) { ""Behavior agrument cannot be null"" } behavior = behavior }"	"< p class= '' changed_added_2_3 '' > Construct a new event object from the Faces context , specified source component and behavior. < /p >"
"fun intdiv(left: Number?, right: Char): Number? { return intdiv(left, Integer.valueOf(right.code).toChar()) }"	Integer Divide a Number by a Character . The ordinal value of the Character is used in the division ( the ordinal value is the unicode value which for simple character sets is the ASCII value ) .
"fun SQLDataException(reason: String?, cause: Throwable?) { super(reason, cause) }"	Creates an SQLDataException object . The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object .
fun isSetHeader(): Boolean { return this.header != null }	Returns true if field header is set ( has been assigned a value ) and false otherwise
"fun increment(key: Float): Boolean { return adjustValue(key, 1) }"	Increments the primitive value mapped to key by 1
fun finish(): Boolean { if (!started) return false var ok = true started = false try { out.write(0x3b) out.flush() if (closeStream) { out.close() } } catch (e: IOException) { ok = false } transIndex = 0 out = null image = null pixels = null indexedPixels = null colorTab = null closeStream = false firstFrame = true return ok }	"Flushes any pending data and closes output file . If writing to an OutputStream , the stream is not closed ."
"fun initializeDefinition(tableName: String, isUnique: Boolean) { m_table = tableName m_isUnique = isUnique s_logger.log(Level.FINEST, toString()) }"	initialize detailed definitions forindex
"private fun concatHeirTokens(stn: com.sun.org.apache.xalan.internal.xsltc.compiler.SyntaxTreeNode): String { val heirs: Array<com.sun.org.apache.xalan.internal.xsltc.compiler.SyntaxTreeNode> = stn.getHeirs() if (heirs.size == 0) { return if (stn.getKind() < SyntaxTreeConstants.NULL_ID) { stn.getImage() } else { """" } } var `val` = """" for (i in heirs.indices) { `val` = `val` + concatHeirTokens(heirs[i]) } return `val` }"	Returns the concatenation of the images of all leaf nodes of the node stn that correspond to actual tokens
"fun jjtAccept(visitor: ParserVisitor, data: Any?): Any? { return visitor.visit(this, data) }"	Accept the visitor .
"fun createImageThumbnail(filePath: String, kind: Int): Bitmap? { val wantMini = kind == Images.Thumbnails.MINI_KIND val targetSize: Int = If (wantMini) TARGET_SIZE_MINI_THUMBNAIL else TARGET_SIZE_MICRO_THUMBNAIL val maxPixels: Int = if (wantMini) MAX_NUM_PIXELS_THUMBNAIL else MAX_NUM_PIXELS_MICRO_THUMBNAIL val sizedThumbnailBitmap = SizedThumbnailBitmap() var bitmap: Bitmap? = null val fileType: MediaFileType = MediaFile.getFileType(filePath) if (fileType != null && fileType.fileType === MediaFile.FILE_TYPE_JPEG) { createThumbnailFromEXIF(filePath, targetSize, maxPixels, sizedThumbnailBitmap) bitmap = sizedThumbnailBitmap.mBitmap } if (bitmap == null) { var stream: FileInputStream? = null try { stream = FileInputStream(filePath) val fd: FileDescriptor = stream.getFD() val options = BitmapFactory.Options() options.inSampleSize = 1 options.inJustDecodeBounds = true BitmapFactory.decodeFileDescriptor(fd, null, options) if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) { return null } options.inSampleSize = computeSampleSize(options, targetSize, maxPixels) options.inJustDecodeBounds = false options.inDither = false options.inPreferredConfig = Bitmap.Config.ARGB_8888 bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options) } catch (ex: IOException) { Log.e(TAG, """", ex) } catch (oom: OutOfMemoryError) { Log.e(TAG, ""Unable to decode file $filePath. OutOfMemoryError."", oom) } finally { try { if (stream != null) { stream.close() } } catch (ex: IOException) { Log.e(TAG, """", ex) } } } if (kind == Images.Thumbnails.MICRO_KIND) { bitmap = extractThumbnail( bitmap, TARGET_SIZE_MICRO_THUMBNAIL, TARGET_SIZE_MICRO_THUMBNAIL, OPTIONS_RECYCLE_INPUT ) } return bitmap }"	"This method first examines if the thumbnail embedded in EXIF is bigger than our target size . If not , then it 'll create a thumbnail from original image . Due to efficiency consideration , we want to let MediaThumbRequest avoid calling this method twice for both kinds , so it only requests for MICRO_KIND and set saveImage to true . This method always returns a `` square thumbnail '' for MICRO_KIND thumbnail ."
"fun <T : Annotation?> checkAnnotationPresent( annotatedType: AnnotatedElement?, annotationClass: Class<T>? ): T { return getAnnotation(annotatedType, annotationClass) }"	"Check if the annotation is present and if not throws an exception , this is just an overload for more clear naming ."
"fun store(o: Any): Element? { val p: PortalIcon = o as PortalIcon if (!p.isActive()) { return null } val element = Element(""PortalIcon"") storeCommonAttributes(p, element) element.setAttribute(""scale"", String.valueOf(p.getScale())) element.setAttribute(""rotate"", String.valueOf(p.getDegrees())) val portal: Portal = p.getPortal() if (portal == null) { log.info(""PortalIcon has no associated Portal."") return null } element.setAttribute(""portalName"", portal.getName()) if (portal.getToBlock() != null) { element.setAttribute(""toBlockName"", portal.getToBlockName()) } if (portal.getFromBlockName() != null) { element.setAttribute(""fromBlockName"", portal.getFromBlockName()) } element.setAttribute(""arrowSwitch"", """" + if (p.getArrowSwitch()) ""yes"" else ""no"") element.setAttribute(""arrowHide"", """" + if (p.getArrowHide()) ""yes"" else ""no"") element.setAttribute( ""class"", ""jmri.jmrit.display.controlPanelEditor.configurexml.PortalIconXml"" ) return element }"	Default implementation for storing the contents of a PortalIcon
fun __rxor__(rhs: Any?): Address? { return Address(m_value.xor(getBigInteger(rhs))) }	Used to support reverse XOR operations on addresses in Python scripts .
"fun SimpleUser( username: String?, userIdentifiers: Collection<String?>?, connectionIdentifiers: Collection<String?>?, connectionGroupIdentifiers: Collection<String?>? ) { this(username) addReadPermissions(userPermissions, userIdentifiers) addReadPermissions(connectionPermissions, connectionIdentifiers) addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers) }"	"Creates a new SimpleUser having the given username and READ access to the users , connections , and groups having the given identifiers ."
public void startDocument ( ) throws org . xml . sax . SAXException { }	"Receive notification of the beginning of a document . < p > The SAX parser will invoke this method only once , before any other methods in this interface or in DTDHandler ( except for setDocumentLocator ) . < /p >"
"protected fun AbstractIntSpliterator(est: Long, additionalCharacteristics: Int) { est = est this.characteristics = if (additionalCharacteristics and Spliterator.SIZED !== 0) additionalCharacteristics or Spliterator.SUBSIZED else additionalCharacteristics }"	Creates a spliterator reporting the given estimated size and characteristics .
private fun preAnalyzeMethods(): Set<DefUseCoverageTestFitness>? { val r: MutableSet<DefUseCoverageTestFitness> = HashSet<DefUseCoverageTestFitness>() val toAnalyze: LinkedList<ClassCallNode> = LinkedList<ClassCallNode>() toAnalyze.addAll(getInitialPreAnalyzeableMethods()) while (!toAnalyze.isEmpty()) { val currentMethod: ClassCallNode = toAnalyze.poll() val analyzeableEntry: CCFGMethodEntryNode = ccfg.getMethodEntryNodeForClassCallNode(currentMethod) if (analyzedMethods.contains(analyzeableEntry)) continue r.addAll(determineIntraInterMethodPairs(analyzeableEntry)) val parents: Set<ClassCallNode> = ccfg.getCcg().getParents(currentMethod) for (parent in parents) { if (toAnalyze.contains(parent)) continue if (analyzedMethods.contains(ccfg.getMethodEntryNodeForClassCallNode(parent))) continue val parentsChildren: Set<ClassCallNode> = ccfg.getCcg().getChildren(parent) var canAnalyzeNow = true for (parentsChild in parentsChildren) { if (parentsChild == null) continue if (!parentsChild.equals(parent) && !(toAnalyze.contains(parentsChild) || analyzedMethods.contains( ccfg.getMethodEntryNodeForClassCallNode(parentsChild) )) ) { canAnalyzeNow = false break } } if (canAnalyzeNow) { toAnalyze.offer(parent) } } } return r }	Checks if there are methods in the CCG that dont call any other methods except for maybe itself . For these we can predetermine free uses and activeDefs prior to looking for inter_method_pairs . After that we can even repeat this process for methods we now have determined free uses and activeDefs ! that way you can save a lot of computation . Map activeDefs and freeUses according to the variable so you can easily determine which defs will be active and which uses are free once you encounter a methodCall to that method without looking at its part of the CCFG
fun createSimpleProjectDescription(): SimpleProjectDescription? { return SimpleProjectDescriptionImpl() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun writeAll() { for (row in 0 until _numRows) { writeState.get(row) = WRITE } issueNextOperation() }	Start writing all rows out
"fun str(): String? { return if (m_obj != null) m_obj.toString() else """" }"	Cast result object to a string .
"fun checkThreadIDAllow0(uid: Int): Int { var uid = uid if (uid == 0) { uid = currentThread.uid } if (!threadMap.containsKey(uid)) { log.warn(String.format(""checkThreadID not found thread 0x%08X"", uid)) throw SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD) } if (!SceUidManager.checkUidPurpose(uid, ""ThreadMan-thread"", true)) { throw SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD) } return uid }"	Check the validity of the thread UID . Allow uid=0 .
fun isPowerOfThreeB(n: Int): Boolean { return n > 0 && maxPow3 % n === 0 }	Find the max power of 3 within int range . It should be divisible by all power of 3s .
"protected fun addDefinitionRef(defRef: Element) { val ref: String = defRef.getAttributeNS(null, XBL_REF_ATTRIBUTE) val e: Element = ctx.getReferencedElement(defRef, ref) if (!XBL_NAMESPACE_URI.equals(e.getNamespaceURI()) || !XBL_DEFINITION_TAG.equals(e.getLocalName())) { throw BridgeException(ctx, defRef, ErrorConstants.ERR_URI_BAD_TARGET, arrayOf<Any>(ref)) } val ir = ImportRecord(defRef, e) imports.put(defRef, ir) val et: NodeEventTarget = defRef as NodeEventTarget et.addEventListenerNS( XMLConstants.XML_EVENTS_NAMESPACE_URI, ""DOMAttrModified"", refAttrListener, false, null ) val d: XBLOMDefinitionElement = defRef as XBLOMDefinitionElement val ns: String = d.getElementNamespaceURI() val ln: String = d.getElementLocalName() addDefinition(ns, ln, e as XBLOMDefinitionElement, defRef) }"	Adds a definition through its referring definition element ( one with a 'ref ' attribute ) .
"fun ActiveMQRATopicSubscriber(consumer: TopicSubscriber, session: ActiveMQRASession) { super(consumer, session) if (ActiveMQRATopicSubscriber.trace) { ActiveMQRALogger.LOGGER.trace(""constructor($consumer, $session)"") } }"	Create a new wrapper
"private fun fieldInsn(opcode: Int, ownerType: Type, name: String, fieldType: Type) { mv.visitFieldInsn(opcode, ownerType.getInternalName(), name, fieldType.getDescriptor()) }"	Generates a get field or set field instruction .
"fun doFrame(frameTimeNanos: Long) { if (isPaused.get()) { return } val frameTimeMillis = frameTimeNanos / 1000000 var timersToCall: WritableArray? = null synchronized(mTimerGuard) { while (!mTimers.isEmpty() && mTimers.peek().mTargetTime < frameTimeMillis) { val timer: Timer = mTimers.poll() if (timersToCall == null) { timersToCall = Arguments.createArray() } timersToCall.pushInt(timer.mCallbackID) if (timer.mRepeat) { timer.mTargetTime = frameTimeMillis + timer.mInterval mTimers.add(timer) } else { mTimerIdsToTimers.remove(timer.mCallbackID) } } } if (timersToCall != null) { org.graalvm.compiler.debug.Assertions.assertNotNull(mJSTimersModule) .callTimers(timersToCall) } org.graalvm.compiler.debug.Assertions.assertNotNull(mReactChoreographer) .postFrameCallback(ReactChoreographer.CallbackType.TIMERS_EVENTS, this) }"	Calls all timers that have expired since the last time this frame callback was called .
"protected fun executeLogoutCommand() { shoppingCartCommandFactory.execute( ShoppingCartCommand.CMD_LOGIN, cartMixin.getCurrentCart(), object : HashMap<String?, Any?>() { init { javax.swing.UIManager.put( ShoppingCartCommand.CMD_LOGOUT, ShoppingCartCommand.CMD_LOGOUT ) } }) }"	Execute logout command .
fun equals(obj: Any): Boolean { if (obj === this) { return true } if (obj is CharSet == false) { return false } val other: CharSet = obj as CharSet return set.equals(other.set) }	"< p > Compares two CharSet objects , returning true if they represent exactly the same set of characters defined in the same way. < /p > < p > The two sets < code > abc < /code > and < code > a-c < /code > are < i > not < /i > equal according to this method. < /p >"
private fun PlatformUtils() {}	Creates a new PlatformUtils object .
"@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED) @Throws(APPlatformException::class) fun deleteInstance(instanceId: String?, settings: ProvisioningSettings): InstanceStatus? { val paramHandler = PropertyHandler(settings) paramHandler.setState(Status.DELETION_REQUESTED) val result = InstanceStatus() result.setChangedParameters(settings.getParameters()) return result }"	"Starts the deletion of an application instance . < p > The internal status < code > DELETION_REQUESTED < /code > is stored as a controller configuration setting . It is evaluated and handled by the status dispatcher , which is invoked at regular intervals by APP through the < code > getInstanceStatus < /code > method ."
"fun isOnline(): Boolean { val oo: Any = get_Value(COLUMNNAME_IsOnline) return if (oo != null) { if (oo is Boolean) oo.toBoolean() else ""Y"" == oo } else false }"	Get Online Access .
"fun EditSensorsAction(visionWorld: VisionWorld?) { super(""Edit selected sensor(s)..."") requireNotNull(visionWorld) { ""visionWorld must not be null"" } visionWorld = visionWorld visionWorld.getSensorSelectionModel().addSensorSelectionListener(SelectionListener()) }"	Create a new edit sensors action .
"fun replace(key: K?, value: V?): V? { var hash: Long var allocIndex: Long var segment: javax.swing.text.Segment<K?, V?> val oldValue: V if (segment(segmentIndex(keyHashCode(key).also { hash = it })).also { segment = it } .find(this, hash, key).also { allocIndex = it } > 0) { oldValue = segment.readValue(allocIndex) segment.writeValue(allocIndex, value) return oldValue } return null }"	Replaces the entry for the specified key only if it is currently mapped to some value .
fun user(): UserResource? { return user }	Get the subresource containing all of the commands related to a tenant 's users .
"private fun isExportable(step: Step): Boolean { return Exporter::class.java.getResource( String.format( ""/edu/wpi/grip/ui/codegeneration/%s/operations/%s.vm"", lang.filePath, step.getOperationDescription().name().replace(' ', '_') ) ) != null }"	Checks if a step is exportable to this exporter 's language .
"fun view(array: LongArray?, length: Int): List<Long?>? { return LongList(array, length) }"	Creates and returns a view of the given long array that requires only a small object allocation .
"fun insert(index: Int, o: Any): MutableString { return insert(index, o.toString()) }"	"Inserts the string representation of an object in this mutable string , starting from index < code > index < /code > ."
"fun checkAttributeValuesChanged( param: BlockVirtualPoolUpdateParam, vpool: VirtualPool ): Boolean { return super.checkAttributeValuesChanged( param, vpool ) || checkPathParameterModified(vpool.getNumPaths(), param.getMaxPaths() ) || checkPathParameterModified( vpool.getMinPaths(), param.getMinPaths() ) || checkPathParameterModified( vpool.getPathsPerInitiator(), param.getPathsPerInitiator() ) || checkPathParameterModified( vpool.getHostIOLimitBandwidth(), param.getHostIOLimitBandwidth() ) || checkPathParameterModified( vpool.getHostIOLimitIOPs(), param.getHostIOLimitIOPs() ) || VirtualPoolUtil.checkRaidLevelsChanged( vpool.getArrayInfo(), param.getRaidLevelChanges() ) || VirtualPoolUtil.checkForVirtualPoolAttributeModification( vpool.getDriveType(), param.getDriveType() ) || VirtualPoolUtil.checkThinVolumePreAllocationChanged( vpool.getThinVolumePreAllocationPercentage(), param.getThinVolumePreAllocationPercentage() ) || VirtualPoolUtil.checkProtectionChanged( vpool, param.getProtection() ) || VirtualPoolUtil.checkHighAvailabilityChanged(vpool, param.getHighAvailability()) }"	Check if any VirtualPool attribute values have changed .
"fun visitIntersection_Intersection( type1: AnnotatedIntersectionType, type2: AnnotatedIntersectionType, visited: VisitHistory ): Boolean? { if (!arePrimeAnnosEqual(type1, type2)) { return false } visited.add(type1, type2) return areAllEqual(type1.directSuperTypes(), type2.directSuperTypes(), visited) }"	//TODO : SHOULD PRIMARY ANNOTATIONS OVERRIDE INDIVIDUAL BOUND ANNOTATIONS ? //TODO : IF SO THEN WE SHOULD REMOVE THE arePrimeAnnosEqual AND FIX AnnotatedIntersectionType Two intersection types are equal if : 1 ) Their sets of primary annotations are equal 2 ) Their sets of bounds ( the types being intersected ) are equal
"@Throws(IOException::class) fun writeEnum(fieldNumber: Int, value: Int) { writeTag(fieldNumber, WireFormat.WIRETYPE_VARINT) writeEnumNoTag(value) }"	"Write an enum field , including tag , to the stream . Caller is responsible for converting the enum value to its numeric value ."
"@Throws(CRLException::class) fun X509CRLImpl(inStrm: InputStream?) { try { parse(sun.security.util.DerValue(inStrm)) } catch (e: IOException) { signedCRL = null throw CRLException(""Parsing error: "" + e.getMessage()) } }"	Unmarshals an X.509 CRL from an input stream . Only one CRL is expected at the end of the input stream .
"protected fun removeTurntable(o: LayoutTurntable): Boolean { if (!noWarnTurntable) { val selectedValue: Int = javax.swing.JOptionPane.showOptionDialog( this, rb.getString(""Question4r""), Bundle.getMessage(""WarningTitle""), javax.swing.JOptionPane.YES_NO_CANCEL_OPTION, javax.swing.JOptionPane.QUESTION_MESSAGE, null, arrayOf<Any>( Bundle.getMessage(""ButtonYes""), Bundle.getMessage(""ButtonNo""), rb.getString(""ButtonYesPlus"") ), Bundle.getMessage(""ButtonNo"") ) if (selectedValue == 1) { return false } if (selectedValue == 2) { noWarnTurntable = true } } if (selectedObject === o) { selectedObject = null } if (prevSelectedObject === o) { prevSelectedObject = null } for (j in 0 until o.getNumberRays()) { val t: TrackSegment = o.getRayConnectOrdered(j) if (t != null) { substituteAnchor(o.getRayCoordsIndexed(j), o, t) } } for (i in 0 until turntableList.size()) { val lx: LayoutTurntable = turntableList.get(i) if (lx === o) { turntableList.remove(i) o.remove() setDirty(true) repaint() return true } } return false }"	Remove a Layout Turntable
"@Throws(javax.swing.text.BadLocationException::class, IOException::class) protected fun emptyTag(elem: Element) { if (!inContent && !inPre) { indentSmart() } val attr: AttributeSet = elem.getAttributes() closeOutUnwantedEmbeddedTags(attr) writeEmbeddedTags(attr) if (matchNameAttribute(attr, javax.swing.text.html.HTML.Tag.CONTENT)) { inContent = true text(elem) } else if (matchNameAttribute(attr, javax.swing.text.html.HTML.Tag.COMMENT)) { comment(elem) } else { val isBlock: Boolean = isBlockTag(elem.getAttributes()) if (inContent && isBlock) { writeLineSeparator() indentSmart() } val nameTag: Any? = if (attr != null) attr.getAttribute(javax.swing.text.StyleConstants.NameAttribute) else null val endTag: Any? = if (attr != null) attr.getAttribute(javax.swing.text.html.HTML.Attribute.ENDTAG) else null var outputEndTag = false if (nameTag != null && endTag != null && endTag is String && endTag == ""true"") { outputEndTag = true } if (completeDoc && matchNameAttribute(attr, javax.swing.text.html.HTML.Tag.HEAD)) { if (outputEndTag) { writeStyles((getDocument() as HTMLDocument).getStyleSheet()) } wroteHead = true } write('<') if (outputEndTag) { write('/') } write(elem.getName()) writeAttributes(attr) write('>') if (matchNameAttribute(attr, javax.swing.text.html.HTML.Tag.TITLE) && !outputEndTag) { val doc: Document = elem.getDocument() val title = doc.getProperty(Document.TitleProperty) as String write(title) } else if (!inContent || isBlock) { writeLineSeparator() if (isBlock && inContent) { indentSmart() } } } }"	Writes out all empty elements ( all tags that have no corresponding end tag ) .
fun isPending(): Boolean { return getConfidence().getConfidenceType() === TransactionConfidence.ConfidenceType.PENDING }	Convenience wrapper around getConfidence ( ) .getConfidenceType ( )
"fun fireSensorMatrixChanged(oldSensorMatrix: SensorMatrix?, sensorMatrix: SensorMatrix?) { requireNotNull(oldSensorMatrix) { ""oldSensorMatrix must not be null"" } requireNotNull(sensorMatrix) { ""sensorMatrix must not be null"" } val listeners: Array<Any> = listenerList.getListenerList() var event: VisionWorldModelEvent? = null var i = listeners.size - 2 while (i >= 0) { if (listeners[i] === VisionWorldModelListener::class.java) { if (event == null) { event = VisionWorldModelEvent(source, oldSensorMatrix, sensorMatrix) } (listeners[i + 1] as VisionWorldModelListener).sensorMatrixChanged(event) } i -= 2 } }"	Fire a sensor matrix changed event to all registered vision world model listeners .
"fun DNameConstraints(parent: javax.swing.JDialog?) { super(parent) setTitle(res.getString(""DNameConstraints.Title"")) initComponents() }"	Creates a new DNameConstraints dialog .
fun visit(v: jdk.nashorn.internal.ir.visitor.NodeVisitor) { v.visit(this) }	Visits this node . There are no children .
fun LDC(x: Int) { env.topFrame().operandStack.pushBv32(ExpressionFactory.buildNewIntegerConstant(x)) }	"Bytecode instruction stream : ... ,0x12 , index , ... < p > Push corresponding symbolic constant from constant pool ( at index ) onto the operand stack . http : //java.sun.com/docs/books/jvms/second_edition/html/Instructions2 . doc8.html # ldc"
"private fun filter_regexp(unfilteredTrie: Trie?): SentenceFilteredTrie? { var trie: SentenceFilteredTrie? = nullif (unfilteredTrie.hasRules()) if (matchesSentence(unfilteredTrie))trie =SentenceFilteredTrie(unfilteredTrie) else return nullif (unfilteredTrie.hasExtensions()) for ((key, unfilteredChildTrie): Map.Entry<Int,Trie?> in unfilteredTrie.getChildren().entrySet()) {val nextTrie: SentenceFilteredTrie? = filter_regexp(unfilteredChildTrie)if (nextTrie != null) {if (trie == null) trie= SentenceFilteredTrie(unfilteredTrie)trie.children.put(key, nextTrie)}}return trie}"	"Alternate filter that uses regular expressions , walking the grammar trie and matching the source side of each rule collection against the input sentence . Failed matches are discarded , and trie nodes extending from that position need not be explored ."
protected fun engineUpdate(input: Byte) { if (first === true) {md.update(k_ipad) first = false }md.update(input)}	Processes the given byte .
"fun configureZone(zone: StendhalRPZone?, attributes: Map<String?, String?>?) { buildAdosGreetingSoldier(zone) }"	Configure a zone .
"@Throws(sun.security.krb5.Asn1Exception::class, IOException::class) fun parse(data: sun.security.util.DerInputStream,explicitTag: Byte,optional: Boolean): sun.security.krb5.internal.KerberosTime? {if (optional && data.peekByte().toByte() and 0x1F.toByte() !=explicitTag.toInt()) return null val der: sun.security.util.DerValue = data.getDerValue()return if (explicitTag.toInt() != der.getTag() and 0x1F.toByte()) { throw sun.security.krb5.Asn1Exception(sun.security.krb5.internal.Krb5.ASN1_BAD_ID) } else { val subDer: sun.security.util.DerValue = der.getData().getDerValue() val temp: Date = subDer.getGeneralizedTime() sun.security.krb5.internal.KerberosTime(temp.time, 0) } }"	Parse ( unmarshal ) a kerberostime from a DER input stream . This form parsing might be used when expanding a value which is part of a constructed sequence and uses explicitly tagged type .
"@DSGenerator( tool_name = ""Doppelganger"",tool_version = ""2.0"",generated_on = ""2013-12-30 13:02:38.770-0500"",hash_original_method = ""C464D16A28A9DCABA3B0B8FD02F52155"",hash_generated_method =""0A183B7841054C14E915336FD1A0DC9E"") fun hasExtension(extension: String?): Boolean {return if (extension == null ||extension.isEmpty()) {false} else extensionToMimeTypeMap.containsKey(extension) }"	Returns true if the given extension has a registered MIME type .
"@Throws(Exception::class) fun testExhaustContentSource() {val algLines = arrayOf(""# ----- properties"",""content.source=org.apache.lucene.benchmark.byTask.feeds.SingleDocSource"",""content.source.log.step=1"",""doc.term.vector=false"",""content.source.forever=false"",""directory=RAMDirectory"",""doc.stored=false"",""doc.tokenized=false"",""# ----- alg "",""CreateIndex"",""{ AddDoc } : * "",""ForceMerge(1)"",""CloseIndex"",""OpenReader"",""{ CountingSearchTest } : 100"",""CloseReader"",""[ CountingSearchTest > : 30"",""[ CountingSearchTest > : 9"")CountingSearchTestTask.numSearches = 0val benchmark: Benchmark = execBenchmark(algLines)assertEquals(""TestSearchTask was supposed to be called!"",139,CountingSearchTestTask.numSearches)assertTrue(""Index does not exist?...!"",DirectoryReader.indexExists(benchmark.getRunData().getDirectory())) val iw = IndexWriter(benchmark.getRunData().getDirectory(),IndexWriterConfig(MockAnalyzer(random())).setOpenMode(OpenMode.APP))iw.close()val ir: IndexReader = DirectoryReader.open(benchmark.getRunData().getDirectory())assertEquals(""1 docs were added to the index, this is what we expect to find!"",1,ir.numDocs())ir.close()}"	Test Exhasting Doc Maker logic
"@DSSource([DSSourceKind.NETWORK]) @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name = ""Doppelganger"",tool_version = ""2.0"",generated_on = ""2014-02-25 10:38:10.723 -0500"",hash_original_method = ""8EB7107FA2367D701AF7CBC234A81F19"",hash_generated_method = ""B23ED7B4CA5FBA5E6343C71EA6EDB1E4"") override fun toString(): String? {val header = StringBuffer()header.append(""From: "")header.append(__from)header.append(""\nNewsgroups: "")header.append(__newsgroups.toString())header.append(""\nSubject: "")header.append(__subject)header.append('\n')if (__headerFields.length() > 0) header.append(__headerFields.toString())header.append('\n')return header.toString()}"	"Converts the SimpleNNTPHeader to a properly formatted header in the form of a String , including the blank line used to separate the header from the article body . < p >"
private fun sincronizarBase() { listaOrganizacao = ControleDAO.getBanco().getOrganizacaoDAO().listar() }	Sincronizar dados com banco de dados
protected fun newlines(text: CharArray): Int { var result = 0 for (i in text.indices) { if (text[i] == 10) { result++ } } return result }	Returns the number of newlines in the given char array .
protected fun toBitmap(source: LuminanceSource?): BinaryBitmap? { return BinaryBitmap(HybridBinarizer(source)) }	"Given an image source , convert to a binary bitmap . Override this to use a custom binarizer ."
"protected fun handleMergeException(dir: Directory?, exc: Throwable?) { throw MergeException(exc, dir) }"	Called when an exception is hit in a background merge thread
"fun merge(factory: FactoryDto, computedProjectConfig: ProjectConfigDto): FactoryDto? { val projects: List<ProjectConfigDto> = factory.getWorkspace().getProjects() if (projects == null || projects.isEmpty()) { factory.getWorkspace().setProjects(listOf(computedProjectConfig)) return factory } if (projects.size == 1) { val projectConfig: ProjectConfigDto = projects[0] if (projectConfig.getSource() == null) projectConfig.setSource(computedProjectConfig.getSource()) } return factory }"	Apply the merging of project config dto including source storage dto into the existing factory < p > here are the following rules < ul > < li > no projects -- > add whole project < /li > < li > if projects < ul > < li > : if there is only one project : add source if missing < /li > < li > if many projects : do nothing < /li > < /ul > < /li > < /ul >
"@Throws(ParseException::class) fun parseSIPStatusLine(statusLine: String?): StatusLine? { var statusLine = statusLine statusLine += ""\n"" return StatusLineParser(statusLine).parse() }"	Parse the SIP Response message status line
"fun initQuitAction(quitAction: QuitAction?) { requireNotNull(quitAction) { ""quitAction is null"" } require(quitAction == null) { ""The method is once-call."" } quitAction = quitAction }"	Set the action to call from quit ( ) .
"fun isFileStoragePool(storagePool: StoragePool, dbClient: DbClient): Boolean { val storageSystemUri: URI = storagePool.getStorageDevice() val storageSystem: StorageSystem = dbClient.queryObject(StorageSystem::class.java, storageSystemUri) ArgValidator.checkEntity(storageSystem, storageSystemUri, false) val storageSystemType: StorageSystem.Type = StorageSystem.Type.valueOf(storageSystem.getSystemType()) return storageSystemType.equals(StorageSystem.Type.isilon) || storageSystemType.equals( StorageSystem.Type.vnxfile ) }"	Finds if a pool is file storage pool
"fun invokeStatic( clazz: String?, methodName: String?, types: Array<Class<*>?>?, values: Array<Any?>?, defaultValue: Any? ): Any? { return try { invokeStatic(Class.forName(clazz), methodName, types, values) } catch (e: ClassNotFoundException) { defaultValue } catch (e: NoSuchMethodException) { defaultValue } }"	Invokes the specified parameterless method if it exists .
"@Throws(IllegalArgumentException::class) fun internalsprintf(s: Double): String? { var s2: String? = """" when (conversionCharacter) { 'f' -> s2 = printFFormat(s) 'E', 'e' -> s2 = printEFormat(s) 'G', 'g' -> s2 = printGFormat(s) else -> throw IllegalArgumentException(""Cannot format a double with a format using a $conversionCharacter conversion character."") } return s2 }"	Format a double argument using this conversion specification .
"fun eInverseRemove( otherEnd: InternalEObject?, featureID: Int, msgs: NotificationChain? ): NotificationChain? { when (featureID) { N4mfPackage.MODULE_FILTER__MODULE_SPECIFIERS -> return (getModuleSpecifiers() as InternalEList<*>).basicRemove( otherEnd, msgs ) } return super.eInverseRemove(otherEnd, featureID, msgs) }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun hasUiObjectExpression(): Boolean { return !com.sun.tools.javac.util.StringUtils.isEmpty(getUiObjectExpression) }	"If this databinding reference an ui element that is not the widget bound to this binding , then an expression is used to retrieve the target ui element"
fun restore() { try { if (inCurrentStorage) currentStorage.insertElementSafe(element) else currentStorage.removeElement( element ) if (inApiStorage) apiStorage.insertElementSafe(element) else apiStorage.removeElement( element ) } catch (e: StorageException) { e.printStackTrace() } element.osmId = osmId element.osmVersion = osmVersion element.state = state element.setTags(tags) if (parentRelations != null) { element.parentRelations = ArrayList<Relation>() element.parentRelations.addAll(parentRelations) } else { element.parentRelations = null } }	Restores the saved state of the element
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:36:00.382 -0500"", hash_original_method = ""A7CC818E7F384DAEC54D76069E9C5019"", hash_generated_method ""E8FCEBA0D995DB6EE22CA1B5390C8697"" ) @Throws( IOException::class ) protected fun available(): Int { return getInputStream().available() }"	Returns the number of bytes available for reading without blocking .
fun isOverwriteMode(): Boolean { return hexEditControl == null || hexEditControl.isOverwriteMode() }	Tells whether the input is in overwrite or insert mode
"fun loadStrings(filename: String): Array<String?>? { val `is`: InputStream = createInput(filename) if (`is` != null) return loadStrings(`is`) System.err.println(""The file \""$filename\"" is missing or inaccessible, make sure the URL is valid or that the file has been added to your sketch and is readable."") return null }"	"Load data from a file and shove it into a String array . < p/ > Exceptions are handled internally , when an error , occurs , an exception is printed to the console and 'null ' is returned , but the program continues running . This is a tradeoff between 1 ) showing the user that there was a problem but 2 ) not requiring that all i/o code is contained in try/catch blocks , for the sake of new users ( or people who are just trying to get things done in a `` scripting '' fashion . If you want to handle exceptions , use Java methods for I/O ."
"private fun fieldsWithAnnotation(cls: Class<*>): Iterable<Field?>? { synchronized(mux) { var fields: MutableList<Field?>? = fieldCache.get(cls) if (fields == null) { fields = ArrayList() for (field in cls.declaredFields) { val ann: Annotation = field.getAnnotation(annCls) if (ann != null || needsRecursion(field)) fields!!.add(field) } if (!fields!!.isEmpty()) fieldCache.put(cls, fields) } return fields } }"	Gets all entries from the specified class or its super-classes that have been annotated with annotation provided .
"@Throws(Exception::class) fun mapRelations( `object`: jdk.internal.loader.Resource, jsonObject: JSONObject, included: List<jdk.internal.loader.Resource?>? ): jdk.internal.loader.Resource? { val relationshipNames: HashMap<String, String> = getRelationshipNames(`object`.javaClass) for (relationship in relationshipNames.keySet()) { var relationJsonObject: JSONObject? = null relationJsonObject = try { jsonObject.getJSONObject(relationship) } catch (e: JSONException) { Logger.debug(""Relationship named "" + relationship + ""not found in JSON"") continue } var relationDataObject: JSONObject? = null try { relationDataObject = relationJsonObject.getJSONObject(""data"") var relationObject: jdk.internal.loader.Resource? = Factory.newObjectFromJSONObject(relationDataObject, null) relationObject = matchIncludedToRelation(relationObject, included) mDeserializer.setField(`object`, relationshipNames[relationship], relationObject) } catch (e: JSONException) { Logger.debug(""JSON relationship does not contain data"") } var relationDataArray: JSONArray? = null try { relationDataArray = relationJsonObject.getJSONArray(""data"") var relationArray: List<jdk.internal.loader.Resource?>? = Factory.newObjectFromJSONArray(relationDataArray, null) relationArray = matchIncludedToRelation(relationArray, included) mDeserializer.setField(`object`, relationshipNames[relationship], relationArray) } catch (e: JSONException) { Logger.debug(""JSON relationship does not contain data"") } } return `object` }"	Loops through relation JSON array and maps annotated objects .
override fun onDestroyView() { mIsWebViewAvailable = false super.onDestroyView() }	Called when the WebView has been detached from the fragment . The WebView is no longer available after this time .
fun clearMovementData() {pathSprites = ArrayList<StepSprite>() movementTarget = null checkFoVHexImageCacheClear() repaint() refreshMoveVectors() }	Clears current movement data from the screen
"@Throws(Exception::class) fun execute( mapping: ActionMapping, form: ActionForm, request: HttpServletRequest, response: HttpServletResponse): ActionForward? { val editRoomDeptForm: EditRoomDeptForm = form as EditRoomDeptForm val rsc: MessageResources = getResources(request) val doit: String = editRoomDeptForm.getDoit() if (doit != null) { if (doit == rsc.getMessage(""button.update"")) { var errors = ActionMessages() errors = editRoomDeptForm.validate(mapping, request) if (errors.size() === 0) { doUpdate(editRoomDeptForm, request) return mapping.findForward(""showRoomDetail"") } else { saveErrors(request, errors) } } if (doit == rsc.getMessage(""button.returnToRoomDetail"")) { response.sendRedirect(""roomDetail.do?id="" + editRoomDeptForm.getId()) return null } if (doit == rsc.getMessage(""button.addRoomDept"")) { if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept() .length() === 0 ) { val errors = ActionMessages() errors.add(""roomDept"", ActionMessage(""errors.required"", ""Department"")) saveErrors(request, errors) } else if (editRoomDeptForm.getDepartmentIds() .contains(editRoomDeptForm.getDept()) ) { val errors = ActionMessages() errors.add(""roomDept"", ActionMessage(""errors.alreadyPresent"", ""Department"")) saveErrors(request, errors) } else { editRoomDeptForm.addDepartment(editRoomDeptForm.getDept()) } } if (doit == rsc.getMessage(""button.removeRoomDept"")) { if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept() .length() === 0 ) { val errors = ActionMessages() errors.add(""roomDept"", ActionMessage(""errors.required"", ""Department"")) saveErrors(request, errors) } else if (!editRoomDeptForm.getDepartmentIds() .contains(editRoomDeptForm.getDept()) ) { val errors = ActionMessages() errors.add(""roomDept"", ActionMessage(""errors.notPresent"", ""Department"")) saveErrors(request, errors) } else { editRoomDeptForm.removeDepartment(editRoomDeptForm.getDept()) } } } val id: Long = java.lang.Long.valueOf(request.getParameter(""id"")) val ldao = LocationDAO()  val location: Location = ldao.get(id) sessionContext.checkPermission(location, Right.RoomEditAvailability) if (doit != null && doit == rsc.getMessage(""button.modifyRoomDepts"")) { val roomDepts = TreeSet(location.getRoomDepts()) val i: Iterator<*> = roomDepts.iterator() while (i.hasNext()) { val roomDept: RoomDept = i.next() as RoomDept editRoomDeptForm.addDepartment(roomDept.getDepartment().getUniqueId().toString()) } } val timeVertical: Boolean = CommonValues.VerticalGrid.eq(UserProperty.GridOrientation.get(sessionContext.getUser())) val rtt: RequiredTimeTable = location.getRoomSharingTable( sessionContext.getUser(), editRoomDeptForm.getDepartmentIds() ) rtt.getModel().setDefaultSelection(UserProperty.GridSize.get(sessionContext.getUser())) if (doit != null && (doit == rsc.getMessage(""button.removeRoomDept"") || doit == rsc.getMessage( ""button.addRoomDept"" )) ) { rtt.update(request) } editRoomDeptForm.setSharingTable(rtt.print(true, timeVertical)) if (location is Room) { val r: Room = location as Room editRoomDeptForm.setName(r.getLabel()) editRoomDeptForm.setNonUniv(false) } else if (location is NonUniversityLocation) { val nonUnivLocation: NonUniversityLocation = location as NonUniversityLocation editRoomDeptForm.setName(nonUnivLocation.getName()) editRoomDeptForm.setNonUniv(true) } else { val errors = ActionMessages() errors.add(""editRoomDept"", ActionMessage(""errors.lookup.notFound"", ""Room Department"")) saveErrors(request, errors) } setupDepartments(editRoomDeptForm, request, location) return mapping.findForward(""showEditRoomDept"") }"	Method execute
"fun execute(timeSeries: MetricTimeSeries, functionValueMap: FunctionValueMap) { if (timeSeries.isEmpty()) { functionValueMap.add(this, false, null) return } val points: DoubleList = timeSeries.getValues() val q1: Double = Percentile.evaluate(points, .25) val q3: Double = Percentile.evaluate(points, .75) val threshold = (q3 - q1) * 1.5 + q3 for (i in 0 until points.size()) { val point: Double = points.get(i) if (point > threshold) { functionValueMap.add(this, true, null) return } } functionValueMap.add(this, false, null) }"	Detects outliers using the default box plot implementation . An outlier every value that is above ( q3-q1 ) *1.5*q3 where qN is the nth percentile
fun DuplicatePrimaryPartitionException(message: String?) { super(message) }	Creates a new < code > DuplicatePrimaryPartitionException < /code > with the given detail message .
fun buildFieldTypes(tableDef: TableDefinition) { (tableDef as JPAMTableDefinition).buildFieldTypes(getSession()) }	INTERNAL : builds the field names based on the type read in from the builder
fun clearCache() { softCache = SoftReference<Array<String>>(null) }	Clear the cache . This method is used for testing .
fun clear() { oredCriteria.clear() orderByClause = null distinct = false }	This method was generated by MyBatis Generator . This method corresponds to the database table activity
protected fun remove(id: Int) { nodes.remove(id) }	Removes the node with the specified identifier from this problem instance .
fun addHaptic(id: Int) { mHapticFeedback.add(id) }	Adds haptic feedback to this utterance .
"private fun init() { val grid = Grid() appendChild(grid) grid.setWidth(""100%"") grid.setStyle(""margin:0; padding:0; position: absolute;"") grid.makeNoStrip() grid.setOddRowSclass(""even"") val rows: jdk.internal.joptsimple.internal.Rows = jdk.internal.joptsimple.internal.Rows() grid.appendChild(rows) for (i in 0 until m_goals.length) { val row = Row() rows.appendChild(row) row.setWidth(""100%"") val pi = WPerformanceIndicator(m_goals.get(i)) row.appendChild(pi) pi.addEventListener(Events.ON_CLICK, this) } }"	Static/Dynamic Init
fun deleteBack(): Int { val oldBack: Int = getBack() size = size - 1 return oldBack }	Deletes item from back of the list and returns deleted item .
fun isLicensed(): Boolean { return resourceExists(thresholdFileResource) && resourceExists(overlappingFileResource) }	This method returns true if the threshold and overlap files are present .
protected fun SimplePhase(name: String?) { super(name) }	Construct a phase given just a name and a global/local ordering scheme .
private fun URIUtil() {}	Prevent instance creation .
"@Synchronized fun processResponse( transactionResponse: SIPResponse, sourceChannel: MessageChannel?, dialog: SIPDialog ) { if (getState() == null) return if ((TransactionState.COMPLETED === this.getState() || TransactionState.TERMINATED === this.getState()) && transactionResponse.getStatusCode() / 100 === 1) { return } if (sipStack.isLoggingEnabled()) { sipStack.getStackLogger().logDebug( ""processing "" + transactionResponse.getFirstLine() .toString() + ""current state = "" + getState() ) sipStack.getStackLogger().logDebug(""dialog = $dialog"") } this.lastResponse = transactionResponse try { if (isInviteTransaction()) inviteClientTransaction( transactionResponse, sourceChannel, dialog ) else nonInviteClientTransaction(transactionResponse, sourceChannel, dialog) } catch (ex: IOException) { if (sipStack.isLoggingEnabled()) sipStack.getStackLogger().logException(ex) this.setState(TransactionState.TERMINATED) raiseErrorEvent(SIPTransactionErrorEvent.TRANSPORT_ERROR) } }"	"Process a new response message through this transaction . If necessary , this message will also be passed onto the TU ."
"fun disable(adapter: BluetoothAdapter) { var mask: Int = BluetoothReceiver.STATE_TURNING_OFF_FLAG or BluetoothReceiver.STATE_OFF_FLAG or BluetoothReceiver.SCAN_MODE_NONE_FLAG var start: Long = -1 val receiver: BluetoothReceiver = getBluetoothReceiver(mask) var state = adapter.state when (state) { BluetoothAdapter.STATE_OFF -> { assertFalse(adapter.isEnabled) removeReceiver(receiver) return } BluetoothAdapter.STATE_TURNING_ON -> { assertFalse(adapter.isEnabled) start = System.currentTimeMillis() } BluetoothAdapter.STATE_ON -> { assertTrue(adapter.isEnabled) start = System.currentTimeMillis() assertTrue(adapter.disable()) } BluetoothAdapter.STATE_TURNING_OFF -> { assertFalse(adapter.isEnabled) mask = 0 } else -> { removeReceiver(receiver) fail(String.format(""disable() invalid state: state=%d"", state)) } } val s = System.currentTimeMillis() while (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) { state = adapter.state if (state == BluetoothAdapter.STATE_OFF && receiver.getFiredFlags() and mask === mask) { assertFalse(adapter.isEnabled) val finish: Long = receiver.getCompletedTime() if (start != -1L && finish != -1L) { writeOutput(String.format(""disable() completed in %d ms"", finish - start)) } else { writeOutput(""disable() completed"") } removeReceiver(receiver) return } sleep(POLL_TIME) } val firedFlags: Int = receiver.getFiredFlags() removeReceiver(receiver) fail( String.format( ""disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)"", state, BluetoothAdapter.STATE_OFF, firedFlags, mask ) ) }"	Disables Bluetooth and checks to make sure that Bluetooth was turned off and that the correct actions were broadcast .
fun isLocal(): Boolean { return local }	Indicates if the ejb referenced is a local ejb .
"fun PowerDecay() { this(10, 0.5) }"	Creates a new Power Decay rate
fun isStorageIORMSupported(): Boolean? { return storageIORMSupported }	Gets the value of the storageIORMSupported property .
fun array(): ByteArray { return array }	Returns the underlying byte array .
"@Throws(Exception::class) fun buildClassifier(D: Instances) { val r = Random(m_seed) if (fastaram) { networks = arrayOfNulls<ARAMNetworkfast>(numberofnetworks) } else if (sparsearam) { networks = arrayOfNulls<ARAMNetworkSparse>(numberofnetworks) } else if (sparsearamH) { networks = arrayOfNulls<ARAMNetworkSparseV>(numberofnetworks) } else if (sparsearamHT) { networks = arrayOfNulls<ARAMNetworkSparseHT>(numberofnetworks) } else { networks = arrayOfNulls<ARAMNetwork>(numberofnetworks) } numClasses = D.classIndex() if (tfastaram) { val bc: Array<BuildClassifier?> = arrayOfNulls<BuildClassifier>(numberofnetworks) for (i in 0 until numberofnetworks) { val list: MutableList<Int?> = ArrayList() for (j in 0 until D.numInstances()) { list.add(j) } Collections.shuffle(list, r) if (fastaram) { networks.get(i) = ARAMNetworkfast() } else if (sparsearam) { networks.get(i) = ARAMNetworkSparse() } else if (sparsearamH) { networks.get(i) = ARAMNetworkSparseV() } else if (sparsearamHT) { networks.get(i) = ARAMNetworkSparseHT() } else { networks.get(i) = ARAMNetwork() } networks.get(i).order = list networks.get(i).roa = roa bc[i] = BuildClassifier(networks.get(i)) bc[i].setinstances(D) bc[i].start() } for (i in 0 until numberofnetworks) { bc[i].join() networks.get(i) = bc[i].m_network networks.get(i).learningphase = false } } else { for (i in 0 until numberofnetworks) { if (fastaram) { networks.get(i) = ARAMNetworkfast() } else if (sparsearam) { networks.get(i) = ARAMNetworkSparse() } else if (sparsearamH) { networks.get(i) = ARAMNetworkSparseV() } else if (sparsearamHT) { networks.get(i) = ARAMNetworkSparseHT() } else { networks.get(i) = ARAMNetwork() } networks.get(i).roa = roa networks.get(i).buildClassifier(D) networks.get(i).learningphase = false D.randomize(r) } } dc = arrayOfNulls<DistributionCalc>(numberofnetworks) }"	Generates the classifier .
"private fun startCameraSource() { val code: Int = GoogleApiAvailability.getInstance() .isGooglePlayServicesAvailable(ApplicationProvider.getApplicationContext()) if (code != ConnectionResult.SUCCESS) { val dlg: Dialog = GoogleApiAvailability.getInstance().getErrorDialog(this, code, RC_HANDLE_GMS) dlg.show() } if (mCameraSource != null) { try { mPreview.start(mCameraSource, mGraphicOverlay) } catch (e: IOException) { Log.e(TAG, ""Unable to start camera source."", e) mCameraSource.release() mCameraSource = null } } }"	"Starts or restarts the camera source , if it exists . If the camera source does n't exist yet ( e.g. , because onResume was called before the camera source was created ) , this will be called again when the camera source is created ."
"fun Timezone(text: String?) { this(null, text) }"	Creates a timezone property .
"fun <K, V> putAt(self: MutableMap<K, V>, key: K, value: V): V { self[key] = value return value }"	A helper method to allow maps to work with subscript operators
"override fun toString(): String? { return toString("","") }"	Form a string listing all elements with comma as the separator character .
"@DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2014-09-03 14:59:51.857 -0400"", hash_original_method = ""8DBE36D3CC23C0C9E5FAAD9804EB9F8E"", hash_generated_method = ""B8E268DF01A1D59287B8F2ED5303EAE7"" ) @Throws( IOException::class ) private fun processInput(endOfInput: Boolean) { decoderIn.flip() var coderResult: CoderResult while (true) { coderResult = decoder.decode(decoderIn, decoderOut, endOfInput) if (coderResult.isOverflow()) { flushOutput() } else if (coderResult.isUnderflow()) { break } else { throw IOException(""Unexpected coder result"") } } decoderIn.compact() }"	Decode the contents of the input ByteBuffer into a CharBuffer .
fun byte52ToFloat(b: Byte): Float { if (b.toInt() == 0) return 0.0f var bits: Int = b and 0xff shl 24 - 5 bits += 63 - 2 shl 24 return java.lang.Float.intBitsToFloat(bits) }	"byteToFloat ( b , mantissaBits=5 , zeroExponent=2 )"
"private fun createAndRegisterObserverProxyLocked(observer: IContentObserver) { check(mObserver == null) { ""an observer is already registered"" } mObserver = ContentObserverProxy(observer, this) mCursor.registerContentObserver(mObserver) }"	Create a ContentObserver from the observer and register it as an observer on the underlying cursor .
"fun compressEstim(src: ByteArray?, srcOff: Int, srcLen: Int): Int { var srcOff = srcOff if (srcLen < 10) return srcLen var stride: Int = LZ4_64K_LIMIT - 1 val segments = (srcLen + stride - 1) / stride stride = srcLen / segments if (stride >= LZ4_64K_LIMIT - 1 || stride * segments > srcLen || segments < 1 || stride < 1) throw RuntimeException( ""?? $srcLen"" ) var bytesIn = 0 var bytesOut = 0 var len = srcLen while (len > 0) { if (len > stride) len = stride bytesOut += compress64k(src, srcOff, len) srcOff += len bytesIn += len len = srcLen - bytesIn } val ratio = bytesOut / bytesIn.toDouble() return if (bytesIn == srcLen) bytesOut else (ratio * srcLen + 0.5).toInt() }"	"Estimates the length of the compressed bytes , as compressed by Lz4 WARNING : if larger than LZ4_64K_LIMIT it cuts it in fragments WARNING : if some part of the input is discarded , this should return the proportional ( so that returnValue/srcLen=compressionRatio )"
fun eIsSet(featureID: Int): Boolean { when (featureID) { N4JSPackage.ARRAY_LITERAL__ELEMENTS -> return elements != null && !elements.isEmpty() N4JSPackage.ARRAY_LITERAL__TRAILING_COMMA -> return trailingComma !== TRAILING_COMMA_EDEFAULT } return super.eIsSet(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun FilterStreamSpecRaw() {}	Default ctor .
fun onMenuVisibilityChanged(isVisible: Boolean) { for (i in 0 until mObservers.size()) { mObservers.get(i).onMenuVisibilityChanged(isVisible) } }	Called by AppMenu to report that the App Menu visibility has changed .
fun updateDownload() { val ongoingDownloads: ArrayList<DownloadInfoRunnable> = getOngoingDownloads() if (!ongoingDownloads.isEmpty()) { updateProgress() } else { timer.cancel() timer.purge() stopSelf() mBuilder = null stopForeground(true) isStopped = true } }	"Updates the download list and stops the service if it 's empty . If not , updates the progress in the Notification bar"
"private fun remoteAddPois(pois: List<Poi>, changeSetId: String): Int { var count = 0 for (poi in pois) { if (remoteAddPoi(poi, changeSetId)) { count++ } } return count }"	Add a List of POIs to the backend .
fun CopyOnWriteArraySet(c: Collection<E?>?) { al = CopyOnWriteArrayList<E>() al.addAllAbsent(c) }	Creates a set containing all of the elements of the specified collection .
@Throws(SQLException::class) fun close() { try { super.close() } finally { this.outputLogger.close() } }	This method will close the connection to the output .
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:55:41.688 -0500"", hash_original_method = ""1623111994CBCA0890DA0FF2A1E140E0"", hash_generated_method =  ""478ACA79A313929F4EF55B9242DEEF4D"" ) fun isBackToBackUserAgent(): Boolean { return super.isBackToBackUserAgent }"	Get the `` back to back User Agent '' flag . return the value of the flag
"fun EnglishMinimalStemFilterFactory(args: Map<String?, String?>) { super(args) require(args.isEmpty()) { ""Unknown parameters: $args"" } }"	Creates a new EnglishMinimalStemFilterFactory
"fun AABB(pos: ReadonlyVec3D?, extent: Float) { super(pos) setExtent(Vec3D(extent, extent, extent)) }"	Creates a new instance from centre point and uniform extent in all directions .
fun <T> subscriber(): JavaslangSubscriber<T>? { return JavaslangSubscriber<T>() }	A reactive-streams subscriber than can generate Javaslang traversable types
"fun SQLNonTransientException(reason: String?, cause: Throwable?) { super(reason, cause) }"	Creates an SQLNonTransientException object . The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object .
fun localTransactionCommitted(event: ConnectionEvent?) {}	Ignored event callback
"protected fun runAndReset(): Boolean { if (state !== NEW || !UNSAFE.compareAndSwapObject( this, runnerOffset, null,Thread.currentThread()  ) ) return false var ran = false var s: Int = state try { val c: Callable<V> = callable if (c != null && s == NEW) { try { c.call() ran = true } catch (ex: Throwable) { setException(ex) } } } finally { runner = null s = state if (s >= INTERRUPTING) handlePossibleCancellationInterrupt(s) } return ran && s == NEW }"	"Executes the computation without setting its result , and then resets this future to initial state , failing to do so if the computation encounters an exception or is cancelled . This is designed for use with tasks that intrinsically execute more than once ."
fun addCookie(cookie: GoogleCookie?) { if (cookieManager != null) { cookieManager.addCookie(cookie) } }	Adds a new GoogleCookie instance to the cache .
"fun debug(trace: String?) { printTrace(trace, DEBUG_LEVEL) }"	Debug trace
fun isAutoIndentEnabled(): Boolean { return autoIndentEnabled }	Returns whether or not auto-indent is enabled .
"fun disableHardwareLayersForContent() { val widget: View = org.jcp.xml.dsig.internal.dom.DOMKeyInfo.getContent() if (widget != null) { widget.setLayerType(LAYER_TYPE_NONE, null) } }"	"Because this view has fading outlines , it is essential that we enable hardware layers on the content ( child ) so that updating the alpha of the outlines does n't result in the content layer being recreated ."
"@Throws(ParseException::class) fun parseDateLong(dateString: String?, pattern: String?): Date? { return getSimplDateFormat(pattern).parse(dateString) }"	Construct payment gateway descriptor .
"@Throws(ParseException::class) fun parseDateLong(dateString: String?, pattern: String?): Date? { return getSimplDateFormat(pattern).parse(dateString) }"	Returns date parsed from string by given pattern
"fun add(i: Int, coord: Coordinate?, allowRepeated: Boolean) { if (!allowRepeated) { val size: Int = size() if (size > 0) { if (i > 0) { val prev: Coordinate = get(i - 1) as Coordinate if (prev.equals2D(coord)) return } if (i < size) { val next: Coordinate = get(i) as Coordinate if (next.equals2D(coord)) return } } } super.add(i, coord) }"	Inserts the specified coordinate at the specified position in this list .
"private fun loadAppThemeDefaults() { val typedValue = TypedValue() val a = context!!.obtainStyledAttributes( typedValue.data, intArrayOf(attr.colorAccent, attr.textColorPrimary, attr.colorControlNormal) ) dialColor = a.getColor(0, dialColor) textColor = a.getColor(1, textColor) clockColor = a.getColor(2, clockColor) a.recycle() }"	Sets default theme attributes for picker These will be used if picker 's attributes are'nt set
fun increaseRefcount() { refcount++ }	Increase number of data points by one .
"fun computePolygonAreaFromVertices(points: Iterable<Vec4?>?): Double { if (points == null) { val message: String = Logging.getMessage(""nullValue.IterableIsNull"") Logging.logger().severe(message) throw IllegalArgumentException(message) } val iter: Iterator<Vec4?> = points.iterator() if (!iter.hasNext()) { return 0 } var area = 0.0 val firstPoint: Vec4? = iter.next() var point: Vec4? = firstPoint while (iter.hasNext()) { val nextLocation: Vec4? = iter.next() area += point.x * nextLocation.y area -= nextLocation.x * point.y point = nextLocation } if (!point.equals(firstPoint)) { area += point.x * firstPoint.y area -= firstPoint.x * point.y } area /= 2.0 return area }"	"Returns the area enclosed by the specified ( x , y ) points ( the z and w coordinates are ignored ) . If the specified points do not define a closed loop , then the loop is automatically closed by simulating appending the first point to the last point ."
fun init(param: KeyGenerationParameters) { this.params = param as NTRUEncryptionKeyGenerationParameters }	Constructs a new instance with a set of encryption parameters .
"fun createDemoPanel(): javax.swing.JPanel? { val chart: JFreeChart = createChart(createDataset()) val panel = ChartPanel(chart, false) panel.setFillZoomRectangle(true) panel.setMouseWheelEnabled(true) return panel }"	Creates a panel for the demo ( used by SuperDemo.java ) .
"@Throws(Throwable::class) fun deleteVMsOnThisEndpoint( host: VerificationHost?, isMock: Boolean, parentComputeLink: String?, instanceIdsToDelete: List<String?>? ) { deleteVMsOnThisEndpoint(host, null, isMock, parentComputeLink, instanceIdsToDelete, null) }"	A utility method that deletes the VMs on the specified endpoint filtered by the instanceIds that are passed in .
fun isIn(i: Byte): Boolean { return i >= this.min && i <= this.max }	Check if given number is in range .
"fun completeAll() { val currentCompleted: Long = completedCount val size = Math.max(1, actionList.size()) while (completedCount - currentCompleted < size) { if (getState() !== Thread.State.BLOCKED && getState() !== Thread.State.RUNNABLE) break try { Thread.sleep(50) } catch (ex: InterruptedException) { break } } }"	"< p > Complete all scheduled actions at the time of this call . Since other threads may keep adding actions , this method makes sure that only the actions in the queue at the time of the call are waited upon . < /p >"
override fun toString(): String? { return image }	Returns the image .
fun KtVisualPanel1() { initComponents() }	Creates new form KtVisualPanel1
"@Throws(MalformedURIException::class) fun URI(p_scheme: String?, p_schemeSpecificPart: String?) { if (p_scheme == null || p_scheme.trim { it <= ' ' }.length == 0) { throw MalformedURIException(""Cannot construct URI with null/empty scheme!"") } if (p_schemeSpecificPart == null || p_schemeSpecificPart.trim { it <= ' ' }.length == 0) { throw MalformedURIException(""Cannot construct URI with null/empty scheme-specific part!"") } setScheme(p_scheme) setPath(p_schemeSpecificPart) }"	Construct a new URI that does not follow the generic URI syntax . Only the scheme and scheme-specific part ( stored as the path ) are initialized .
fun isDoingRangedAttack(): Boolean { return isDoingRangedAttack }	Check if the currently performed attack is ranged .
"@Throws(IOException::class) fun SdfReaderWrapper(sdfDir: File?, useMem: Boolean, checkConsistency: Boolean) { mIsPaired = jdk.internal.org.jline.reader.impl.ReaderUtils.isPairedEndDirectory(sdfDir) if (mIsPaired) { mSingle = null mLeft = createSequencesReader( jdk.internal.org.jline.reader.impl.ReaderUtils.getLeftEnd(sdfDir), useMem ) mRight = createSequencesReader( jdk.internal.org.jline.reader.impl.ReaderUtils.getRightEnd(sdfDir), useMem ) if (checkConsistency) { if (mLeft.numberSequences() !== mRight.numberSequences() || !mLeft.type() .equals(mRight.type()) || mLeft.hasQualityData() !== mRight.hasQualityData() || mLeft.hasNames() !== mRight.hasNames() ) { throw NoTalkbackSlimException( ErrorType.INFO_ERROR, ""Paired end SDF has inconsistencies between arms."" ) } } } else { mLeft = null mRight = null mSingle = createSequencesReader(sdfDir, useMem) } }"	Wrapper for the readers .
fun DefaultRenderStack() { stack = ArrayDeque() }	Constructs the stack .
"fun onLocationChanged(location: Location?) { if (location == null) { return } val distance: Float = getDistanceFromNetwork(location) mTrackerData.writeEntry(location, distance) }"	"Writes details of location update to tracking file , including recording the distance between this location update and the last network location update"
"fun secondaryIndexFileName(data: File): File? { val extensionIndex: Int = data.getName().lastIndexOf('.') return if (extensionIndex != -1) { File( data.getParentFile(), data.getName().substring(0, extensionIndex) + BamIndexer.BAM_INDEX_EXTENSION ) } else indexFileName(data) }"	Get the secondary possible name for an index to have for a given data file ( Will return same as indexFileName if there is no file extension )
"@Throws(IOException::class) private fun cancelOrder(contract: Contract, order: TradeOrder) { val orderState = OrderState() orderState.m_status = OrderStatus.CANCELLED this.brokerModel.openOrder(order.getOrderKey(), contract, order, orderState) order.setStatus(OrderStatus.CANCELLED) }"	Method cancelOrder .
"private fun TempTripleStore(store: TemporaryStore, properties: Properties) { this(store, UUID.randomUUID().toString() + ""kb"", ITx.UNISOLATED, properties) }"	Note : This is here just to make it easy to have the reference to the [ store ] and its [ uuid ] when we create one in the calling ctor .
"fun <T> newSameSize(list: List<*>?, cpType: Class<T>?): Array<T>? { return if (list == null) create(cpType, 0) else create(cpType, list.size) }"	"Creates an array with the same size as the given list . If the list is null , a zero-length array is created ."
fun addPaintListener(pl: PaintListener?) { if (m_painters == null) { m_painters = CopyOnWriteArrayList() } m_painters.add(pl) }	Add a PaintListener to this Display to receive notifications about paint events .
fun isNamed(): Boolean { return flags and NO_NAME === 0 }	Returns true if this method is anonymous .
"fun CopyOnWriteMap() { internalMap = HashMap<K, V>() }"	Creates a new instance of CopyOnWriteMap .
"fun runTrialParallel( size: Int,set: TrialSuite,pts: Array<IPoint>,selector: IPivotIndex?,numThreads: Int,ratio: Int) {val ar = arrayOfNulls<Int>(size) run { var i = 0 var idx = 0 while (i < pts.size) { ar[idx++] = (pts[i].getX() * BASE) as Int ar[idx++] = (pts[i].getY() * BASE) as Int i++ } } val qs: MultiThreadQuickSort<Int> = MultiThreadQuickSort<Int>(ar) qs.setPivotMethod(selector) qs.setNumberHelperThreads(numThreads) qs.setThresholdRatio(ratio) System.gc() val start = System.currentTimeMillis() qs.qsort(0, size - 1) val end = System.currentTimeMillis() set.addTrial(size, start, end) for (i in 0 until ar.size - 1) { assert(ar[i]!! <= ar[i + 1]!!) } }"	Change the number of helper threads inside to try different configurations . < p > Set to NUM_THREADS by default .
"private fun initResumableMediaRequest( request: GDataRequest, file: MediaFileSource, title: String ) { initMediaRequest(request, title) request.setHeader(GDataProtocol.Header.X_UPLOAD_CONTENT_TYPE, file.getContentType()) request.setHeader( GDataProtocol.Header.X_UPLOAD_CONTENT_LENGTH, file.getContentLength().toString() ) }"	Initialize a resumable media upload request .
fun toShortArray(array: Array<Short>): ShortArray? { val result = ShortArray(array.size) for (i in array.indices) { result[i] = array[i] } return result }	Coverts given shorts array to array of shorts .
"fun createTable(db: SQLiteDatabase, ifNotExists: Boolean) { val constraint = if (ifNotExists) ""IF NOT EXISTS "" else """" db.execSQL(""CREATE TABLE $constraint'SIMPLE_ADDRESS_ITEM' ('_id' INTEGER PRIMARY KEY ,'NAME' TEXT,'ADDRESS' TEXT,'CITY' TEXT,'STATE' TEXT,'PHONE' INTEGER);"") }"	Creates the underlying database table .
"fun eInverseRemove(otherEnd: InternalEObject?,featureID: Int,msgs: NotificationChain?): NotificationChain? {when (featureID) { UmplePackage.ABSTRACT_METHOD_DECLARATION___METHOD_DECLARATOR_1 -> return (getMethodDeclarator_1() as InternalEList<*>).basicRemove( otherEnd, msgs ) } return super.eInverseRemove(otherEnd, featureID, msgs) }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"protected fun emit_N4SetterDeclaration_SemicolonKeyword_5_q( semanticObject: EObject?, transition: ISynNavigable?, nodes: List<INode?>? ) { acceptNodes(transition, nodes) }"	Ambiguous syntax : ' ; ' ? This ambiguous syntax occurs at : body=Block ( ambiguity ) ( rule end ) fpar=FormalParameter ' ) ' ( ambiguity ) ( rule end )
"private fun updateProgress(progressLabel: String, progress: Int) { if (myHost != null && (progress != previousProgress || progressLabel != previousProgressLabel)) { myHost.updateProgress(progressLabel, progress) } previousProgress = progress previousProgressLabel = progressLabel }"	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
"@Throws(FitsException::class) fun FitsDate(dStr: String?) { if (dStr == null || dStr.isEmpty()) { return } var match: Matcher = FitsDate.NORMAL_REGEX.matcher(dStr) if (match.matches()) { this.year = getInt(match, FitsDate.NEW_FORMAT_YEAR_GROUP) this.month = getInt(match, FitsDate.NEW_FORMAT_MONTH_GROUP) this.mday = getInt(match, FitsDate.NEW_FORMAT_DAY_OF_MONTH_GROUP) this.hour = getInt(match, FitsDate.NEW_FORMAT_HOUR_GROUP) this.minute = getInt(match, FitsDate.NEW_FORMAT_MINUTE_GROUP) this.second = getInt(match, FitsDate.NEW_FORMAT_SECOND_GROUP) this.millisecond = jdk.nashorn.internal.objects.NativeDate.getMilliseconds( match, FitsDate.NEW_FORMAT_MILLISECOND_GROUP ) } else { match = FitsDate.OLD_REGEX.matcher(dStr) if (match.matches()) { this.year = getInt(match, FitsDate.OLD_FORMAT_YEAR_GROUP) + FitsDate.YEAR_OFFSET this.month = getInt(match, FitsDate.OLD_FORMAT_MONTH_GROUP) this.mday = getInt(match, FitsDate.OLD_FORMAT_DAY_OF_MONTH_GROUP) } else { if (dStr.trim { it <= ' ' }.isEmpty()) { return } throw FitsException(""Bad FITS date string \""$dStr\"""") } } }"	Convert a FITS date string to a Java < CODE > Date < /CODE > object .
"fun <T> fromBytes(value: ByteArray?, clazz: Class<T>): T { return try { val input = Input(ByteArrayInputStream(value)) clazz.cast(kryo.get().readClassAndObject(input)) } catch (t: Throwable) { LOG.error(""Unable to deserialize because "" + t.message, t) throw t } }"	Deserialize a profile measurement 's value . The value produced by a Profile definition can be any numeric data type . The data type depends on how the profile is defined by the user . The user should be able to choose the data type that is most suitable for their use case .
"fun SequencesWriter( source: SequenceDataSource?, outputDir: File?, sizeLimit: Long, type: PrereadType?, compressed: Boolean ) { this(source, outputDir, sizeLimit, null, type, compressed, null) }"	Creates a writer for processing sequences from provided data source .
fun allowStyling(): HtmlPolicyBuilder? { allowStyling(CssSchema.DEFAULT) return this }	"Convert < code > style= '' & lt ; CSS & gt ; '' < /code > to sanitized CSS which allows color , font-size , type-face , and other styling using the default schema ; but which does not allow content to escape its clipping context ."
"private fun PhoneUtil() { throw Error(""Do not need instantiate!"") }"	Do n't let anyone instantiate this class .
fun unregisterTap(tap: Tap?) { mTaps.remove(tap) }	Remove instrumentation tap
fun isNavBarTintEnabled(): Boolean { return mNavBarTintEnabled }	Is tinting enabled for the system navigation bar ?
"override fun equals(other: Any?): Boolean { return if (_map.equals(other)) { true } else if (other is Map<*, *>) { val that = other if (that.size != _map.size()) { false } else { val it: Iterator<*> = that.entries.iterator() var i = that.size while (i-- > 0) { val (key1, value) = it.next() as Map.Entry<*, *> val key = key1!! val `val` = value!! if (key is Float) { val k: Float = unwrapKey(key) val v: Any = unwrapValue(`val` as V) if (_map.containsKey(k) && v === _map.get(k)) { } else { return false } } else { return false } } true } } else { false } }"	Compares this map with another map for equality of their stored entries .
private fun declareExtensions() { BlogCommentFeed().declareExtensions(extProfile) BlogFeed().declareExtensions(extProfile) BlogPostFeed().declareExtensions(extProfile) PostCommentFeed().declareExtensions(extProfile) }	Declare the extensions of the feeds for the Blogger service .
fun eIsSet(featureID: Int): Boolean { when (featureID) { UmplePackage.ANONYMOUS_GEN_EXPR_2__INDEX_1 -> return if (INDEX_1_EDEFAULT == null) index_1 != null else !INDEX_1_EDEFAULT.equals( index_1 ) } return super.eIsSet(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun sequence(name: String?): ReferenceSequence? { return mReferences.get(name) }	Get the < code > ReferenceSequence < /code > selected by name .
"private fun ChainBuilder(frame: javax.swing.JFrame) { super(java.awt.BorderLayout()) frame = frame THIS = this val customPanel: javax.swing.JPanel = createCustomizationPanel() val presetPanel: javax.swing.JPanel = createPresetPanel() label = javax.swing.JLabel( ""Click the \""Begin Generating\"" button"" + "" to begin generating phrases"", javax.swing.JLabel.CENTER ) val padding: javax.swing.border.Border = javax.swing.BorderFactory.createEmptyBorder(20, 20, 5, 20) customPanel.setBorder(padding) presetPanel.setBorder(padding) val tabbedPane: javax.swing.JTabbedPane = javax.swing.JTabbedPane() tabbedPane.addTab(""Build your own"", null, customPanel, customizationPanelDescription) tabbedPane.addTab(""Presets"", null, presetPanel, presetPanelDescription) add(tabbedPane, java.awt.BorderLayout.CENTER) add(label, java.awt.BorderLayout.PAGE_END) label.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10)) }"	Creates the GUI shown inside the frame 's content pane .
override fun toString(): String? { return this.materialPackageBO.toString() }	A method that returns a string representation of a parsed MaterialPackage object
protected fun VirtualBaseTypeImpl() { super() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"private fun removeParserNotices(parser: Parser) { if (noticesToHighlights != null) { val h: RSyntaxTextAreaHighlighter = textArea.getHighlighter() as RSyntaxTextAreaHighlighter val i: MutableIterator<*> = noticesToHighlights.entrySet().iterator() while (i.hasNext()) { val (key, value) = i.next() as Map.Entry<*, *> val notice: ParserNotice = key as ParserNotice if (notice.getParser() === parser && value != null) { h.removeParserHighlight(value) i.remove() } } } }"	Removes all parser notices ( and clears highlights in the editor ) from a particular parser .
"fun TextLineDecoder(charset: Charset?, delimiter: String?) { this(charset, LineDelimiter(delimiter)) }"	Creates a new instance with the spcified < tt > charset < /tt > and the specified < tt > delimiter < /tt > .
"fun resetViewableArea() { throw RuntimeException(""resetViewableArea called in PdfDecoderFx"") }"	"NOT PART OF API turns off the viewable area , scaling the page back to original scaling"
private fun postResults() { this.reportTestCase.host.updateSystemInfo(false) this.trState.systemInfo = this.reportTestCase.host.getSystemInfo() val factoryPost: Operation = Operation.createPost(this.remoteTestResultService) .setReferer(this.reportTestCase.host.getReferer()).setBody(this.trState) .setCompletion(null) this.reportTestCase.host.testStart(1) this.reportTestCase.host.sendRequest(factoryPost) try { this.reportTestCase.host.testWait() } catch (throwable: Throwable) { throwable.printStackTrace() } }	"Send current test state to a remote server , by creating an instance for this particular run ."
fun clear(iterator: MutableIterator<*>) { checkNotNull(iterator) while (iterator.hasNext()) { iterator.next() iterator.remove() } }	Clears the iterator using its remove method .
fun isTop(fact: BitSet): Boolean { return fact[topBit] }	Return whether or not given fact is the special TOP value .
fun eraseMap() { if (MAP_STORE.getMap(MAP_STORE.getSelectedMapName()) == null) { return } for (r in MAP_STORE.getMap(MAP_STORE.getSelectedMapName()).getRoutes()) { eraseRoute(r) } }	Non-destructively erases all displayed content from the map display
"fun doTestTransfer(size: Int) { Thread.setDefaultUncaughtExceptionHandler(this) val start: Long val elapsed: Long val received: Int sendData = createDummyData(size) sendStreamSize = size recvStream = ByteArrayOutputStream(size) start = PseudoTCPBase.now() startClocks() try { connect() } catch (ex: IOException) { fail(ex.getMessage()) } assert_Connected_wait(kConnectTimeoutMs) val transferTout: Long = maxTransferTime(sendData.length, kMinTransferRate) val transfferInTime: Boolean = assert_Disconnected_wait(transferTout) elapsed = PseudoTCPBase.now() - start stopClocks() received = recvStream.size() assertEquals( ""Transfer timeout, transferred: "" + received + "" required: "" + sendData.length + "" elapsed: "" + elapsed + "" limit: "" + transferTout, true, transfferInTime ) assertEquals(size, received) val recvdArray: ByteArray = recvStream.toByteArray() assertArrayEquals(sendData, recvdArray) logger.log( Level.INFO, ""Transferred "" + received + "" bytes in "" + elapsed + "" ms ("" + size * 8 / elapsed + "" Kbps"" ) }"	Transfers the data of < tt > size < /tt > bytes
"protected fun sequence_SkillFakeDefinition( context: ISerializationContext?, semanticObject: SkillFakeDefinition ) { if (errorAcceptor != null) { if (transientValues.isValueTransient( semanticObject, GamlPackage.Literals.GAML_DEFINITION__NAME ) === ValueTransient.YES ) errorAcceptor.accept( diagnosticProvider.createFeatureValueMissing( semanticObject, GamlPackage.Literals.GAML_DEFINITION__NAME ) ) } val feeder: SequenceFeeder = createSequencerFeeder(context, semanticObject) feeder.accept( grammarAccess.getSkillFakeDefinitionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName() ) feeder.finish() }"	Contexts : GamlDefinition returns SkillFakeDefinition SkillFakeDefinition returns SkillFakeDefinition Constraint : name=ID
fun closeDriver() { if (camera != null) { FlashlightManager.disableFlashlight() camera.release() camera = null } }	Closes the camera driver if still in use .
"@Throws(PageException::class) fun removeSecurityManager(password: sun.security.util.Password?, id: String) { checkWriteAccess() (ConfigImpl.getConfigServer(config, password) as ConfigServerImpl).removeSecurityManager(id) val security: Element = _getRootElement(""security"") val children: Array<Element> = XMLConfigWebFactory.getChildren(security, ""accessor"") for (i in children.indices) { if (id == children[i].getAttribute(""id"")) { security.removeChild(children[i]) } } }"	remove security manager matching given id
"fun circle(x: Double, y: Double, r: Double) { require(r >= 0) { ""circle radius must be nonnegative"" } val xs: Double = scaleX(x) val ys: Double = scaleY(y) val ws: Double = factorX(2 * r) val hs: Double = factorY(2 * r) if (ws <= 1 && hs <= 1) pixel( x, y ) else offscreen.draw(java.awt.geom.Ellipse2D.Double(xs - ws / 2, ys - hs / 2, ws, hs)) draw() }"	"Draw a circle of radius r , centered on ( x , y ) ."
"fun run() { amIActive = true val inputFile: String = args.get(0) if (inputFile.lowercase(Locale.getDefault()).contains("".dep"")) { calculateRaster() } else if (inputFile.lowercase(Locale.getDefault()).contains("".shp"")) { calculateVector() } else { showFeedback(""There was a problem reading the input file."") } }"	Used to execute this plugin tool .
"private fun <T> create(cls: Class<T>, qname: QName): T { return Configuration.getBuilderFactory().getBuilder(qname).buildObject(qname) }"	Create object using OpenSAML 's builder system .
fun createHttpConnection(): HttpConnection? { return AndroidHttpConnection() }	Create an HTTP connection
"private fun parseWaveformsFromJsonFile(waveformsFile: File): Map<Int?, FloatArray?>? { var waveformsMap: Map<Int?, FloatArray >? try { waveformsMap = parseJsonFile(waveformsFile) as Map<Int?, FloatArray?>? LOG.info(""Loaded waveform images from {}"", waveformsFile) } catch (exception: IOException) { waveformsMap = HashMap() LOG.error(""Error loading waveform thumbnails: {}"", exception.getMessage(), exception) } return waveformsMap }"	Loads the waveforms from a saved file formatted in JSON
"fun drawShape(gl: GL2?, s: Shape?, points: Boolean) { if (s is Circle) { RenderUtilities.drawCircle(gl, s as Circle?, points, true) } else if (s is java.awt.Rectangle) { RenderUtilities.drawRectangle(gl, s as java.awt.Rectangle?, points) } else if (s is java.awt.Polygon) { RenderUtilities.drawPolygon(gl, s as java.awt.Polygon?, points) } else if (s is javax.swing.text.Segment) { RenderUtilities.drawLineSegment(gl, s as javax.swing.text.Segment?, points) } else { } }"	Draws the given shape .
"@Throws(IOException::class) fun write(writer: Writer) { val map: MutableMap<String, Any> = HashMap() map[""vcards""] = vcards map[""utils""] = TemplateUtils() map[""translucentBg""] = readImage(""translucent-bg.png"", ImageType.PNG) map[""noProfile""] = readImage(""no-profile.png"", ImageType.PNG) map[""ezVCardVersion""] = Ezvcard.VERSION map[""ezVCardUrl""] = Ezvcard.URL map[""scribeIndex""] = ScribeIndex() try { template.process(map, writer) } catch (e: TemplateException) { throw RuntimeException(e) } writer.flush() }"	Writes the HTML document to a writer .
"fun toString(field: String): String? { val buffer = StringBuilder() if (sun.reflect.misc.FieldUtil.getField() != field) { buffer.append(sun.reflect.misc.FieldUtil.getField()) buffer.append("":"") } buffer.append(if (includeLower) '[' else '{') buffer.append( if (lowerTerm != null) if (""*"" == Term.toString(lowerTerm)) ""\\*"" else Term.toString( lowerTerm ) else ""*"" ) buffer.append("" TO "") buffer.append( if (upperTerm != null) if (""*"" == Term.toString(upperTerm)) ""\\*"" else Term.toString( upperTerm ) else ""*"" ) buffer.append(if (includeUpper) ']' else '}') return buffer.toString() }"	Prints a user-readable version of this query .
"@Throws(ReplicatorException::class, InterruptedException::class) fun prepare(context: PluginContext?) { logger.info( ""Import tables from "" + this.uri.getPath() .toString() + "" to the "" + this.getDefaultSchema().toString() + "" schema"" ) tableNames = ArrayList<String>() columnDefinitions = HashMap<String, ArrayList<ColumnSpec>>() parser = CSVParser(',', '""') val importDirectory = File(this.uri.getPath()) if (!importDirectory.exists()) { throw ReplicatorException( ""The "" + this.uri.getPath().toString() + "" directory does not exist"" ) } for (f in importDirectory.listFiles()) { if (f.getName().endsWith("".def"")) { this.prepareTableDefinition(f) } } if (this.tableNames.size() === 0) { throw ReplicatorException(""There are no tables to load"") } }"	Prepare plug-in for use . This method is assumed to allocate all required resources . It is called before the plug-in performs any operations .
"fun plot(draw: AbstractDrawer) { if (!visible) return draw.setColor(color) draw.setFont(font) draw.setBaseOffset(base_offset) draw.setTextOffset(cornerE, cornerN) draw.setTextAngle(angle) draw.drawText(label, coord) draw.setBaseOffset(null) }"	see Text for formatted text output
"fun testShiftRight4() { val aBytes = byteArrayOf(1, -128, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26) val aSign = 1 val number = 45 val rBytes = byteArrayOf(12, 1, -61, 39, -11, -94, -55) val aNumber = BigInteger(aSign, aBytes) val result: BigInteger = aNumber.shiftRight(number) var resBytes = ByteArray(rBytes.size) resBytes = result.toByteArray() for (i in resBytes.indices) { assertTrue(resBytes[i] == rBytes[i]) } assertEquals(""incorrect sign"", 1, result.signum()) }"	"shiftRight ( int n ) , n > 32"
fun fixStatsError(sendCommand: Int) { while (this.affectedRows.length < sendCommand) { this.affectedRows.get(currentStat++) = Statement.EXECUTE_FAILED } }	Add missing information when Exception is thrown .
"@Throws(IOException::class) fun readRawBytes(size: Int): ByteArray? { if (size < 0) { throw InvalidProtocolBufferNanoException.negativeSize() } if (bufferPos + size > currentLimit) { skipRawBytes(currentLimit - bufferPos) throw InvalidProtocolBufferNanoException.truncatedMessage() } return if (size <= bufferSize - bufferPos) { val bytes = ByteArray(size) System.arraycopy(buffer, bufferPos, bytes, 0, size) bufferPos += size bytes } else { throw InvalidProtocolBufferNanoException.truncatedMessage() } }"	Read a fixed size of bytes from the input .
private fun resetToXMLSAXHandler() { this.m_escapeSetting = true }	Reset all of the fields owned by ToXMLSAXHandler class
"fun cuCmplx(r: Float, i: Float): cuComplex? { val res = cuComplex() res.x = r res.y = i return res }"	Creates a new complex number consisting of the given real and imaginary part .
"fun make( rawSig: String?, f: sun.reflect.generics.factory.GenericsFactory? ): sun.reflect.generics.repository.MethodRepository? { return sun.reflect.generics.repository.MethodRepository(rawSig, f) }"	Static factory method .
fun add(`object`: T?) { mObjects.add(`object`) notifyItemInserted(getItemCount() - 1) }	Adds the specified object at the end of the array .
"fun compareHardware(hwMap: Map<String?, String>, checkDisk: Boolean): String? { val localMemSizeStr: String = ServerProbe.getInstance().getMemorySize() val localCpuCoreStr: String = ServerProbe.getInstance().getCpuCoreNum() hwMap[PropertyConstants.PROPERTY_KEY_DISK_CAPACITY] if (localMemSizeStr != hwMap[PropertyConstants.PROPERTY_KEY_MEMORY_SIZE]) { log.warn( ""Local memory {} is not the same as selected cluster {}"", localMemSizeStr, hwMap[PropertyConstants.PROPERTY_KEY_MEMORY_SIZE] ) return String.format( ""Local memory {%s} is not the same as selected cluster {%s}"", localMemSizeStr, hwMap[PropertyConstants.PROPERTY_KEY_MEMORY_SIZE] ) } if (localCpuCoreStr != hwMap[PropertyConstants.PROPERTY_KEY_CPU_CORE]) { log.warn( ""Local CPU core number {} is not the same as selected cluster {}"", localCpuCoreStr, hwMap[PropertyConstants.PROPERTY_KEY_CPU_CORE] )return String.format( ""Local CPU core number {%s} is not the same as selected cluster {%s}"", localCpuCoreStr, hwMap[PropertyConstants.PROPERTY_KEY_CPU_CORE] ) } if (checkDisk && !hasSameDiskInfo( hwMap[PropertyConstants.PROPERTY_KEY_DISK], hwMap[PropertyConstants.PROPERTY_KEY_DISK_CAPACITY] ) ) { log.warn( ""Local disk(s) are not the same as selected cluster capacity {}"", hwMap[PropertyConstants.PROPERTY_KEY_DISK_CAPACITY] ) return String.format( ""Local disk(s) are not the same as selected cluster capacity {%s}"", hwMap[PropertyConstants.PROPERTY_KEY_DISK_CAPACITY] ) } return null }"	"Check local node hardware ( i.e . Memory size , CPU core , Disk Capacity ) are the same as in the input map ."
"fun tearDown(bot: SWTWorkbenchBot) { SwtBotUtils.print(""Tear Down"") bot.resetWorkbench() SwtBotUtils.print(""Tear Down  "") }"	Performs the necessary tear down work for most SWTBot tests .
"private fun handleMessage(data: ByteArray) { val buffer = Buffer() buffer.write(data) val type: Int = buffer.readShort() and 0xffff and APP_MSG_RESPONSE_BIT.inv() if (type == BeanMessageID.SERIAL_DATA.getRawValue())   beanListener.onSerialMessageReceived(buffer.readByteArray()) } else if (type == BeanMessageID.BT_GET_CONFIG.getRawValue()) { returnConfig(buffer) } else if (type == BeanMessageID.CC_TEMP_READ.getRawValue()) { returnTemperature(buffer) } else if (type == BeanMessageID.BL_GET_META.getRawValue()) { returnMetadata(buffer) } else if (type == BeanMessageID.BT_GET_SCRATCH.getRawValue()) { returnScratchData(buffer) } else if (type == BeanMessageID.CC_LED_READ_ALL.getRawValue()) { returnLed(buffer) } else if (type == BeanMessageID.CC_ACCEL_READ.getRawValue()) { returnAcceleration(buffer) } else if (type == BeanMessageID.CC_ACCEL_GET_RANGE.getRawValue()) { returnAccelerometerRange(buffer) } else if (type == BeanMessageID.CC_GET_AR_POWER.getRawValue()) { returnArduinoPowerState(buffer) } else if (type == BeanMessageID.BL_STATUS.getRawValue()) { try { val status: Status = Status.fromPayload(buffer) handleStatus(status) } catch (e: NoEnumFoundException) { Log.e(TAG, ""Unable to parse status from buffer: "" + buffer.toString()) e.printStackTrace() } } else { var fourDigitHex = Integer.toHexString(type) while (fourDigitHex.length < 4) { fourDigitHex = ""0$fourDigitHex"" } Log.e(TAG, ""Received message of unknown type 0x$fourDigitHex"") returnError(BeanError.UNKNOWN_MESSAGE_ID) } }"	Handles incoming messages from the Bean and dispatches them to the proper handlers .
"fun <K, V> newEmptyHashMap(iterable: Iterable<*>?): HashMap<K, V>? { return if (iterable is Collection<*>) Maps.newHashMapWithExpectedSize( iterable.size ) else Maps.newHashMap() }"	"Returns an empty map with expected size matching the iterable size if it 's of type Collection . Otherwise , an empty map with the default size is returned ."
"fun calculateScrollY(firstVisiblePosition: Int, visibleItemCount: Int): Int { mFirstVisiblePosition = firstVisiblePosition if (mReferencePosition < 0) { mReferencePosition = mFirstVisiblePosition } if (visibleItemCount > 0) { val c: View = mListView.getListChildAt(0) var scrollY = -c.top mListViewItemHeights.put(firstVisiblePosition, c.measuredHeight) return if (mFirstVisiblePosition >= mReferencePosition) { for (i in mReferencePosition until firstVisiblePosition) { if (mListViewItemHeights.get(i) == null) { mListViewItemHeights.put(i, c.measuredHeight) } scrollY += mListViewItemHeights.get(i) } scrollY } else { for (i in mReferencePosition - 1 downTo firstVisiblePosition) { if (mListViewItemHeights.get(i) == null) { mListViewItemHeights.put(i, c.measuredHeight) } scrollY -= mListViewItemHeights.get(i) } scrollY } } return 0 }"	Call from an AbsListView.OnScrollListener to calculate the scrollY ( Here we definite as the distance in pixels compared to the position representing the current date ) .
fun DynamicRegionFactoryImpl() {}	create an instance of the factory . This is normally only done by DynamicRegionFactory 's static initialization
"fun DViewAsymmetricKeyFields( parent: javax.swing.JDialog?, title: String?, dsaPublicKey: DSAPublicKey ) { super(parent, title, Dialog.ModalityType.DOCUMENT_MODAL) key = dsaPublicKey initFields() }"	Creates new DViewAsymmetricKeyFields dialog .
fun removeAllActions(target: CCNode?) { if (target == null) return val element: HashElement = targets.get(target) if (element != null) { deleteHashElement(element) } else { } }	Removes all actions from a certain target . All the actions that belongs to the target will be removed .
"private fun normalizeName(name: String): String? { var name: String? = name name = name?.trim { it <= ' ' } ?: """" return if (name.isEmpty()) MISSING_NAME else name }"	Normalizes a name to something OpenMRS will accept .
@Throws(QueryNodeException::class) fun build(queryNode: QueryNode): Any? { process(queryNode) return queryNode.getTag(QUERY_TREE_BUILDER_TAGID) }	Builds some kind of object from a query tree . Each node in the query tree is built using an specific builder associated to it .
fun isEnableLighting(): Boolean { return false }	Returns false .
"protected fun prepare() { val para: Array<ProcessInfoParameter> = getParameter() for (i in para.indices) { val name: String = para[i].getParameterName() if (para[i].getParameter() == null) ; else log.log( Level.SEVERE, ""prepare - Unknown Parameter: $name"" ) } }"	"Prepare - e.g. , get Parameters ."
"fun fling(velocityX: Int, velocityY: Int) { if (getChildCount() > 0) { val height: Int = getHeight() - getPaddingBottom() - getPaddingTop() val bottom: Int = getChildAt(0).getHeight() val width: Int = getWidth() - getPaddingRight() - getPaddingLeft() val right: Int = getChildAt(0).getWidth() mScroller.fling( getScrollX(), getScrollY(), velocityX, velocityY, 0, right - width, 0, bottom - height ) val movingDown = velocityY > 0 val movingRight = velocityX > 0 var newFocused: View = findFocusableViewInMyBounds( movingRight, mScroller.getFinalX(), movingDown, mScroller.getFinalY(), findFocus() ) if (newFocused == null) { newFocused = this } if (newFocused !== findFocus() && newFocused.requestFocus(if (movingDown) View.FOCUS_DOWN else View.FOCUS_UP)) { mTwoDScrollViewMovedFocus = true mTwoDScrollViewMovedFocus = false } awakenScrollBars(mScroller.getDuration()) invalidate() } }"	Fling the scroll view
protected fun createSocket(): Socket? { return Socket() }	Creates a new unconnected Socket instance . Subclasses may use this method to override the default socket implementation .
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:36:21.616 -0500"", hash_original_method = ""F5BF0DDF083843E14FDE0C117BAE250E"", hash_generated_method = ""E1C3BB6772CE07721D8608A1E4D81EE1"" ) fun netmaskIntToPrefixLength(netmask: Int): Int { return Integer.bitCount(netmask) }"	Convert a IPv4 netmask integer to a prefix length
"fun createWritableChild( x: Int, y: Int, width: Int, height: Int, x0: Int, y0: Int, bandList: IntArray? ): java.awt.image.WritableRaster? { if (x < this.minX) { throw java.awt.image.RasterFormatException(""x lies outside the raster"") } if (y < this.minY) { throw java.awt.image.RasterFormatException(""y lies outside the raster"") } if (x + width < x || x + width > this.minX + width) { throw java.awt.image.RasterFormatException(""(x + width) is outside of Raster"") } if (y + height < y || y + height > this.minY + height) { throw java.awt.image.RasterFormatException(""(y + height) is outside of Raster"") } val sm: java.awt.image.SampleModel if (bandList != null) sm = sampleModel.createSubsetSampleModel(bandList) else sm = sampleModel val deltaX = x0 - x val deltaY = y0 - y return sun.awt.image.ShortInterleavedRaster( sm, dataBuffer, java.awt.Rectangle(x0, y0, width, height), Point(sampleModelTranslateX + deltaX, sampleModelTranslateY + deltaY), this ) }"	"Creates a Writable subRaster given a region of the Raster . The x and y coordinates specify the horizontal and vertical offsets from the upper-left corner of this Raster to the upper-left corner of the subRaster . A subset of the bands of the parent Raster may be specified . If this is null , then all the bands are present in the subRaster . A translation to the subRaster may also be specified . Note that the subRaster will reference the same DataBuffers as the parent Raster , but using different offsets ."
"private fun isBlockCommented( startLine: Int, endLine: Int, prefixes: Array<String>, document: IDocument ): Boolean { try { for (i in startLine..endLine) { val line: IRegion = document.getLineInformation(i) val text: String = document.get(line.getOffset(), line.getLength()) val found: IntArray = TextUtilities.indexOf(prefixes, text, 0) if (found[0] == -1) return false var s: String = document.get(line.getOffset(), found[0]) s = s.trim { it <= ' ' } if (s.length != 0) return false } return true } catch (x: javax.swing.text.BadLocationException) { } return false }"	Determines whether each line is prefixed by one of the prefixes .
fun eUnset(featureID: Int) { when (featureID) { GamlPackage.PARAMETERS__PARAMS -> { setParams(null as jdk.nashorn.internal.ir.ExpressionList?) return } } super.eUnset(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"@JvmStatic fun main(args: Array<String>) { var matrixFilename: String? = null var coordinateFilename: String? = null var externalZonesFilename: String? = null var networkFilename: String? = null var plansFilename: String? = null var populationFraction: Double? = null require(args.size == 6) { ""Wrong number of arguments"" } matrixFilename = args[0] coordinateFilename = args[1] externalZonesFilename = args[2] networkFilename = args[3] plansFilename = args[4] populationFraction = args[5].toDouble() val list: MutableList<String?> = ArrayList() try { val br: BufferedReader = sun.security.util.IOUtils.getBufferedReader(externalZonesFilename) try { var line: String? = null while (br.readLine().also { line = it } != null) { list.add(line) } } finally { br.close() } } catch (e: FileNotFoundException) { e.printStackTrace() } catch (e: IOException) { e.printStackTrace() } val mdm = MyDemandMatrix() mdm.readLocationCoordinates(coordinateFilename, 2, 0, 1) mdm.parseMatrix(matrixFilename, ""Saturn"", ""Saturn model received for Sanral project"") val sc: Scenario = mdm.generateDemand(list, Random(5463), populationFraction, ""car"") val nr = NetworkReaderMatsimV1(sc.getNetwork()) nr.readFile(networkFilename) val xy = XY2Links(sc.getNetwork(), null) xy.run(sc.getPopulation()) val pw = PopulationWriter(sc.getPopulation(), sc.getNetwork()) pw.write(plansFilename) }"	"Class to generate plans files from the Saturn OD-matrices provided by Sanral 's modelling consultant , Alan Robinson ."
"private fun partition(a: IntArray, left: Int, right: Int): Int { var left = left var right = right val pivot = a[left + (right - left) / 2] while (left <= right) { while (a[left] > pivot) left++ while (a[right] < pivot) right-- if (left <= right) { val temp = a[left] a[left] = a[right] a[right] = temp left++ right-- } } return left }"	Choose mid value as pivot Move two pointers Swap and move on Return left pointer
fun isDone(): Boolean {return one.getHand().empty() || two.getHand().empty() }	Returns true if either hand is empty .
"fun ClassNotFoundException(@Nullable s: String?, @Nullable ex: Throwable) { super(s, null) ex = ex }"	Constructs a < code > ClassNotFoundException < /code > with the specified detail message and optional exception that was raised while loading the class .
fun eIsSet(featureID: Int): Boolean { when (featureID) { BasePackage.DOCUMENTED_ELEMENT__DOCUMENTATION -> return if (DOCUMENTATION_EDEFAULT == null) documentation != null else !DOCUMENTATION_EDEFAULT.equals( documentation ) } return super.eIsSet(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun drawRangeLine( g2: java.awt.Graphics2D, plot: CategoryPlot, axis: ValueAxis, dataArea: java.awt.geom.Rectangle2D, value: Double, paint: Paint?, stroke: java.awt.Stroke? ) { val range: Range = axis.getRange() if (!range.contains(value)) { return } val adjusted: java.awt.geom.Rectangle2D = java.awt.geom.Rectangle2D.Double( dataArea.getX(), dataArea.getY() + getYOffset(), dataArea.getWidth() - getXOffset(), dataArea.getHeight() - getYOffset() ) var line1: java.awt.geom.Line2D? = null var line2: java.awt.geom.Line2D? = null val orientation: PlotOrientation = plot.getOrientation() if (orientation === PlotOrientation.HORIZONTAL) { val x0: Double = axis.valueToJava2D(value, adjusted, plot.getRangeAxisEdge()) val x1: Double = x0 + getXOffset() val y0: Double = dataArea.getMaxY() val y1: Double = y0 - getYOffset() val y2: Double = dataArea.getMinY() line1 = java.awt.geom.Line2D.Double(x0, y0, x1, y1) line2 = java.awt.geom.Line2D.Double(x1, y1, x1, y2) } else if (orientation === PlotOrientation.VERTICAL) { val y0: Double = axis.valueToJava2D(value, adjusted, plot.getRangeAxisEdge()) val y1: Double = y0 - getYOffset() val x0: Double = dataArea.getMinX() val x1: Double = x0 + getXOffset() val x2: Double = dataArea.getMaxX() line1 = java.awt.geom.Line2D.Double(x0, y0, x1, y1) line2 = java.awt.geom.Line2D.Double(x1, y1, x2, y1) } g2.setPaint(paint) g2.setStroke(stroke) g2.draw(line1) g2.draw(line2) }"	Draws a line perpendicular to the range axis .
fun startFading() { mHandler.removeMessages(MSG_FADE) scheduleFade() }	"Start up the pulse to fade the screen , clearing any existing pulse to ensure that we do n't have multiple pulses running at a time ."
"@Throws(Exception::class) protected fun createConnection(): Connection? { val factory = ActiveMQConnectionFactory(""vm://localhost?broker.persistent=false"") return factory.createConnection() }"	Creates a connection .
"protected fun drawView( g: java.awt.Graphics2D, r: java.awt.Rectangle, view: View, fontHeight: Int, y: Int )  { var y = y var x: Float = r.x.toFloat() val h: javax.swing.text.LayeredHighlighter = attr.host.getHighlighter() as javax.swing.text.LayeredHighlighter val document: RSyntaxDocument = com.sun.org.apache.xerces.internal.util.DOMUtil.getDocument() as RSyntaxDocument val map: Element = getElement() var p0: Int = view.getStartOffset() val lineNumber: Int = map.getElementIndex(p0) val p1: Int = view.getEndOffset() setSegment(p0, p1 - 1, document, drawSeg) val start: Int = p0 - drawSeg.offset var token: Token = document.getTokenListForLine(lineNumber)if (token != null && token.type === Token.NULL) { h.paintLayeredHighlights(g, p0, p1, r, attr.host, this) return } while (token != null && token.isPaintable()) { val p: Int = calculateBreakPosition(p0, token, x) x = r.x.toFloat() h.paintLayeredHighlights(g, p0, p, r, attr.host, this) while (token != null && token.isPaintable() && token.offset + token.textCount - 1 < p) { x = token.paint(g, x, y, attr.host, this) token = token.getNextToken() } if (token != null && token.isPaintable() && token.offset < p) { val tokenOffset: Int = token.offset var temp: Token? = DefaultToken( drawSeg, tokenOffset - start, p - 1 - start, tokenOffset, token.type ) temp.paint(g, x, y, attr.host, this) temp = null token.makeStartAt(p) } p0 = if (p == p0) p1 else p y += fontHeight } if (attr.host.getEOLMarkersVisible()) { g.setColor(attr.host.getForegroundForTokenType(Token.WHITESPACE)) g.setFont(attr.host.getFontForTokenType(Token.WHITESPACE)) g.drawString(""¶"", x, (y - fontHeight).toFloat()) } }"	"Draws a single view ( i.e. , a line of text for a wrapped view ) , wrapping the text onto multiple lines if necessary ."
"fun containsKey(key: Any?): Boolean {var key = key if (key == null) {key = NULL_OBJECT}val index: Int = findIndex(key,  elementData) return elementData.get(index) === key }"	Returns whether this map contains the specified key .
"fun autoCorrectText(): Boolean { return preferences.getBoolean( resources.getString(R.string.key_autocorrect_text), java.lang.Boolean.parseBoolean(resources.getString(R.string.default_autocorrect_text)) ) }"	Whether message text should be autocorrected .
"@Throws(Exception::class) protected fun removeNode(id: Int) { val idx: Int var node: FolderTokenDocTreeNode? = null idx = findIndexById(id) if (idx == -1) { throw IeciTdException(FolderBaseError.EC_NOT_FOUND, FolderBaseError.EM_NOT_FOUND) } node = m_nodes.get(idx) as FolderTokenDocTreeNode if (node.isNew()) m_nodes.remove(idx) else node.setEditFlag(FolderEditFlag.REMOVE) }"	Elimina de la lista de nodos el nodo con el id especificado
fun deleteAttributes(columnIndices: IntArray?) { (getModel() as ArffTableModel).deleteAttributes(columnIndices) }	deletes the attributes at the given indices
"fun onSuccess(statusCode: Int, headers: Array<Header?>?, response: JSONObject?) { Log.w( LOG_TAG, ""onSuccess(int, Header[], JSONObject) was not overriden, but callback was received"" ) }"	Returns when request succeeds
"fun lastIndexOfFromTo(element: Byte, from: Int, to: Int): Int {if (size === 0) return -1 checkRangeFromTo(from, to, size) val theElements: ByteArray = elements for (i in to downTo from) { if (element == theElements[i]) { return i } } return -1 }"	"Returns the index of the last occurrence of the specified element . Returns < code > -1 < /code > if the receiver does not contain this element . Searches beginning at < code > to < /code > , inclusive until < code > from < /code > , inclusive . Tests for identity ."
fun put(key: Long) { if (key == FREE_KEY) { m_hasFreeKey = true return } var ptr = (Tools.phiMix(key) and m_mask) as Int var e: Long = m_data.get(ptr) if (e == FREE_KEY) { m_data.get(ptr) = key if (m_size >= m_threshold) { rehash(m_data.length * 2) } else { ++m_size } return } else if (e == key) { return } while (true) { ptr = (ptr + 1 and m_mask) e = m_data.get(ptr) if (e == FREE_KEY) { m_data.get(ptr) = key if (m_size >= m_threshold) { rehash(m_data.length * 2) } else { ++m_size } return } else if (e == key) { return }   }	Add a single element to the map
"@Throws(InstantiationException::class, IllegalAccessException::class, ClassNotFoundException::class ) fun PredictiveInfoCalculatorKraskov(calculatorName: String) { super(calculatorName) if (!calculatorName.equals( MI_CALCULATOR_KRASKOV1, ignoreCase = true ) && !calculatorName.equals(MI_CALCULATOR_KRASKOV2, ignoreCase = true) ) { throw ClassNotFoundException(""Must be an underlying Kraskov-Grassberger calculator"") } }"	"Creates a new instance of the Kraskov-Stoegbauer-Grassberger estimator for PI , with the supplied MI calculator name ."
"fun DefaultDirectAdjacentSelector(type: Short, parent: Selector?, simple: SimpleSelector?) { super(type, parent, simple) }"	Creates a new DefaultDirectAdjacentSelector object .
"@Inline fun postCopy(`object`: com.sun.jdi.ObjectReference?, majorGC: Boolean) { initializeHeader(`object`, false) if (!HEADER_MARK_BITS) { testAndSetLiveBit(`object`) } }"	Perform any required post copy ( i.e . in-GC allocation ) initialization . This is relevant ( for example ) when MS is used as the mature space in a copying GC .
"fun parseRulesFile(`is`: InputStream): LinkedHashMap<Pattern, String>? { val rules: LinkedHashMap<Pattern, String> = LinkedHashMap() val br = BufferedReader( sun.security.util.IOUtils.getDecodingReader( `is`, StandardCharsets.UTF_  ) ) var line: String try { var linenum = 0 while (br.readLine().also { line = it } != null) { linenum++ val arr = line.split(""#"").toTypedArray() if (arr.size > 0) line = arr[0].trim { it <= ' ' } if (line.length == 0) continue val sep = line.indexOf(""="") if (sep <= 0) { log.warn(""Wrong format of password line $linenum"") continue } val pass = line.substring(sep + 1).trim { it <= ' ' } val regex = line.substring(0, sep).trim { it <= ' ' } try { val pattern: Pattern = Pattern.compile(regex) rules[pattern] = pass } catch (pse: PatternSyntaxException) { log.warn(""Key of line $linenum was not a valid regex pattern"", pse) continue }  } `is`.close() } catch (e: IOException) { throw RuntimeException(e) } return rules }"	Parses rule file from stream and returns a Map of all rules found
fun isItemForce(): Boolean {return true }	Returns true .
"fun document(document: InputStream, mediaType: String): Builder? { documentInputStream = document mediaType = mediaType return this }"	Sets the document as an input stream and its media type .
"override fun toString(): String { val text = StringBuffer() text.append( """""" Print statistic values of instances (${first.toString()}-${last.toString()}=  """""".trimIndent() ) text.append( """""" Number of instances: ${numInstances.toString()} """""" ) text.append( """""" NUmber of instances with unknowns: ${missingInstances.toString()} """""" ) text.append( """""" Attribute: :${attr.toString()} """""" ) text.append( """""" Sum: ${sum.toString()} """""" ) text.append( """""" Squared sum: ${sqrSum.toString()} """""" ) text.append( """""" Stanard Deviation: ${sd.toString()} """""" ) return text.toString() }"	Converts the stats to a string
"private fun scanAndLock(key: Any, hash: Int) { var first: HashEntry<K?, V?> = entryForHash(this, hash) var e: HashEntry<K?, V?> = first var retries = -1 while (!tryLock()) { var f: HashEntry<K?, V?> if (retries < 0) { if (e == null || key == e.key) retries = 0 else e = e.next } else if (++retries > MAX_SCAN_RETRIES) { lock() break } else if (retries and 1 == 0 && entryForHash(this, hash).also { f = it } !== first) { first = f e = first retries = -1 } } }"	"Scans for a node containing the given key while trying to acquire lock for a remove or replace operation . Upon return , guarantees that lock is held . Note that we must lock even if the key is not found , to ensure sequential consistency of updates ."
fun oldColor(oldColor: Int): IntentBuilder? { mOldColor = oldColor return this }	"Sets the old color to show on the bottom `` Cancel '' half circle , and also the initial value for the picked color . The default value is black ."
fun __setDaoSession(daoSession: DaoSession) {daoSession = daoSessionmyDao = if (daoSession != null) daoSession.getUserDBDao() else null }	"called by internal mechanisms , do not call yourself ."
fun equals(obj: Any): Boolean { if (obj === this) { return true } if (obj !is TimeTableXYDataset) { return false } val that: TimeTableXYDataset = obj as TimeTableXYDataset if (this.domainIsPointsInTime !== that.domainIsPointsInTime) { return false   if (this.xPosition !== that.xPosition) { return false } if (!this.workingCalendar.getTimeZone().equals(that.workingCalendar.getTimeZone())) { return false } return if (!this.values.equals(that.values)) { false } else true }	Tests this dataset for equality with an arbitrary object .
"private fun startContext(crawlJob: CrawlJob) { LOGGER.debug(""Starting context"") val ac: PathSharingContext = crawlJob.getJobContext() ac.addApplicationListener(this) try { ac.start() } catch (be: BeansException) { LOGGER.warn(be.getMessage()) ac.close() } catch (e: Exception) { LOGGER.warn(e.message) try { ac.close() } catch (e2: Exception) { e2.printStackTrace(System.err) } finally { } } LOGGER.debug(""Context started"") }"	"Start the context , catching and reporting any BeansExceptions ."
fun performCancel(): Boolean { CnAElementFactory.getInstance().reloadModelFromDatabase() return true }	Cause update to risk analysis object in loaded model .
fun isOpaque(): Boolean { checkOpacityMethodClient() return explicitlyOpaque }	Returns whether the background of this < code > BasicPanel < /code > will be painted when it is rendered .
"@Throws(IOException::class, ClassNotFoundException::class) private fun readObject(s: ObjectInputStream) { s.defaultReadObject() } }"	"Adds semantic checks to the default deserialization method . This method must have the standard signature for a readObject method , and the body of the method must begin with `` s.defaultReadObject ( ) ; '' . Other than that , any semantic checks can be specified and do not need to stay the same from version to version . A readObject method of this form may be added to any class , even if Tetrad sessions were previously saved out using a version of the class that did n't include it . ( That 's what the `` s.defaultReadObject ( ) ; '' is for . See J. Bloch , Effective Java , for help ."
"@Throws(Exception::class) fun resetDistribution(data: Instances) { val insts = Instances(data, data.numInstances()) for (i in 0 until data.numInstances()) { if (whichSubset(data.instance(i)) > -1) { insts.add(data.instance(i)) } } val newD = Distribution(insts, this) newD.addInstWithUnknown(data, m_attIndex) m_distribution = newD }"	Sets distribution associated with model .
"@Throws(NoSuchFieldException::class) fun <T, R> readStaticField(klass: Class<T>?, fieldName: String?): R { return readAvailableField(klass, null, fieldName) }"	Reads the static field with given fieldName in given klass .
"fun extractFactor_Display(laggedFactor: String): String? { val colonIndex = laggedFactor.indexOf("":L"") return laggedFactor.substring(0, colonIndex) }"	Parses the given string representing a lagged factor and return the part that represents the factor .
"@Throws(IOException::class) protected fun deployCargoPing(container: WebLogicLocalContainer) { val deployDir: String = getFileHandler().createDirectory(getDomainHome(), container.getAutoDeployDirectory()) getResourceUtils().copyResource( RESOURCE_PATH.toString() + ""cargocpc.war"", getFileHandler().append(deployDir, ""cargocpc.war""), getFileHandler() ) }"	Deploy the Cargo Ping utility to the container .
fun size(): Int {return this.count }	Returns the number of mappings in this map
"@Throws(Exception::class) protected fun parse(stream: DataInputStream) { var size: Int = stream.readInt() var ret: Int var read = 0 data = ByteArray(size) while (size > 0) { ret = stream.read(data, read, size) size -= ret read += ret } }"	Loading method . ( see NBT_Tag )
"@Ignore(""NaN behavior TBD"") @Test @Throws(Exception::class) fun testLinearAzimuth_WithNaN() { val begin = Location(Double.NaN, Double.NaN) val end = Location(34.2, -119.2) val azimuth: Double = begin.linearAzimuth(end) assertTrue(""expecting NaN"", java.lang.Double.isNaN(azimuth)) }"	Ensures linear azimuth is NaN when NaN members are used .
"fun MutableValueBuffer(capacity: Int, src: IRaba?) { requireNotNull(src) checkCapacity(capacity) require(capacity >= src.capacity()) nvalues = src.size() values = arrayOfNulls<ByteArray>(capacity) var i = 0 for (a in src) { values.get(i++) = a } }"	Builds a mutable value buffer .
fun OutOfLineContent() { super(KEY) }	Constructs a new instance using the default metadata .
"private fun rewriteTermBruteForce(term: String): List<String>? { val termsList: MutableList<String> = rewriteBrute(term) if (term === """" || term != termsList[termsList.size - 1]) termsList.add(term) return termsList }"	"Wrapper over main recursive method , rewriteBrute which performs the fuzzy tokenization of a term The original term may not be a valid dictionary word , but be a term particular to the database The method rewriteBrute only considers terms which are valid dictionary words In case original term is not a dictionary word , it will not be added to queryList by method rewriteBrute This wrapper ensures that if rewriteBrute does not include the original term , it will still be included For example , for the term `` newyork '' , rewriteBrute will return the list < `` new york '' > But `` newyork '' also needs to be included in the list to support particular user queries This wrapper includes `` newyork '' in this list"
"@Throws(Exception::class) fun test_sssp_linkType_constraint() { val p: SmallWeightedGraphProblem = setupSmallWeightedGraphProblem() val gasEngine: IGASEngine = getGraphFixture().newGASEngine(1) try { val graphAccessor: IGraphAccessor = getGraphFixture().newGraphAccessor(null) val gasContext: IGASContext<SSSP.VS, SSSP.ES, Int> = gasEngine.newGASContext(graphAccessor, SSSP()) gasContext.setLinkType(p.getFoafKnows() as URI) val gasState: IGASState<SSSP.VS, SSSP.ES, Int> = gasContext.getGASState() gasState.setFrontier(gasContext, p.getV1()) gasContext.call() assertEquals(0.0, gasState.getState(p.getV1()).dist()) assertEquals(1.0, gasState.getState(p.getV2()).dist()) assertEquals(1.0, gasState.getState(p.getV3()).dist()) assertEquals(2.0, gasState.getState(p.getV4()).dist()) assertEquals(2.0, gasState.getState(p.getV5()).dist()) } finally { gasEngine.shutdownNow() } }"	A unit test based on graph with link weights - in this version of the test we constrain the link type but do not specify the link attribute type . Hence it ignores the link weights . This provides a test of the optimized access path when just the link type constraint is specified .
"fun convertNodeId2NotExpandedCrossingNodeId(nodeId: Id<Node?>): Id<DgCrossingNode?>? { val idString: String = nodeId.toString() return idPool.createId(idString, DgCrossingNode::class.java) }"	converts a matsim node ID of a node outside the signals bounding box to the single crossing node ID existing for the not expanded crossing in the ks-model . ( the signals bounding box determines the region of spatial expansion : all nodes within this area will be expanded . )
"@Throws(Exception::class) fun runSafely(stack: Catbert.FastStack?): Any? { val k = getString(stack) val r = getString(stack) return if (!Sage.WINDOWS_OS) Pooler.EMPTY_STRING_ARRAY else Sage.getRegistryNames( Sage.getHKEYForName( r ), k ) }"	"Returns a list of the Windows registry names which exist under the specified root & amp ; key ( Windows only ) Acceptable values for the Root are : `` HKCR '' , `` HKEY_CLASSES_ROOT '' , `` HKCC '' , `` HKEY_CURRENT_CONFIG '' , `` HKCU '' , `` HKEY_CURRENT_USER '' , `` HKU '' , `` HKEY_USERS '' , `` HKLM '' or `` HKEY_LOCAL_MACHINE '' ( HKLM is the default if nothing matches )"
fun APIPermissionSet() {}	Creates a new permission set which contains no granted permissions . Any permissions must be added by manipulating or replacing the applicable permission collection .
"@RequestMapping( value = ""/upload/single/initiation"", method = RequestMethod.POST, consumes = [""application/xml"", ""application/json""] ) @Secured(SecurityFunctions.FN_UPLOAD_POST) fun initiateUploadSingle(@RequestBody uploadSingleInitiationRequest: UploadSingleInitiationRequest?): UploadSingleInitiationResponse? { val uploadSingleInitiationResponse: UploadSingleInitiationResponse = uploadDownloadService.initiateUploadSingle(uploadSingleInitiationRequest) for (businessObjectData in Arrays.asList( uploadSingleInitiationResponse.getSourceBusinessObjectData(), uploadSingleInitiationResponse.getTargetBusinessObjectData() )) { val businessObjectDataKey: BusinessObjectDataKey = businessObjectDataHelper.getBusinessObjectDataKey(businessObjectData) for (eventType in Arrays.asList( NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN, NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG )) { notificationEventService.processBusinessObjectDataNotificationEventAsync( eventType, businessObjectDataKey, businessObjectData.getStatus(), null ) } for (storageUnit in businessObjectData.getStorageUnits()) { notificationEventService.processStorageUnitNotificationEventAsync( NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG, businessObjectDataKey, storageUnit.getStorage().getName(), storageUnit.getStorageUnitStatus(), null ) } } return uploadSingleInitiationResponse }"	Initiates a single file upload capability by creating the relative business object data instance in UPLOADING state and allowing write access to a specific location in S3_MANAGED_LOADING_DOCK storage . < p > Requires WRITE permission on namespace < /p >
"fun ArrayIntCompressed(size: Int, leadingClearBits: Int, trailingClearBits: Int) {init(size, BIT_LENGTH - leadingClearBits  trailingClearBits, trailingClearBits) }"	"Create < code > IntArrayCompressed < /code > from number of ints to be stored , the number of leading and trailing clear bits . Everything else is stored in the internal data structure ."
"fun compXmlStringAt(arr: ByteArray, strOff: Int): String? { val strLen: Int = arr[strOff + 1] shl 8 and 0xff00 or arr[strOff] and 0xff val chars = CharArray(strLen) for (ii in 0 until strLen) { val p0 = strOff + 2 + ii * 2 if (p0 >= arr.size - 1) break chars[ii] = ((arr[p0 + 1] and 0x00FF shl 8) + (arr[p0] and 0x00FF)).toChar() } return String(chars) }"	"Return the string stored in StringTable format at offset strOff . This offset points to the 16 bit string length , which is followed by that number of 16 bit ( Unicode ) chars ."
"fun AbstractExportOperation(archiveFile: File, mainFile: IFile, project: IN4JSEclipseProject) { this.targetFile = archiveFile mainFile = mainFile project = project this.workspace = project.getProject().getWorkspace() rootLocation = project.getLocation().appendSegment("""") }"	Create an operation that will export the given project to the given zip file .
"@Throws(SQLException::class) fun supportsMixedCaseQuotedIdentifiers(): Boolean { debugCodeCall(""supportsMixedCaseQuotedIdentifiers"") val m: String = conn.getMode() return if (m == ""MySQL"") { false } else true }"	Checks if a table created with CREATE TABLE `` Test '' ( ID INT ) is a different table than a table created with CREATE TABLE TEST ( ID INT ) .
"private fun leftEdge(image: java.awt.image.BufferedImage): Shape? { val path: java.awt.geom.GeneralPath = java.awt.geom.GeneralPath() var p1: java.awt.geom.Point2D? = null var p2: java.awt.geom.Point2D? = null val line: java.awt.geom.Line2D = java.awt.geom.Line2D.Float() var p: java.awt.geom.Point2D = java.awt.geom.Point2D.Float() var foundPointY = -1 for (i in 0 until image.getHeight()) { for (j in 0 until image.getWidth()) { if (image.getRGB(j, i) and -0x1000000 != 0) { p = java.awt.geom.Point2D.Float(j, i) foundPointY = i break } } if (foundPointY >= 0) { if (p2 == null) { p1 = java.awt.geom.Point2D.Float(image.getWidth() - 1, foundPointY) path.moveTo(p1.getX(), p1.getY()) p2 = java.awt.geom.Point2D.Float() p2.setLocation(p) } else { p2 = detectLine(p1, p2, p, line, path) } } } path.lineTo(p.getX(), p.getY()) if (foundPointY >= 0) { path.lineTo((image.getWidth() - 1).toFloat(), foundPointY.toFloat()) } path.closePath() return path }"	trace the left side of the image
"@Throws(Exception::class) fun testSetMaxRows() { var maxRowsStmt: Statement? = null try { maxRowsStmt = this.conn.createStatement() maxRowsStmt.setMaxRows(1) this.rs = maxRowsStmt.executeQuery(""SELECT 1"") } finally { if (maxRowsStmt != null) { maxRowsStmt.close() } } }"	Tests fix for BUG # 907
fun unregisterMbeans() { unregisterMbeans(ManagementFactory.getPlatformMBeanServer()) }	unRegister all jamon related mbeans
fun free(value: T?): Boolean { return _ringQueue.offer(value) }	"Frees the object . If the free list is full , the object will be garbage collected ."
"fun basicSet_lok( new_lok: LocalArgumentsVariable, msgs: NotificationChain? ): NotificationChain? { var msgs: NotificationChain? = msgs val old_lok: LocalArgumentsVariable = _lok _lok = new_lok if (eNotificationRequired()) { val notification = ENotificationImpl( this, Notification.SET, N4JSPackage.FUNCTION_DECLARATION__LOK, old_lok, new_lok ) if (msgs == null) msgs = notification else msgs.add(notification) } return msgs }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun query(onlyCurrentRows: Boolean, onlyCurrentDays: Int, maxRows: Int) { m_mTab.query(onlyCurrentRows, onlyCurrentDays, maxRows) if (!isSingleRow()) vTable.autoSize(true) activateChilds() }"	Query Tab and resize Table ( called from APanel )
"fun queryProb(query: Query.ProbQuery?): EmpiricalDistribution? { val isquery = LikelihoodWeighting(query, nbSamples, maxSamplingTime) val samples: List<Sample> = isquery.getSamples() return EmpiricalDistribution(samples) }"	"Queries for the probability distribution of the set of random variables in the Bayesian network , given the provided evidence"
fun loadChar(offset: Offset?): Char { if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED) return 0.toChar() }	Loads a char from the memory location pointed to by the current instance .
"fun put(src: FloatArray, off: Int, len: Int): FloatBuffer? {val length = src.size if (off < 0 || len < 0 || off.toLong() + len.toLong() > length) { throw IndexOutOfBoundsException() } if (len > remaining()) { throw BufferOverflowException() } for (i in off until off + len) { put(src[i]) } return this }"	"Writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written ."
"@Throws(InterruptedException::class, KeeperException::class) fun deleteCollectionLevelSnapshot( zkClient:  SolrZkClient, collectionName: String?, commitName: String? ) { val zkPath: String = getSnapshotMetaDataZkPath(collectionName, Optional.of(commitName)) zkClient.delete(zkPath, -1, true) }"	This method deletes an entry for the named snapshot for the specified collection in Zookeeper .
"private fun turn22(grid: IntGrid2D, x: Int, y: Int) { val p1: Int val p2: Int val p3: Int val p4: Int p1 = grid.get(grid.stx(x), grid.sty(y)) p2 = grid.get(grid.stx(x + 1), grid.sty(y)) p3 = grid.get(grid.stx(x + 1), grid.sty(y + 1)) p4 = grid.get(grid.stx(x), grid.sty(y + 1))if (p.r.nextBoolean()) { grid.set(grid.stx(x), grid.sty(y), p4) grid.set(grid.stx(x + 1), grid.sty(y), p1) grid.set(grid.stx(x + 1), grid.sty(y + 1), p2) grid.set(grid.stx(x), grid.sty(y + 1), p3) } else { grid.set(grid.stx(x), grid.sty(y), p2) grid.set(grid.stx(x + 1), grid.sty(y), p3) grid.set(grid.stx(x + 1), grid.sty(y + 1), p4) grid.set(grid.stx(x), grid.sty(y + 1), p1) } }"	Diffuse a 2x2 block clockwise or counter-clockwise . This procedure was published by Toffoli and Margolus to simulate the diffusion in an ideal gas . The 2x2 blocks will be turned by random in one direction ( clockwise or counter clockwise ) . Usually a second run will be done but this time with a offset of one to the previous run
"fun magnitude(u: DoubleArray?): Double { return Math.sqrt(dot(u, u)) }"	Returns the magnitude ( Euclidean norm ) of the specified vector .
override fun toString(): String? { return statusString }	Returns the String representation for thiz .
"fun chopFrame(offsetDelta: Int, k: Int) { numOfEntries++ output.write(251 - k) write16(offsetDelta) }"	Writes a < code > chop_frame < /code > .
"fun AsyncHttpClient(fixNoHttpResponseException: Boolean, httpPort: Int, httpsPort: Int) { this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort)) }"	Creates new AsyncHttpClient using given params
"fun verify(signature: ByteArray?): Boolean { return verify(signature, false) }"	Verifies the data ( computes the secure hash and compares it to the input )
override fun toString(): String? { return name().toLowerCase() }	override fun toString(): String? { return name().toLowerCase() }
"fun StringBand(initialCapacity: Int) { require(initialCapacity > 0) { ""Invalid initial capacity"" } array = arrayOfNulls<String (initialCapacity) }"	Creates an empty < code > StringBand < /code > with provided capacity . Capacity refers to internal string array ( i.e . number of joins ) and not the total string size .
fun removeConstraint(c: ParticleConstraint2D?): Boolean { return constraints.remove(c) }	Attempts to remove the given constraint instance from the list of active constraints .
"private fun DoneCallback( cb: GridClientFutureCallback<R, T>, lsnr: GridClientFutureListener<R>, chainedFut: GridClientFutureAdapter<T> ) { cb = cb lsnr = lsnr chainedFut = chainedFut }"	Constructs future finished notification callback .
"private fun addSignatureProfile(signature: SignatureWrapper, xmlSignature: XmlSignature) {var signatureType: SignatureType = SignatureType.NA val certificateId: String = signature.getSigningCertificateId() if (certificateId != null) { signatureType = getSignatureType(certificateId) } xmlSignature.setSignatureLevel(signatureType.name()) }"	Here we determine the type of the signature .
fun isArray(): Boolean { return false }	Determines if this Class object represents an array class .
"fun NewSessionAction() { super(""New Session"") }"	Creates a new session action for the given desktop .
"private fun appendIfNotNull(source: StringBuilder,addStr: String?,delimiter: String): StringBuilder? {var delimiter: String? = delimiter if (addStr != null) {if (addStr.length == 0) {delimiter = """"}return source.append(addStr).append(delimiter)}return source}"	"Takes a string and adds to it , with a separator , if the bit to be added is n't null . Since the logger takes so many arguments that might be null , this method helps cut out some of the agonizing tedium of writing the same 3 lines over and over ."
"@Throws(IOException::class) fun write(out: OutStream) { out.flushBits() out.writeUBits(5, getBitSize()) out.writeSBits(bitSize, minX) out.writeSBits(bitSize, maxX  out.writeSBits(bitSize, minY) out.writeSBits(bitSize, maxY) out.flushBits() }"	Write the rect contents to the output stream
"private fun checkCenter(center: LatLon) { println(""Testing fromLatLngToPoint using: $center"") val p: java.awt.geom.Point2D = googleMap.fromLatLngToPoint(center.toLatLong()) println(""Testing fromLatLngToPoint result: $p"") System.out.println(""Testing fromLatLngToPoint expected: "" + (mapComponent.getWidth() / 2).toString() + "", "" + mapComponent.getHeight() / 2) System.out.println(""type = "" + org.graalvm.compiler.nodeinfo.StructuralInput.MarkerType.BROWN.iconPath()) }"	Demonstrates how to go from lat/lon to pixel coordinates .
"fun createBusinessObjectDataAttributeEntity( namespaceCode: String?, businessObjectDefinitionName: String?, businessObjectFormatUsage: String?,businessObjectFormatFileType: String?,businessObjectFormatVersion: Int?,businessObjectDataPartitionValue: String?,businessObjectDataSubPartitionValues: List<String?>?,businessObjectDataVersion: Int?,businessObjectDataAttributeName: String?,businessObjectDataAttributeValue: String?): BusinessObjectDataAttributeEntity? {val businessObjectDataKey = BusinessObjectDataKey(namespaceCode,businessObjectDefinitionName, businessObjectFormatUsage,businessObjectFormatFileType,businessObjectFormatVersion,businessObjectDataPartitionValue,businessObjectDataSubPartitionValues,businessObjectDataVersion)return createBusinessObjectDataAttributeEntity(businessObjectDataKey,businessObjectDataAttributeName,businessObjectDataAttributeValue)}"	Creates and persists a new business object data attribute entity .
"@Synchronized private fun containsMapping(key: Any, value: Any): Boolean {val hash: Int = Collections.secondaryHash(key)val tab: Array<sun.jvm.hotspot.utilities.HashtableEntry<K, V>> = table val index = hash and tab.size - 1var e: sun.jvm.hotspot.utilities.HashtableEntry<K, V> = tab[index] while (e != null) { if (e.hash === hash && e.key.equals(key)) {return e.value.equals(value)}e = e.next}return false}"	Returns true if this map contains the specified mapping .
"fun Setting(value: Any, type: Int, save: Boolean, file: String) { value = value if (type == MAP) { this.defaultValue = HashMap(value as Map<*, *>) } else if (type == LIST) { this.defaultValue = copyCollection(value as Collection<*>) } else { this.defaultValue = value } save = save type = type file = file }"	Creates a new Setting object with some initial values .
"protected fun layoutGraphicModifiers( dc: DrawContext?, modifiers: AVList?, osym: OrderedSymbol? ) { }"	"Layout static graphic modifiers around the symbol . Static modifiers are not expected to change due to changes in view . The static layout is computed when a modifier is changed , but may not be computed each frame . For example , a text modifier indicating a symbol identifier would only need to be laid out when the text is changed , so this is best treated as a static modifier . However a direction of movement line that needs to be computed based on the current eye position should be treated as a dynamic modifier ."
"@HLEFunction(nid = -0x1e29de29, version = 150, checkInsideInterrupt = true) fun sceNetAdhocInit(): Int { log.info( String.format( ""sceNetAdhocInit: using MAC address=%s, nick name='%s'"", sceNet.convertMacAddressToString(Wlan.getMacAddress()), sceUtility.getSystemParamNickname() ) ) if (isInitialized) { return SceKernelErrors.ERROR_NET_ADHOC_ALREADY_INITIALIZED } isInitialized = true return 0 }"	Initialize the adhoc library .
fun Assignment(booleanAssigns: List<kotlin.String?>) { this() booleanAssigns.stream().forEach(null) }	Creates an assignment with a list of boolean assignments ( cf . method above ) .
"@Throws(Exception::class) fun testMergeSameFilterInTwoDocuments() { val srcXml = ""<web-app>"" + "" <filter>"" + "" <filter-name>f1</filter-name>"" + "" <filter-class>fclass1</filter-class>"" + "" </filter>"" + "" <filter-mapping>"" + "" <filter-name>f1</filter-name>"" + "" <url-pattern>/f1mapping1</url-pattern>"" + "" </filter-mapping>"" + ""</web-app>"" val srcWebXml: WebXml = WebXmlIo.parseWebXml(ByteArrayInputStream(srcXml.toByteArray(charset(""UTF-8""))), null) val mergeXml = ""<web-app>"" + "" <filter>"" + "" <filter-name>f1</filter-name>"" + "" <filter-class>fclass1</filter-class>"" + "" </filter>"" + "" <filter-mapping>"" + "" <filter name>f1</filter-name>"" + "" <url-pattern>/f1mapping1</url-pattern>"" + "" </filter-mapping>"" + ""</web-app>"" val mergeWebXml: WebXml = WebXmlIo.parseWebXml(ByteArrayInputStream(mergeXml.toByteArray(charset(""UTF-8""))), null) val merger = WebXmlMerger(srcWebXml) merger.mergeFilters(mergeWebXml) assertTrue(WebXmlUtils.hasFilter(srcWebXml, ""f1"")) val filterMappings: List<String> = WebXmlUtils.getFilterMappings(srcWebXml, ""f1"") assertEquals(1, filterMappings.size) assertEquals(""/f1mapping1"", filterMappings[0]) }"	"Tests whether the same filter in two different files is mapped correctly ( i.e. , once ) ."
"fun countPeriods(haystack: String?): Int { return com.sun.tools.javac.util.StringUtils.countOccurrencesOf(haystack, ""."") }"	Count the number of periods in a value .
"@JvmStatic fun main(args: Array<String>) { DOMTestCase.doMain(nodegetfirstchildnull::class.java, args) }"	Runs this test from the command line .
"fun actionPerformed(e: java.awt.event.ActionEvent?) { val target: javax.swing.text.JTextComponent = getTextComponent(e) if (target != null && e != null) { if (!target.isEditable() || !target.isEnabled()) { javax.swing.UIManager.getLookAndFeel().provideErrorFeedback(target) return } var content: String = target.getText() if (content != null && target.getSelectionStart() > 0) { content = content.substring(0, target.getSelectionStart()) } if (content != null) { target.setText(getNextMatch(content)) adaptor.markText(content.length) } } }"	Shows the next match .
"fun clear() { super.clear() LEFT_PARENTHESES = """" RIGHT_PARENTHESES = """" }"	removes the stored data but retains the dimensions of the matrix .
"fun deleteChannel(jsonChannel: CumulusChannel) { val jsonString: String = jsonChannel.toString() val i = Intent(""com.felkertech.cumulustv.RECEIVER"") i.putExtra(INTENT_EXTRA_JSON, jsonString) i.putExtra(INTENT_EXTRA_ACTION, INTENT_EXTRA_ACTION_DELETE) sendBroadcast(i) finish() }"	Deletes the provided channel and resyncs . Then the app closes .
"fun toStringExclude(`object`: Any?, excludeFieldNames: Collection<*>?): String? { return toStringExclude(`object`, toNoNullStringArray(excludeFieldNames)) }"	Builds a String for a toString method excluding the given field names .
"fun StringDict(reader: BufferedReader?) { val lines: Array<String> = PApplet.loadStrings(reader) keys = arrayOfNulls<String>(lines.size) values = arrayOfNulls<String>(lines.size) for (i in lines.indices) { val pieces: Array<String> = PApplet.split(lines[i], '\t') if (pieces.size == 2) { keys.get(count) = pieces[0] values.get(count) = pieces[1] count++ } } }"	"Read a set of entries from a Reader that has each key/value pair on a single line , separated by a tab ."
"@Throws(IOException::class) fun <K, V> writeMap(map: Map<K, V>, stream: ObjectOutputStream) { stream.writeInt(map.size) for ((key, value): Map.Entry<K, V> in map) { stream.writeObject(key) stream.writeObject(value) } }"	"Stores the contents of a map in an output stream , as part of serialization . It does not support concurrent maps whose content may change while the method is running . < p > The serialized output consists of the number of entries , first key , first value , second key , second value , and so on ."
"fun NioDatagramAcceptor() { this(DefaultDatagramSessionConfig(), null) }"	Creates a new instance .
"fun <V> callWithRetry(callable: Callable<V>, isRetryable: Predicate<Throwable?>): V { var failures = 0 while (true) { try { return callable.call() } catch (e: Throwable) { if (++failures == attempts || !isRetryable.apply(e)) { androidx.test.espresso.core.internal.deps.guava.base.Throwables.throwIfUnchecked( e ) throw RuntimeException(e) } logger.info(e, ""Retrying transient error, attempt $failures"") try { sleeper.sleep(Duration.millis(pow(2, failures) * 100)) } catch (e2: InterruptedException) { Thread.currentThread().interrupt() androidx.test.espresso.core.internal.deps.guava.base.Throwables.throwIfUnchecked( e ) throw RuntimeException(e) } } } }"	"Retries a unit of work in the face of transient errors . < p > Retrying is done a fixed number of times , with exponential backoff , if the exception that is thrown is deemed retryable by the predicate . If the error is not considered retryable , or if the thread is interrupted , or if the allowable number of attempts has been exhausted , the original exception is propagated through to the caller ."
fun size(): Int { return n }	Returns the number of items in this queue .
"fun toXML(network: Network?): String? { val writer = StringWriter() writeXML(network, writer) writer.flush() return writer.toString() }"	Covert the network into xml .
private fun parseEntityAttribute(fieldName: String): String? { val m: Matcher = _fnPattern.matcher(fieldName) return if (m.find()) { m.group(1) } else null }	check whether this field is one entity attribute or not
"fun addScrapView(scrap: View, position: Int, viewType: Int) { if (viewTypeCount === 1) { currentScrapViews.put(position, scrap) } else { scrapViews.get(viewType).put(position, scrap) } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { scrap.setAccessibilityDelegate(null) } }"	Put a view into the ScrapViews list . These views are unordered .
fun AStart() {}	Construct the applet
fun dispose() { disposeColors() disposeImages() disposeFonts() disposeCursors() }	Dispose of cached objects and their underlying OS resources . This should only be called when the cached objects are no longer needed ( e.g . on application shutdown ) .
"protected fun bends(g1: Geo, g2: Geo?, g3: Geo?): Int { val bend: Double = g1.crossNormalize(g2).distance(g3) - Math.PI / 2.0 if (Math.abs(bend) < .0001) { return STRAIGHT } else { if (bend < 0) { return BENDS_LEFT } } return BENDS_RIGHT }"	Method that determines which way the angle between the three points bends .
fun eIsSet(featureID: Int): Boolean { when (featureID) { TypesPackage.PRIMITIVE_TYPE__DECLARED_ELEMENT_TYPE -> return declaredElementType != null TypesPackage.PRIMITIVE_TYPE__ASSIGNMENT_COMPATIBLE -> return assignmentCompatible != null TypesPackage.PRIMITIVE_TYPE__AUTOBOXED_TYPE -> return autoboxedType != null } return super.eIsSet(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"@Description(summary = ""Create h2client.jar with only the remote JDBC implementation."") fun jarClient() { compile(true, true, false) var files: FileList? = files(""temp"").exclude(""temp/org/h2/build/*"").exclude(""temp/org/h2/dev/*"") .exclude(""temp/org/h2/jaqu/*"").exclude(""temp/org/h2/java/*"") .exclude(""temp/org/h2/jcr/*"").exclude(""temp/org/h2/mode/*"") .exclude(""temp/org/h2/samples/*"").exclude(""temp/org/h2/test/*"").exclude(""*.bat"") .exclude(""*.sh"").exclude(""*.txt"").exclude(""*.DS_Store"") files = excludeTestMetaInfFiles(files) val kb: Long = jar(""bin/h2-client"" + getJarSuffix(), files, ""temp"") if (kb < 350 || kb > 450) { throw RuntimeException(""Expected file size 350 - 450 KB, got: $kb"") } }"	Create the h2client.jar . This only contains the remote JDBC implementation .
"fun Messages(name: String?) { this(null as Messages?, name) }"	Creates a messages bundle by full name .
fun providesSingletonInScope() { this@Binding.singletonInScope() isProvidingSingletonInScope = true }	to provide a singleton using the binding 's scope and reuse it inside the binding 's scope
fun dispose() { m_table.getColumn(m_field).removeColumnListener(this) }	"Dispose of this metadata , freeing any resources and unregistering any listeners ."
"fun updateUI() { super.updateUI() if (myTree != null) { myTree.updateUI() } javax.swing.LookAndFeel.installColorsAndFont( this, ""Tree.background"", ""Tree.foreground"", ""Tree.font"" ) }"	Overridden to message super and forward the method to the tree . Since the tree is not actually in the component hierarchy it will never receive this unless we forward it in this manner .
fun ResourceNotificationException(message: String?) { super(message) }	Creates a new < code > ResourceNotificationException < /code > object
fun variance(vector: DoubleArray): Double { var sum = 0.0 var sumSquared = 0.0 if (vector.size <= 1) { return 0 } for (i in vector.indices) { sum += vector[i] sumSquared += vector[i] * vector[i]  } val result = sumSquared - sum * sum / vector.size.toDouble() / (vector.size - 1).toDouble() return if (result < 0) { 0 } else { result } }	Computes the variance for an array of doubles .
fun taskClass(): Class<out Task?>? { return IgniteSinkTask::class.java }	Obtains a sink task class to be instantiated for feeding data into grid .
"fun createNode(path: String?, watch: Boolean, ephimeral: Boolean): String? { var createdNodePath: String? = null createdNodePath = try { val nodeStat: Stat = zooKeeper.exists(path, watch) if (nodeStat == null) { zooKeeper.create( path, ByteArray(0), Ids.OPEN_ACL_UNSAFE, if (ephimeral) CreateMode.EPHEMERAL_SEQUENTIAL else CreateMode.PERSISTENT ) } else { path } } catch (e: KeeperException) { throw IllegalStateException(e) } catch (e: InterruptedException) { throw IllegalStateException(e) } return createdNodePath }"	Create a zookeeper node
@Throws(ConfigurationError::class) fun findClassLoader(): ClassLoader? { val ss: SecuritySupport = SecuritySupport.getInstance() val context: ClassLoader = ss.getContextClassLoader() val system: ClassLoader = ss.getSystemClassLoader() var chain = system while (true) { if (context === chain) { val current: ClassLoader = ObjectFactory::class.java.getClassLoader() chain = system while (true) { if (current === chain) { return system } if (chain == null) { break } chain = ss.getParentClassLoader(chain) } return current } if (chain == null) { break } chain = ss.getParentClassLoader(chain) } return context }	Figure out which ClassLoader to use . For JDK 1.2 and later use the context ClassLoader .
"private fun updateProgress(progressLabel: String, progress: Int) { if (myHost != null && (progress != previousProgress || progressLabel) != previousProgressLabel) { myHost.updateProgress(progressLabel, progress) } previousProgress = progress previousProgressLabel = progressLabel }"	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
fun isCellEditable(anEvent: EventObject): Boolean { if (!m_mField.isEditable(false)) return false log.fine(m_mField.getHeader()) if (anEvent is MouseEvent && (anEvent as MouseEvent).getClickCount() < CLICK_TO_START) return false if (m_editor == null) createEditor() return true }	Ask the editor if it can start editing using anEvent . If editing can be started this method returns true . Previously called : MTable.isCellEditable
"@Throws(BadLocationException::class) fun applyAll(changes: Collection<IChange?>?) { val changesPerFile: Map<URI, List<IAtomicChange>> = organize(changes) for (currURI in changesPerFile.keySet()) { val document: IXtextDocument = getDocument(currURI) applyAllInSameDocument(changesPerFile[currURI], document) } }"	Applies all given changes .
fun beginApplyInterval() { intervalStartMillis = System.currentTimeMillis() endMillis = intervalStartMillis state = org.gradle.api.tasks.TaskState.apply }	Start an apply interval .
"fun updateDataset(source: CandleDataset?, seriesIndex: Int, newBar: Boolean) { requireNotNull(source) { ""Null source (CandleDataset)."" } for (i in 0 until this.getSeriesCount()) { val series: CandleSeries = this.getSeries(i) series.updateSeries( source.getSeries(seriesIndex), source.getSeries(seriesIndex).getItemCount() - 1, newBar ) } }"	Method updateDataset .
"fun optInt(key: String?): Int { return optInt(key, 0) }"	"Get an optional int value associated with a key , or zero if there is no such key or if the value is not a number . If the value is a string , an attempt will be made to evaluate it as a number ."
"@DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:30:28.318 -0500"", hash_original_method = ""FEDEC1668E99CC7AC8B63903F046C2E4"", hash_generated_method = ""270B33800028B49BD2EC75D7757AD67D"" ) protected fun onStartLoading() { if (mCursor != null)   deliverResult(mCursor) } if (takeContentChanged() || mCursor == null) { forceLoad() } }"	Starts an asynchronous load of the contacts list data . When the result is ready the callbacks will be called on the UI thread . If a previous load has been completed and is still valid the result may be passed to the callbacks immediately . Must be called from the UI thread
"@Throws(IOException::class) fun name(name: String?): JsonWriter? { if (name == null) { throw NullPointerException(""name == null"") } beforeName() string(name) return this }"	Encodes the property name .
"protected fun changeTimeBy(amount: Long) { changeTimeBy( amount, timeWrap, if (amount >= 0) TimerStatus.FORWARD else TimerStatus.BACKWARD ) }"	Call setTime with the amount given added to the current time . The amount should be negative if you are going backward through time . You need to make sure manageGraphics is called for the map to update . < p >
"@Throws(Exception::class) fun testCreateRenameNoClose() { if (dual) return create(igfs, paths(DIR, SUBDIR), null) var os: IgfsOutputStream? = null try { os = igfs.create(FILE, true) igfs.rename(FILE, FILE2) os.close() } finally { javax.swing.text.html.HTML.Tag.U.closeQuiet(os) } }"	Test rename on the file when it was opened for write ( create ) and is not closed yet .
override fun equals(other: Any?): Boolean { if (other == null) return false if (javaClass != other.javaClass) { return false } val that: HostPort = other as HostPort return port === that.port && host!!.equals(that.host) }	"returns true if the two objects are equals , false otherwise ."
fun ensureParentFolderHierarchyExists(folder: IFolder) { val parent: IContainer = folder.getParent() if (parent is IFolder) { ensureFolderHierarchyExists(parent as IFolder) } }	Ensures the given folder 's parent hierarchy is created if they do not already exist .
private fun Trees() { throw UnsupportedOperationException() }	Utility classes should not be instantiated .
"private fun drawLine(iter: DBIDRef): Element? { val path = SVGPath() val obj: SpatialComparable = relation.get(iter) val dims: Int = proj.getVisibleDimensions() var drawn = false var valid = 0 var prevpos = Double.NaN for (i in 0 until dims) { val d: Int = proj.getDimForAxis(i) val minPos: Double = proj.fastProjectDataToRenderSpace(obj.getMin(d), i) if (minPos != minPos) { valid = 0 continue } ++valid if (valid > 1) { if (valid == 2) { path.moveTo(getVisibleAxisX(d - 1), prevpos) } path.lineTo(getVisibleAxisX(d), minPos) drawn = true } prevpos = minPos } valid = 0 for (i in dims - 1 downTo 0) { val d: Int = proj.getDimForAxis(i) val maxPos: Double = proj.fastProjectDataToRenderSpace(obj.getMax(d), i) if (maxPos != maxPos) { valid = 0 continue } ++valid if (valid > 1) { if (valid == 2) { path.moveTo(getVisibleAxisX(d + 1), prevpos) } path.lineTo(getVisibleAxisX(d), maxPos) drawn = true } prevpos = maxPos } return if (!drawn) { null } else path.makeElement(svgp) }"	Draw a single line .
"@Throws(Exception::class) fun testExceptionWithEmpty() { val mapper = ObjectMapper() try { val result: Any = mapper.readValue("" "", Any::class.java) fail(""Expected an exception, but got result value: $result"") } catch (e: Exception) { verifyException(e, EOFException::class.java, ""No content"") } }"	Simple test to check behavior when end-of-stream is encountered without content . Should throw EOFException .
"@Throws(SQLException::class) fun dropUser(user: User, ignore: Boolean) { val sql = String.format(""drop user %s"", user.getLogin()) try { execute(sql) } catch (e: SQLException) { if (!ignore) { throw e } else if (logger.isDebugEnabled()) { logger.debug(""Drop user failed: $sql"", e) } } }"	"Drops user , ignoring errors if desired by caller ."
"fun loadSoundEffects(): Boolean { var attempts = 3 val reply = LoadSoundEffectReply() synchronized(reply) { sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0) while (reply.mStatus === 1 && attempts-- > 0) { try { reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS) } catch (e: InterruptedException) { Log.w(TAG, ""loadSoundEffects Interrupted while waiting sound pool loaded."") } } } return reply.mStatus === 0 }"	Loads samples into the soundpool . This method must be called at first when sound effects are enabled
"fun gcd(p: Int, q: Int): Int { return if (q == 0) { p } else gcd(q, p % q) }"	Computes the Greatest Common Devisor of integers p and q .
"fun sort(keys: IntArray?, values: IntArray?, offset: Int, length: Int) { hybridsort(keys, values, offset, offset + length - 1) }"	"Sorts a range from the keys in an increasing order . Elements key [ i ] and values [ i ] are always swapped together in the corresponding arrays . < p > A mixture of several sorting algorithms is used : < p > A radix sort performs better on the numeric data we sort , but requires additional storage to perform the sorting . Therefore only the not-very-large parts produced by a quick sort are sorted with radix sort . An insertion sort is used to sort the smallest arrays , where the the overhead of the radix sort is also bigger"
fun isRegistered(name: javax.management.ObjectName?): Boolean { return mbsInterceptor.isRegistered(name) }	"Checks whether an MBean , identified by its object name , is already registered with the MBean server ."
"private fun startItemListItem(result: StringBuilder, rootId: String, itemId: String) { result.append(""<div class=\""subtree\"">"") result.append(""<div class=\""alone $itemId\"" id=\""alone_$rootId:$itemId\"">"") }"	Called to start adding an item to an item list .
@Throws(IOException::class) fun write(ios: javax.imageio.stream.ImageOutputStream?) { }	Writes the data for this segment to the stream in valid JPEG format .
fun PatternEveryExpr() {}	"Ctor - for use to create a pattern expression tree , without pattern child expression ."
"private fun tryQueueCurrentBuffer(elapsedWaiting: Long): Boolean { if (currentBuffer.isEmpty()) return true return if (isOpen && neverPubQueue.size() < neverPubCapacity) { neverPubQueue.add(currentBuffer) totalQueuedRecords.addAndGet(currentBuffer.sizeRecords()) totalQueuedBuffers.incrementAndGet() onQueueBufferSuccess(currentBuffer, elapsedWaiting) currentBuffer = RecordBuffer(flow) true } else if (elapsedWaiting > 0) { onQueueBufferTimeout(currentBuffer, elapsedWaiting) false } else false }"	Keep private . Call only when holding lock .
"private fun writeKeysWithPrefix(prefix: String, exclude: String) { for (key in keys) { if (key.startsWith(prefix) && !key.startsWith(exclude)) { ps.println(key + ""="" + prop.getProperty(key)) } } ps.println() }"	writes all keys starting with the specified prefix and not starting with the exclude prefix in alphabetical order .
"fun ProtocolInfo( name: String, connectionForms: Collection<Form?>, sharingProfileForms: Collection<Form?> ) { name = name connectionForms = connectionForms sharingProfileForms = sharingProfileForms }"	Creates a new ProtocolInfo having the given name and forms . The given collections of forms are used to describe the parameters for connections and sharing profiles respectively .
fun prepare(sql: String?): Prepared? {val p: Prepared = parse(sql)p.prepare()if (currentTokenType !== END) {throw getSyntaxError()} return p }	Parse the statement and prepare it for execution .
"fun logging(msg1: String?, msg2: String?, msg3: String?) { print(msg1) print("" "") print(msg2) print("" "") println(msg3)"	Prints a log message .
"fun initQueryStringHandlers() { this.transport = SimpleTargetedChain() this.transport.setOption(""qs.list"", ""org.apache.axis.transport.http.QSListHandler"") this.transport.setOption(""qs.method"", ""org.apache.axis.transport.http.QSMethodHandler"") this.transport.setOption(""qs.wsdl"", ""org.apache.axis.transport.http.QSWSDLHandler"") }"	Initialize a Handler for the transport defined in the Axis server config . This includes optionally filling in query string handlers .
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 13:00:42.071 -0500"", hash_original_method = ""236CE70381CAE691CF8D03F3D0A7E2E8"", hash_generated_method = ""34048EFAD324F63AAF648818713681BB"" ) fun toUpperCase(string: String): String? { var changed = false val chars = string.toCharArray() for (i in chars.indices) { val ch = chars[i] if ('a' <= ch && 'z' >= ch) { changed = true chars[i] = (ch.code - 'a'.code + 'A'.code).toChar() } } return if (changed) { String(chars) } else string }"	A locale independent version of toUpperCase .
"fun HTMLForm(htmlC: HTMLComponent, action: String?, method: String?, encType: String) { htmlC = htmlC action = htmlC.convertURL(action) encType = encType if (htmlC.getHTMLCallback() != null) { val linkProps: Int = htmlC.getHTMLCallback().getLinkProperties(htmlC, action) if (linkProps and HTMLCallback.LINK_FORBIDDEN !== 0) { action = null } } this.isPostMethod = method != null && method.equals(""post"", ignoreCase = true) }"	Constructs the HTMLForm
"fun CurlInterceptor(logger: jdk.nashorn.internal.runtime.logging.Loggable, limit: Long) { logger = logger limit = limit }"	Interceptor responsible for printing curl logs
override fun toString(): String? { return java.lang.String.valueOf(value) }	Returns the String value of this mutable .
fun unRegisterImpulseConstraint(con: ImpulseConstraint) { collisionResponseRows -= (con as ImpulseConstraint).GetCollisionResponseRows() collisions.remove(con) }	Un-registers an impulse constraint with the constraint engine
"fun Index(node: Node<K?, V?>, down: Index<K?, V?>, right: Index<K?, V?>) { node = node down = down right = right }"	Creates index node with given values .
fun isInBoundsX(x: Float): Boolean { return if (isInBoundsLeft(x) && isInBoundsRight(x)) true else false }	BELOW METHODS FOR BOUNDS CHECK
fun caseAnonymous_constraint_1_(`object`: Anonymous_constraint_1_?): T? { return null }	Returns the result of interpreting the object as an instance of ' < em > Anonymous constraint 1 < /em > ' . < ! -- begin-user-doc -- > This implementation returns null ; returning a non-null result will terminate the switch . < ! -- end-user-doc -- >
fun CProjectLoaderReporter(listeners: ListenerProvider<IProjectListener?>) { m_listeners = listeners }	Creates a new reporter object .
"@Throws(InvalidArgument::class,NotFound::class,InvalidSession::class,StorageFault::class,NotImplemented::class) fun queryUniqueIdentifiersForLuns(arrayUniqueId: String): Array<String?>? { val methodName = ""queryUniqueIdentifiersForLuns(): "" log.info(methodName + ""Entry with arrayUniqueId["" + arrayUniqueId + ""]"") sslUtil.checkHttpRequest(true, true) val sosManager: SOSManager = contextManager.getSOSManager() val ids: Array<String?> = sosManager.queryUniqueIdentifiersForLuns(arrayUniqueId) log.info(methodName + ""Exit returning ids of size["" + ids.size + ""]"") return ids }"	Returns unique identifiers for LUNs for the give array Id
"fun onCreateOptionsMenu(menu: Menu): Boolean { mOpsOptionsMenu = menu val inflater: MenuInflater = getMenuInflater() inflater.inflate(R.menu.ops_options_menu, menu) return true }"	Inflates the Operations ( `` Ops '' ) Option Menu .
protected fun PackageImpl() { super() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun fillAttributeSet(attrSet: MutableSet<*>) { attrSet.add(""lang"") }"	Fills the given set with the attribute names found in this selector .
"fun addColumn(columnFamily: String?, columnQualifier: String?) { var columns: MutableSet<String?> = this.columnFamilies.get(columnFamily) if (columns == null) { columns = HashSet() } columns.add(columnQualifier) this.columnFamilies.put(columnFamily, columns) }"	Add column family and column qualifier to be extracted from tuple
"fun ofString(name: String?, description: String?): Field<String?>? { return Field(name, String::class.java, description) }"	Break down metrics by string . < p > Each unique string will allocate a new submetric . < b > Do not use user content as a field value < /b > as field values are never reclaimed .
"fun OMPoint(lat: Double, lon: Double, radius: Int) { setRenderType(RENDERTYPE_LATLON) set(lat, lon) radius = radius }"	"Create an OMPoint at a lat/lon position , with the specified radius ."
"@Throws(GamaRuntimeException::class) private fun saveMicroAgents(scope: IScope, agent: IMacroAgent) { innerPopulations = THashMap<String, List<SavedAgent>>() for (microPop in agent.getMicroPopulations()) { val savedAgents: MutableList<SavedAgent> = ArrayList<SavedAgent>() val it: Iterator<IAgent?> = microPop.iterator() while (it.hasNext()) { savedAgents.add(SavedAgent(scope, it.next())) } innerPopulations.put(microPop.getSpecies().getName(), savedAgents) } }"	Recursively save micro-agents of an agent .
"fun GenerationResult( parent: jdk.nashorn.tools.Shell?, style: Int,location: IPath,target: IResource) {super(parent, style) location = location this.targetResource = target setText(""EvoSuite Result"") }"	Create the dialog .
"fun run() { ActivationLibrary.deactivate(this, getID()) }"	"Thread to deactivate object . First attempts to make object inactive ( via the inactive method ) . If that fails ( the object may still have pending/executing calls ) , then unexport the object forcibly ."
"private fun createImageLink( AD_Language: String, name: String, js_command: String, enabled: Boolean, pressed: Boolean ): a? { var js_command: String? = js_command val img = a(""#"", jdk.tools.jlink.internal.JlinkTask.createImage(AD_Language, name)) if (!pressed || !enabled) img.setID(""imgButtonLink"") else img.setID(""imgButtonPressedLink"") if (js_command == null) js_command = ""'Submit'"" if (js_command.length > 0 && enabled) { if (js_command.startsWith(""startPopup"")) img.setOnClick(js_command) else img.setOnClick( ""SubmitForm('$name', $js_command,'toolbar');return false;"" ) } img.setClass(""ToolbarButton"") img.setOnMouseOver(""window.status='$name';return true;"") img.setOnMouseOut(""window.status='';return true;"") img.setOnBlur(""this.hideFocus=false"") return img }"	"Create Image with name , id of button_name and set P_Command onClick"
"fun CassandraStatus(mode: CassandraMode,joined: Boolean,rpcRunning: Boolean,nativeTransportRunning: Boolean,gossipInitialized: Boolean,gossipRunning: Boolean,hostId: String,endpoint: String,tokenCount: Int,dataCenter: String,rack: String,version: String) {mode = mode joined = joined rpcRunning = rpcRunning nativeTransportRunning = nativeTransportRunning gossipInitialized = gossipInitialized gossipRunning = gossipRunning hostId = hostId endpoint = endpoint tokenCount = tokenCount dataCenter = dataCenter rack = rack version = version }"	Constructs a CassandraStatus .
"@Throws(GenericEntityException::class) fun checkDataSource( modelEntities: Map<String?, ModelEntity?>?, messages: List<String >?, addMissing: Boolean ) { genericDAO.checkDb(modelEntities, messages, addMissing) }"	"Check the datasource to make sure the entity definitions are correct , optionally adding missing entities or fields on the server"
"fun string2HashMap(paramString: String): HashMap<String, String>? { val params: HashMap<String, String> = HashMap() for (keyValue in paramString.split("" *& *"".toRegex()).dropLastWhile { it.isEmpty() } .toTypedArray()) { val pairs = keyValue.split("" *= *"".toRegex(), limit = 2).toTypedArray() params[pairs[0]] = if (pairs.size == 1) """" else pairs[1] } return params }"	"Convert key=value type String to HashMap < String , String >"
"@LargeTest @Throws(Exception::class) fun testMediaVideoItemRenderingModes() { val videoItemFileName: String = INPUT_FILE_PATH + ""H263_profile0_176x144_15fps_256kbps_AACLC_32kHz_128kbps_s_0_26.3gp"" val videoItemRenderingMode: Int = MediaItem.RENDERING_MODE_BLACK_BORDER var flagForException = false val mediaVideoItem1: MediaVideoItem = mVideoEditorHelper.createMediaItem( mVideoEditor, ""mediaVideoItem1"", videoItemFileName, videoItemRenderingMode ) mVideoEditor.addMediaItem(mediaVideoItem1)  mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING) assertEquals( ""MediaVideo Item rendering Mode"", MediaItem.RENDERING_MODE_CROPPING, mediaVideoItem1.getRenderingMode() ) try { mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING + 911) } catch (e: IllegalArgumentException) { flagForException = true } assertTrue(""Media Item Invalid rendering Mode"", flagForException) flagForException = false try { mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_BLACK_BORDER - 11) } catch (e: IllegalArgumentException) { flagForException = true } assertTrue(""Media Item Invalid rendering Mode"", flagForException) assertEquals( ""MediaVideo Item rendering Mode"", MediaItem.RENDERING_MODE_CROPPING, mediaVideoItem1.getRenderingMode() ) mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_STRETCH) assertEquals( ""MediaVideo Item rendering Mode"", MediaItem.RENDERING_MODE_STRETCH, mediaVideoItem1.getRenderingMode() ) }"	To test creation of Media Video Item with Set and Get rendering Mode
fun visitTree(tree: com.sun.tools.javac.tree.JCTree?) {}	Default member enter visitor method : do nothing
"private fun createControls(): EventLogControlPanel? { val c = EventLogControlPanel() c.addHeading(""connections"") conUpCheck = c.addControl(""up"") conDownCheck = c.addControl(""down"") c.addHeading(""messages"") msgCreateCheck = c.addControl(""created"") msgTransferStartCheck = c.addControl(""started relay"") msgRelayCheck = c.addControl(""relayed"") msgDeliveredCheck = c.addControl(""delivered"") msgRemoveCheck = c.addControl(""removed"") msgDropCheck = c.addControl(""dropped"") msgAbortCheck = c.addControl(""aborted"") return c }"	Creates a control panel for the log
fun type(): String? { return type }	Returns the type of document to get the term vector for .
"fun `test_getIterator$Ljava_text_AttributedCharacterIterator$AttributeII`() { val test = ""Test string"" try { val hm: MutableMap<AttributedCharacterIterator.Attribute?, String> = HashMap<AttributedCharacterIterator.Attribute?, String>() val aci: Array<AttributedCharacterIterator.Attribute?> = arrayOfNulls<AttributedCharacterIterator.Attribute>(3) aci[0] = TestAttributedCharacterIteratorAttribute(""att1"") aci[1] = TestAttributedCharacterIteratorAttribute(""att2"") aci[2] = TestAttributedCharacterIteratorAttribute(""att3"") hm[aci[0]] = ""value1"" hm[aci[1]] = ""value2"" val attrString = AttributedString(test) attrString.addAttributes(hm, 2, 4) val it: AttributedCharacterIterator = attrString.getIterator(aci, 1, 5) assertTrue(""Incorrect iteration on AttributedString"", it.getAttribute(aci[0]) == null) assertTrue(""Incorrect iteration on AttributedString"", it.getAttribute(aci[1]) == null) assertTrue(""Incorrect iteration on AttributedString"", it.getAttribute(aci[2]) == null) it.next() assertTrue( ""Incorrect iteration on AttributedString"", it.getAttribute(aci[0]).equals(""value1"") ) assertTrue( ""Incorrect iteration on AttributedString"", it.getAttribute(aci[1]).equals(""value2"") ) assertTrue(""Incorrect iteration on AttributedString"", it.getAttribute(aci[2]) == null) try { attrString.getIterator(aci, -1, 5) fail(""IllegalArgumentException is not thrown."") } catch (iae: IllegalArgumentException) { } }try { attrString.getIterator(aci, 6, 5) fail(""IllegalArgumentException is not thrown."") } catch (iae: IllegalArgumentException) { } try { attrString.getIterator(aci, 3, 2) fail(""IllegalArgumentException is not thrown."") } catch (iae: IllegalArgumentException) { } } catch (e: Exception) { fail(""Unexpected exceptiption $e"") } }"	"java.text.AttributedString # getIterator ( AttributedCharacterIterator.Attribute [ ] , int , int ) Test of method java.text.AttributedString # getIterator ( AttributedCharacterIterator.Attribute [ ] , int , int ) ."
private fun newplan(plan: TransformationPlan) { if (plan.replaces(plan)) { plan = plan } }	Install a new plan iff it 's more drastic than the existing plan
"private fun buildSmallContingencyTables(): SmallContingencyTables? { val allLabelSet: MutableSet<String> = TreeSet() for (outcome in id2Outcome.getOutcomes()) { allLabelSet.addAll(outcome.getLabels()) } val labelList: List<String> = ArrayList(allLabelSet) val numberOfLabels = labelList.size val counterIncreaseValue = 1.0 val smallContingencyTables = SmallContingencyTables(labelList) for (allLabelsClassId in 0 until numberOfLabels) { for (outcome in id2Outcome.getOutcomes()) { val localClassId: Int = outcome.getReverseLabelMapping(labelList).get(allLabelsClassId) val threshold: Double = outcome.getBipartitionThreshold() var goldValue: Double var predictionValue: Double if (localClassId == -1) { goldValue = 0.0 predictionValue = 0.0 } else { goldValue = outcome.getGoldstandard().get(localClassId) predictionValue = outcome.getPrediction().get(localClassId) } if (goldValue >= threshold) { if (predictionValue >= threshold) { smallContingencyTables.addTruePositives( allLabelsClassId, counterIncreaseValue ) } else { smallContingencyTables.addFalseNegatives( allLabelsClassId, counterIncreaseValue ) } } else { if (predictionValue >= threshold) { smallContingencyTables.addFalsePositives( allLabelsClassId, counterIncreaseValue ) } else { smallContingencyTables.addTrueNegatives( allLabelsClassId, counterIncreaseValue ) } } } } return smallContingencyTables }"	build small contingency tables ( a small contingency table for each label ) from id2Outcome
"fun commandTopic(command: String?): String? { var command = command if (command == null) { command = ""+"" } return cmdTopic.replace(""{COMMAND}"", command) }"	Get the MQTT topic for a command .
fun hasExtension(extension: String?): Boolean { return if (TextUtils.isEmpty(extension)) { false } else extensionToMimeTypeMap.containsKey(extension) }	Returns true if the given extension has a registered MIME type .
"@Before fun onBefore() { tut = TransportUnitType(""TUT"") loc1 = Location(LocationPK(""AREA"", ""ASL"", ""X"", ""Y"", ""Z"")) loc2 = Location(LocationPK(""ARE2"", ""ASL2"", ""X2"", ""Y2"", ""Z2"")) product = Product(""tttt"") entityManager.persist(product) entityManager.persist(tut) entityManager.persist(loc1) entityManager.persist(loc2) tu = TransportUnit(""TEST"") tu.setTransportUnitType(tut) tu.setActualLocation(loc1) entityManager.persist(tu) entityManager.flush() }"	Setup some test data .
fun beforeRerunningIndexCreationQuery() {}	"Asif : Called just before IndexManager executes the function rerunIndexCreationQuery . After this function gets invoked , IndexManager will iterate over all the indexes of the region making the data maps null & re running the index creation query on the region . The method of Index Manager gets executed from the clear function of the Region"
fun buffered(): Float { return if (totalSize > 0) Futures.getUnchecked(response).cache.cacheSize() / totalSize as Float else -1 }	"Returns the percentage that is buffered , or -1 , if unknown"
"fun accept(dir: File?, name: String?): Boolean { return accept(File(dir, name)) }"	Returns true if the file in the given directory with the given name should be accepted .
@Throws(Exception::class) @JvmStatic fun main(a: Array<String>) { TestBase.createCaller().init().test() }	Run just this test .
fun isFieldPresent(field: String?): Boolean { return fields.containsKey(field) }	Checks if the given field is present in this extension because not every field is mandatory ( according to scim 2.0 spec ) .
"fun mapToStr(map: Map<out Any?, Any?>?): String? { if (map == null) return null val buf = StringBuilder() var first = true for (entry in map.entrySet()) { val key: Any = entry.getKey() val value: Any = entry.getValue() if (key !is String || value !is String) continue var encodedName: String? = null try { encodedName = URLEncoder.encode(key, ""UTF-8"") } catch (e: UnsupportedEncodingException) { Debug.logError(e, module) } var encodedValue: String? = null try { encodedValue = URLEncoder.encode(value, ""UTF-8"") } catch (e: UnsupportedEncodingException) { Debug.logError(e, module) } if (first) first = false else buf.append(""|"") buf.append(encodedName) buf.append(""="") buf.append(encodedValue) } return buf.toString() }"	Creates an encoded String from a Map of name/value pairs ( MUST BE STRINGS ! )
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 13:00:42.074 -0500"", hash_original_method = ""002C3CFFC816A38E005543BB54E228FD"", hash_generated_method = ""24D6A751F50FC61EC42FBA4D0FC608F4"" ) fun toLowerCase(string: String): String? { var changed = false val chars = string.toCharArray() for (i in chars.indices) { val ch = chars[i] if ('A' <= ch && 'Z' >= ch) { changed = true chars[i] = (ch.code - 'A'.code + 'a'.code).toChar() } } return if (changed) { String(chars) } else string }"	A locale independent version of toLowerCase .
"fun numberToWords(num: Int): String? { var num = num if (num == 0) { return LESS_THAN_TWENTY.get(0) } var i = 0 val res = StringBuilder() while (num > 0) { if (num % 1000 != 0) { res.insert(0, "" "") res.insert(0, THOUSANDS.get(i)) res.insert(0, helper(num % 1000)) } num /= 1000 i++ } return res.toString().trim { it <= ' ' } }"	"Math , String . Try to find the pattern first . The numbers less than 1000 , e.g . xyz , can be x Hundred y '' ty '' z . The numbers larger than 1000 , we need to add thousand or million or billion . Given a number num , we pronounce the least significant digits first . Then concat the result to the end to next three least significant digits . So the recurrence relation is : Next result of num = the pronunciation of least three digits + current result of num After that , remove those three digits from number . Stop when number is 0 ."
fun hasLat(): Boolean { return super.hasAttribute(LAT) }	Returns whether it has the Latitude .
"fun test_ConstructorIF() { val hs2 = HashSet<Any>(5, 0.5.toFloat()) assertEquals(""Created incorrect HashSet"", 0, hs2.size()) try { HashSet(0, 0) } catch (e: IllegalArgumentException) { return } fail(""Failed to throw IllegalArgumentException for initial load factor <= 0"") }"	"java.util.HashSet # HashSet ( int , float )"
"private fun emitCharMapArray(): Int { val cl: CharClasses = parser.getCharClasses() if (cl.getMaxCharCode() < 256) { emitCharMapArrayUnPacked() return 0 } intervals = cl.getIntervals() println("""") println("" /** "") println("" * Translates characters to character classes"") println("" */"") println("" private static final String ZZ_CMAP_PACKED = "") var n = 0 print("" \"""") var i = 0 var numPairs = 0 var count: Int var value: Int while (i < intervals.length) { count = intervals.get(i).end - intervals.get(i).start + 1 value = colMap.get(intervals.get(i).charClass) while (count > 0xFFFF) { printUC(0xFFFF) printUC(value) count -= 0xFFFF numPairs++ n++ }  numPairs++ printUC(count) printUC(value) if (i < intervals.length - 1) { if (++n >= 10) { println(""\""+"") print("" \"""") n = 0 } } i++ } println(""\"";"") println() println("" /** "") println("" * Translates characters to character classes"") println("" */"") println("" private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);"") println() return numPairs }"	"Returns the number of elements in the packed char map array , or zero if the char map array will be not be packed . This will be more than intervals.length if the count for any of the values is more than 0xFFFF , since the number of char map array entries per value is ceil ( count / 0xFFFF )"
fun size(): Int { return mSize }	Returns the number of key-value mappings that this SparseDoubleArray currently stores .
"fun depends(parent: Int, child: Int) { dag.addNode(child) dag.addNode(parent) dag.addEdge(parent, child) }"	"Adds a dependency relation ship between two variables that will be in the network . The integer value corresponds the the index of the i'th categorical variable , where the class target 's value is the number of categorical variables ."
fun DiscreteTransfer(tableValues: IntArray) { tableValues = tableValues this.n = tableValues.size }	The input is an int array which will be used later to construct the lut data
"fun roundTo(`val`: Float, prec: Float): Float { return floor(`val` / prec + 0.5f) * prec }"	Rounds a single precision value to the given precision .
"fun <K, V> readKeyValues( topic: String?, consumerConfig: Properties?, maxMessages: Int ): List<KeyValue<K, V>>? { val consumer: KafkaConsumer<K, V> = KafkaConsumer(consumerConfig) consumer.subscribe(Collections.singletonList(topic)) val pollIntervalMs = 100 val maxTotalPollTimeMs = 2000 var totalPollTimeMs = 0 val consumedValues: MutableList<KeyValue<K, V>> = ArrayList() while (totalPollTimeMs < maxTotalPollTimeMs && continueConsuming( consumedValues.size, maxMessages ) ) { totalPollTimeMs += pollIntervalMs val records: ConsumerRecords<K, V> = consumer.poll(pollIntervalMs) for (record in records) { consumedValues.add(KeyValue(record.key(), record.value())) } } consumer.close() return consumedValues }"	Returns up to ` maxMessages ` by reading via the provided consumer ( the topic ( s ) to read from are already configured in the consumer ) .
private fun segment(key: Any): Int { return Math.abs(key.hashCode() % size) }	This method performs the translation of the key hash code to the segment index within the list . Translation is done by acquiring the modulus of the hash and the list size .
"private fun handleStateLeaving(endpoint: InetAddress) { val tokens: Collection<Token> = getTokensFor(endpoint) if (logger.isDebugEnabled()) logger.debug( ""Node {} state leaving, tokens {}"", endpoint, tokens ) if (!tokenMetadata.isMember(endpoint)) { logger.info(""Node {} state jump to leaving"", endpoint) tokenMetadata.updateNormalTokens(tokens, endpoint) } else if (!tokenMetadata.getTokens(endpoint).containsAll(tokens)) { logger.warn(""Node {} 'leaving' token mismatch. Long network partition?"", endpoint) tokenMetadata.updateNormalTokens(tokens, endpoint) } tokenMetadata.addLeavingEndpoint(endpoint) PendingRangeCalculatorService.instance.update() }"	Handle node preparing to leave the ring
"fun MAttributeInstance( ctx: Properties?, M_Attribute_ID: Int, M_AttributeSetInstance_ID: Int, BDValue: BigDecimal?, trxName: String? ) { super(ctx, 0, trxName) setM_Attribute_ID(M_Attribute_ID) setM_AttributeSetInstance_ID(M_AttributeSetInstance_ID) setValueNumber(BDValue) }"	Number Value Constructior
"fun supportsPositionedUpdate(): Boolean { debugCodeCall(""supportsPositionedUpdate"") return true }"	Returns whether positioned updates are supported .
"private fun prepareMapping(index: String, defaultMappings: Map<String, Any>): Boolean { var success = true for (stringObjectEntry in defaultMappings.entrySet()) { val mapping = stringObjectEntry.getValue() as Map<String, Any> ?: throw RuntimeException(""type mapping not defined"") val putMappingRequestBuilder: PutMappingRequestBuilder = client.admin().indices().preparePutMapping().setIndices(index) putMappingRequestBuilder.setType(stringObjectEntry.getKey()) putMappingRequestBuilder.setSource(mapping) if (log.isLoggable(Level.FINE)) { log.fine(""Elasticsearch create mapping for index '"" + index + "" and type '"" + stringObjectEntry.getKey() + ""': "" + mapping) } val resp: PutMappingResponse = putMappingRequestBuilder.execute().actionGet() if (resp.isAcknowledged()) { if (log.isLoggable(Level.FINE)) { log.fine(""Elasticsearch mapping for index '"" + index + "" and type '"" + stringObjectEntry.getKey() + ""' was acknowledged"") } } else { success = false log.warning(""Elasticsearch mapping creation was not acknowledged for index '"" + index + "" and type '"" + stringObjectEntry.getKey() + ""'"") } } return success }"	This method applies the supplied mapping to the index .
fun disableOcr() { if (!ocrDisabled) { excludeParser(TesseractOCRParser::class.java) ocrDisabled = true pdfConfig.setExtractInlineImages(false) } }	Disable OCR . This method only has an effect if Tesseract is installed .
"fun eInverseRemove( otherEnd: InternalEObject?, featureID: Int, msgs: NotificationChain? ): NotificationChain? { when (featureID) { DatatypePackage.DICTIONARY_PROPERTY_TYPE__KEY_TYPE -> return basicSetKeyType(null, msgs) DatatypePackage.DICTIONARY_PROPERTY_TYPE__VALUE_TYPE -> return basicSetValueType( null, msgs ) } return super.eInverseRemove(otherEnd, featureID, msgs) }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
@JvmStatic fun main(args: Array<String>) { Am().run(args)	Command-line entry point .
fun removeAllHighlights() { }	Removes all highlights .
fun init() { val p: Properties? p = try { System.getProperties() }  catch (ace: AccessControlException) { Properties() } init(p) }	Initialize debugging from the system properties .
fun bySecond(vararg seconds: Int?): Builder? { return bySecond(Arrays.asList(seconds)) }	Adds one or more BYSECOND rule parts .
fun CakePHP3CustomizerPanel() { initComponents() init() }	Creates new form CakePHP3CustomizerPanel
"private fun updateProgress(progressLabel: String, progress: Int) { if (myHost != null && (progress != previousProgress || progressLabel) != previousProgressLabel) { myHost.updateProgress(progressLabel, progress) } previousProgress = progress previousProgressLabel = progressLabel }"	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
fun first(): Char { pos = 0 return current() }	Sets the position to getBeginIndex ( ) and returns the character at that position .
@Benchmark @Throws(IOException::class) fun test4_UsingKeySetAndForEach(): Long { var i: Long = 0 for (key in map.keySet()) { i += key + map.get(key) } return i }	4 . Using keySet and foreach
fun eUnset(featureID: Int) { when (featureID) { N4JSPackage.N4_FIELD_DECLARATION__DECLARED_TYPE_REF -> { setDeclaredTypeRef(null as TypeRef?) return } N4JSPackage.N4_FIELD_DECLARATION__BOGUS_TYPE_REF -> { setBogusTypeRef(null as TypeRef?) return } N4JSPackage.N4_FIELD_DECLARATION__DECLARED_NAME -> { setDeclaredName(null as LiteralOrComputedPropertyName?) return } N4JSPackage.N4_FIELD_DECLARATION__DEFINED_FIELD -> { setDefinedField(null as TField?) return } N4JSPackage.N4_FIELD_DECLARATION__EXPRESSION -> { setExpression(null as Expression?) return } } super.eUnset(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"private fun StringTextStore(text: String?) { super() fText = text ?: """" fCopyLimit = if (fText.length() > SMALL_TEXT_LIMIT) fText.length() / 2 else 0 }"	Create a text store with initial content .
"fun incompleteGammaP(a: Double, x: Double): Double { return incompleteGamma(x, a, lnGamma(a)) }"	"Incomplete Gamma function P ( a , x ) = 1-Q ( a , x ) ( a cleanroom implementation of Numerical Recipes gammp ( a , x ) ; in Mathematica this function is 1-GammaRegularized )"
"@Scheduled(fixedDelay = 60000) fun controlHerdJmsMessageListener() { try { val jmsMessageListenerEnabled: Boolean = java.lang.Boolean.valueOf(configurationHelper.getProperty(ConfigurationValue.JMS_LISTENER_ENABLED)) val registry: JmsListenerEndpointRegistry = ApplicationContextHolder.getApplicationContext().getBean( ""org.springframework.jms.config.internalJmsListenerEndpointRegistry"", JmsListenerEndpointRegistry::class.java ) val jmsMessageListenerContainer: MessageListenerContainer = registry.getListenerContainer(HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING) LOGGER.debug( ""controlHerdJmsMessageListener(): {}={} jmsMessageListenerContainer.isRunning()={}"", ConfigurationValue.JMS_LISTENER_ENABLED.getKey(), jmsMessageListenerEnabled, jmsMessageListenerContainer.isRunning() ) if (!jmsMessageListenerEnabled && jmsMessageListenerContainer.isRunning()) { LOGGER.info(""controlHerdJmsMessageListener(): Stopping the herd JMS message listener ..."") jmsMessageListenerContainer.stop() LOGGER.info(""controlHerdJmsMessageListener(): Done"") } else if (jmsMessageListenerEnabled && !jmsMessageListenerContainer.isRunning()) { LOGGER.info(""controlHerdJmsMessageListener(): Starting the herd JMS message listener ..."") jmsMessageListenerContainer.start() LOGGER.info(""controlHerdJmsMessageListener(): Done"") } } catch (e: Exception) { LOGGER.error( ""controlHerdJmsMessageListener(): Failed to control the herd Jms message listener service."", e ) } }"	"Periodically check the configuration and apply the action to the herd JMS message listener service , if needed ."
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2014-08-13 13:14:13.408 -0400"", hash_original_method = ""FC36FCA077BB9356BFDFCA10D99D0311"", hash_generated_method = ""2430FCC224E47ADC0C94FB89530AAC4A"" ) fun AnnotationTypeMismatchException(element: Method, foundType: String) { super(""The annotation element $element doesn't match the type $foundType"") element = element foundType = foundType }"	Constructs an instance for the given type element and the type found .
"@Throws(java.awt.dnd.InvalidDnDOperationException::class) fun startDrag( trigger: java.awt.dnd.DragGestureEvent?, dragCursor: Cursor?, transferable: java.awt.datatransfer.Transferable?, dsl: java.awt.dnd.DragSourceListener? ) { startDrag(trigger, dragCursor, null, null, transferable, dsl, null) }"	"Start a drag , given the < code > DragGestureEvent < /code > that initiated the drag , the initial < code > Cursor < /code > to use , the < code > Transferable < /code > subject data of the drag , and the < code > DragSourceListener < /code > . < P >"
fun dynamicStartCache(){ }	Dynamically starts cache .
"private fun createFieldMenu(): HtmlSelectOneMenu? { val field = HtmlSelectOneMenu() val children: MutableList<*> = field.getChildren() children.add(createSelectItem(""Subject"")) children.add(createSelectItem(""Sender"")) children.add(createSelectItem(""Date"")) children.add(createSelectItem(""Priority"")) children.add(createSelectItem(""Status"")) children.add(createSelectItem(""To"")) children.add(createSelectItem(""Cc"")) children.add(createSelectItem(""To or Cc"")) return field }"	Creates the menu that allows the user to select a field .
"public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }"	Closes the disk cache associated with this ImageCache object . Note that this includes disk access so this should not be executed on the main/UI thread .
"fun close() { synchronized(mDiskCacheLock) { if (mDiskLruCache != null) { try { if (!mDiskLruCache.isClosed()) { mDiskLruCache.close() } } catch (e: Throwable) { LogUtils.e(e.message, e) } mDiskLruCache = null } } }"	Common initialization code for new list entries .
public _ScheduleDays ( ) { super ( ) ; }	Constructs a _ScheduleDays with no flags initially set .
"public int allocLow ( int size , int addrAlignment ) { for ( MemoryChunk memoryChunk = low ; memoryChunk != null ; memoryChunk = memoryChunk . next ) { if ( memoryChunk . isAvailable ( size , addrAlignment ) ) { return allocLow ( memoryChunk , size , addrAlignment ) ; } } return 0 ; }"	Allocate a memory at the lowest address .
public double heapInit ( ) { return memory . getHeapMemoryUsage ( ) . getInit ( ) ; }	Returns the heap initial memory of the current JVM .
public final long size ( ) { int sum = 0 ; for ( int i = 0 ; i < this . sets . length ; i ++ ) { sum += this . sets [ i ] . size ( ) ; } return sum ; }	Returns the number of fingerprints in this set . Warning : The size is only accurate in single-threaded mode .
"private static Location initLocation ( GlowSession session , PlayerReader reader ) { if ( reader . hasPlayedBefore ( ) ) { Location loc = reader . getLocation ( ) ; if ( loc != null ) { return loc ; } } return session . getServer ( ) . getWorlds ( ) . get ( 0 ) . getSpawnLocation ( ) ; }"	Read the location from a PlayerReader for entity initialization . Will fall back to a reasonable default rather than returning null .
"public fun performMessageAction(messageAction: MessageAction) { removeOverlay() when (messageAction) { is Resend -> resendMessage(messageAction.message)is ThreadReply -> { messageActions = messageActions + Reply(messageAction.message) loadThread(messageAction.message) } is Delete, is Flag -> {messageActions = messageActions + messageAction } is Copy -> copyMessage(messageAction.message)is MuteUser -> updateUserMute(messageAction.message.user)is React -> reactToMessage(messageAction.reaction, messageAction.message) is Pin -> updateMessagePin(messageAction.message)else -> {// no op, custom user action}}}"	"Triggered when the user selects a new message action, in the message overlay."
public fun dismissAllMessageActions() {this.messageActions = emptySet()}	"Dismisses all message actions, when we cancel them in the rest of the UI."
public fun dismissMessageAction(messageAction: MessageAction) {this.messageActions = messageActions - messageAction}	"Used to dismiss a specific message action, such as delete, reply, edit or something similar."
@Preview @Composable fun RotatingSquareComponentPreview() { RotatingSquareComponent() }	"Android Studio lets you preview your composable functions within the IDE itself, instead of needing to download the app to an Android device or emulator. This is a fantastic feature as you can preview all your custom components(read composable functions) from the comforts of the IDE. The main restriction is, the composable function must not take any parameters. If your composable function requires a parameter, you can simply wrap your component inside another composable function that doesn't take any parameters and call your composable function with the appropriate params. Also, don't forget to annotate it with @Preview & @Composable annotations."
@Composable fun MyApp() { val backgroundColor by animateColorAsState(MaterialTheme.colors.background) Surface(color = backgroundColor) { NewtonsTimerScreen() } }	Start building your app here!
override suspend fun handleEvent(event: RootEvent) = when (event) { RootEvent.AppOpen -> handleAppOpen() }	region Event Handling
"@Composable public fun BackButton( painter: Painter, onBackPressed: () -> Unit, modifier: Modifier = Modifier, ) { IconButton( modifier = modifier, onClick = onBackPressed ) { Icon( painter = painter, contentDescription = null, tint = ChatTheme.colors.textHighEmphasis, ) } }"	"Basic back button, that shows an icon and calls [onBackPressed] when tapped.  @param painter The icon or image to show. @param onBackPressed Handler for the back action. @param modifier Modifier for styling."
"@Composable public fun CancelIcon( modifier: Modifier = Modifier, onClick: () -> Unit, ) { Icon( modifier = modifier .background(shape = CircleShape, color = ChatTheme.colors.overlayDark). clickable( indication = null, interactionSource = remember { MutableInteractionSource() }, onClick = onClick ), painter = painterResource(id = R.drawable.stream_compose_ic_close), contentDescription = stringResource(id = R.string.stream_compose_cancel), tint = ChatTheme.colors.appBackground ) }"	Represents a simple cancel icon that is used primarily for attachments. @param modifier Modifier for styling.  @param onClick Handler when the user clicks on the icon.
"@Composable public fun EmptyContent( text: String, painter: Painter, modifier: Modifier = Modifier, ) { Column( modifier = modifier.background(color = ChatTheme.colors.appBackground), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( painter = painter, contentDescription = null, tint = ChatTheme.colors.disabled, modifier = Modifier.size(96.dp), )  Spacer(Modifier.size(16.dp)) Text( text = text,style = ChatTheme.typography.title3, color = ChatTheme.colors.textLowEmphasis, textAlign = TextAlign.Center ) } }"	The view that's shown when there's no data available. Consists of an icon and a caption below it. @param text The text to be displayed. @param painter The painter for the icon. @param modifier Modifier for styling.
"@Composable public fun LoadingFooter(modifier: Modifier = Modifier) { Box( modifier = modifier .background(color = ChatTheme.colors.appBackground) .padding(top = 8.dp, bottom = 48.dp) ) { LoadingIndicator( modifier = Modifier.size(16.dp).align(Alignment.Center)) } }"	Shows the loading footer UI in lists. @param modifier Modifier for styling.
"@Composable public fun LoadingIndicator(modifier: Modifier = Modifier) { Box( modifier, contentAlignment = Alignment.Center, ) { CircularProgressIndicator(strokeWidth = 2.dp, color = ChatTheme.colors.primaryAccent) } }"	Shows the default loading UI. @param modifier Modifier for styling.
"@Composable public fun NetworkLoadingIndicator( modifier: Modifier = Modifier, spinnerSize: Dp = 18.dp, textStyle: TextStyle = ChatTheme.typography.title3Bold, textColor: Color = ChatTheme.colors.textHighEmphasis, ) { Row( modifier, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.Center ) { CircularProgressIndicator( modifier = Modifier .padding(horizontal = 8.dp) .size(spinnerSize), strokeWidth = 2.dp, color = ChatTheme.colors.primaryAccent, ) Text( text = stringResource(id = R.string.stream_compose_waiting_for_network), style = textStyle, color = textColor, ) } }"	"Represents the default network loading view for the header, in case the network is down. @param modifier Styling for the [Row]. @param spinnerSize The size of the spinner. @param textStyle The text style of the inner text. @param textColor The text color of the inner text."
"@Composable public fun OnlineIndicator(modifier: Modifier = Modifier) { Box( modifier = modifier .size(12.dp).background(ChatTheme.colors.appBackground, CircleShape).padding(2.dp).background(ChatTheme.colors.infoAccent, CircleShape) ) }"	Component that represents an online indicator to be used with [io.getstream.chat.android.compose.ui.components.avatar.UserAvatar]. @param modifier Modifier for styling.
"@Composable internal fun DefaultSearchLabel() { Text( text = stringResource(id = R.string.stream_compose_search_input_hint),style = ChatTheme.typography.body,color = ChatTheme.colors.textLowEmphasis, ) }"	Default search input field label.
"@Composable internal fun RowScope.DefaultSearchLeadingIcon() { Icon( modifier = Modifier.weight(1f), painter = painterResource(id =R.drawable.stream_compose_ic_search), contentDescription = null, tint = ChatTheme.colors.textLowEmphasis, ) }"	"Default search input field leading ""search"" icon."
"@Composable public fun SearchInput(query: String,onValueChange: (String) -> Unit,modifier: Modifier = Modifier,onSearchStarted: () -> Unit = {},leadingIcon: @Composable RowScope.() -> Unit = { DefaultSearchLeadingIcon() }, label: @Composable () -> Unit = { DefaultSearchLabel() }, ) { var isFocused by remember { mutableStateOf(false) } val trailingIcon: (@Composable RowScope.() -> Unit)? = if (isFocused && query.isNotEmpty()) { @Composable { IconButton( modifier = Modifier .weight(1f) .size(24.dp), onClick = { onValueChange("""") }, content = { Icon( painter = painterResource(id = R.drawable.stream_compose_ic_clear), contentDescription = stringResource(id = R.string.stream_compose_search_input_cancel), tint = ChatTheme.colors.textLowEmphasis, ) } ) } } else null InputField( modifier = modifier .onFocusEvent { newState -> val wasPreviouslyFocused = isFocused if (!wasPreviouslyFocused && newState.isFocused) { onSearchStarted() }  isFocused = newState.isFocused},value = query,onValueChange = onValueChange, decorationBox = { innerTextField ->Row(Modifier.fillMaxWidth(),verticalAlignment = Alignment.CenterVertically) {leadingIcon() Box(modifier = Modifier.weight(8f)) { if (query.isEmpty()) { label() } innerTextField() } trailingIcon?.invoke(this) } }, maxLines = 1, innerPadding = PaddingValues(4.dp) ) }"	"The search component that allows the user to fill in a search query and filter their items. It also holds a clear action, that is active when the search is in focus and not empty, to clear the input. @param query Current query value. @param onValueChange Handler when the value changes. @param modifier Modifier for styling. @param onSearchStarted Handler when the search starts, by focusing the input field. @param leadingIcon The icon at the start of the search component that's customizable, but shows [DefaultSearchLeadingIcon] by default. @param label The label shown in the search component, when there's no input."
"@Composable public fun SimpleDialog( title: String, message: String, onPositiveAction: () -> Unit, onDismiss: () -> Unit, modifier: Modifier = Modifier, ) { AlertDialog( modifier = modifier, onDismissRequest = onDismiss, title = { Text( text = title, color = ChatTheme.colors.textHighEmphasis, style = ChatTheme.typography.title3Bold, ) }, text = { Text( text = message, color = ChatTheme.colors.textHighEmphasis, style = ChatTheme.typography.body, ) }, confirmButton = { TextButton( colors = ButtonDefaults.textButtonColors(contentColor = ChatTheme.colors.primaryAccent), onClick = { onPositiveAction() } ) { Text(text = stringResource(id = R.string.stream_compose_ok)) } }, dismissButton = { TextButton( colors = ButtonDefaults.textButtonColors(contentColor = ChatTheme.colors.primaryAccent), onClick = onDismiss ) { Text(text = stringResource(id = R.string.stream_compose_cancel)) } }, backgroundColor = ChatTheme.colors.barsBackground, ) }"	Generic dialog component that allows us to prompt the user.
"@Composable public fun SimpleMenu( modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.bottomSheet, overlayColor: Color = ChatTheme.colors.overlay, onDismiss: () -> Unit = {}, headerContent: @Composable ColumnScope.() -> Unit = {}, centerContent: @Composable ColumnScope.() -> Unit = {}, ) { Box( modifier = Modifier .background(overlayColor) .fillMaxSize() .clickable( onClick = onDismiss, indication = null, interactionSource = remember { MutableInteractionSource() } ) ) { Card( modifier = modifier.clickable( onClick = {},indication = null, interactionSource = remember { MutableInteractionSource() } ), shape = shape, backgroundColor = ChatTheme.colors.barsBackground ) { Column { headerContent() centerContent()}}}BackHandler(enabled = true, onBack = onDismiss)}"	Represents a reusable and generic modal menu useful for showing info about selected items.
"@Composable public fun Timestamp( date: Date?, modifier: Modifier = Modifier,formatter: DateFormatter = ChatTheme.dateFormatter,formatType: DateFormatType = DATE, ) {val timestamp = if (LocalInspectionMode.current) {""13:49""} else {when (formatType) {TIME -> formatter.formatTime(date)DATE -> formatter.formatDate(date)}}Text(modifier = modifier,text = timestamp,style = ChatTheme.typography.footnote,color = ChatTheme.colors.textLowEmphasis)}"	"Represents a timestamp in the app, that's used primarily for channels and messages."
"@Composable public fun TypingIndicator(modifier: Modifier = Modifier) { Row(modifier = modifier, horizontalArrangement = Arrangement.spacedBy(3.dp)) { TypingIndicatorAnimatedDot(0 * DotAnimationDurationMillis) TypingIndicatorAnimatedDot(1 * DotAnimationDurationMillis) TypingIndicatorAnimatedDot(2 * DotAnimationDurationMillis) } }"	Represents a simple typing indicator that consists of three animated dots
"@Composable public fun TypingIndicatorAnimatedDot( initialDelayMillis: Int, ) { val alpha = remember { Animatable(0.5f) }  LaunchedEffect(initialDelayMillis) { delay(initialDelayMillis.toLong()) alpha.animateTo( targetValue = 1f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = DotAnimationDurationMillis, delayMillis = DotAnimationDurationMillis, ), repeatMode = RepeatMode.Reverse, ), ) }  val color: Color = ChatTheme.colors.textLowEmphasis.copy(alpha = alpha.value)  Box( Modifier.background(color, CircleShape).size(5.dp) ) }"	Show a dot with infinite alpha animation
"@Composable internal fun DefaultFilesPickerItem( fileItem: AttachmentPickerItemState, onItemSelected: (AttachmentPickerItemState) -> Unit, ) { Row( Modifier.fillMaxWidth().clickable(interactionSource = remember { MutableInteractionSource() },indication = rememberRipple(),onClick = { onItemSelected(fileItem) }).padding(vertical = 8.dp, horizontal = 16.dp),verticalAlignment = Alignment.CenterVertically) { Box(contentAlignment = Alignment.Center) { Checkbox(checked = fileItem.isSelected,onCheckedChange = null,colors = CheckboxDefaults.colors(checkedColor = ChatTheme.colors.primaryAccent,uncheckedColor = ChatTheme.colors.disabled,checkmarkColor = Color.White,disabledColor = ChatTheme.colors.disabled,disabledIndeterminateColor = ChatTheme.colors.disabled),)} FilesPickerItemImage( fileItem = fileItem, modifier = Modifier .padding(start = 16.dp) .size(size = 40.dp) ) Column( modifier = Modifier.padding(start = 16.dp), horizontalAlignment = Alignment.Start, verticalArrangement = Arrangement.Center ) { Text( text = fileItem.attachmentMetaData.title ?: """", style = ChatTheme.typography.bodyBold, color = ChatTheme.colors.textHighEmphasis, ) Text( text = MediaStringUtil.convertFileSizeByteCount(fileItem.attachmentMetaData.size), style = ChatTheme.typography.footnote, color = ChatTheme.colors.textLowEmphasis, ) } } }"	Represents a single item in the file picker list.@param fileItem File to render.@param onItemSelected Handler when the item is selected.
"@Composable public fun FilesPicker( files: List<AttachmentPickerItemState>, onItemSelected: (AttachmentPickerItemState) -> Unit, onBrowseFilesResult: (List<Uri>) -> Unit, modifier: Modifier = Modifier, itemContent: @Composable (AttachmentPickerItemState) -> Unit = { DefaultFilesPickerItem( fileItem = it, onItemSelected = onItemSelected ) }, ) { val fileSelectContract = rememberLauncherForActivityResult(contract = SelectFilesContract()) { onBrowseFilesResult(it) }  Column(modifier = modifier) { Row(Modifier.fillMaxWidth()) { Text( modifier = Modifier.padding(16.dp), text = stringResource(id = R.string.stream_compose_recent_files), style = ChatTheme.typography.bodyBold, color = ChatTheme.colors.textHighEmphasis, )  Spacer(modifier = Modifier.weight(6f))  IconButton( content = { Icon(  painter = painterResource(id = R.drawable.stream_compose_ic_more_files), contentDescription = stringResource(id = R.string.stream_compose_send_attachment), tint = ChatTheme.colors.primaryAccent, ) }, onClick = { fileSelectContract.launch(Unit) } ) }  LazyColumn(modifier) { items(files) { fileItem -> itemContent(fileItem) } } } }"	Shows the UI for files the user can pick for message attachments. Exposes the logic of selecting items and browsing for extra files.
"@Composable public fun FilesPickerItemImage( fileItem: AttachmentPickerItemState, modifier: Modifier = Modifier, ) { val attachment = fileItem.attachmentMetaData val isImage = fileItem.attachmentMetaData.type == ""image"" val painter = if (isImage) { val dataToLoad = attachment.uri ?: attachment.file rememberStreamImagePainter(dataToLoad) } else { painterResource(id = MimeTypeIconProvider.getIconRes(attachment.mimeType)) }  val shape = if (isImage) ChatTheme.shapes.imageThumbnail else null val imageModifier = modifier.let { baseModifier -> if (shape != null) baseModifier.clip(shape) else baseModifier }  Image( modifier = imageModifier, painter = painter, contentDescription = null, contentScale = if (isImage) ContentScale.Crop else ContentScale.Fit ) }"	Represents the image that's shown in file picker items. This can be either an image/icon that represents the file  type or a thumbnail in case the file type is an image.
"@Composable private fun AvatarPreview( imageUrl: String, initials: String, ) { ChatTheme { Avatar( modifier = Modifier.size(36.dp), imageUrl = imageUrl, initials = initials ) } }"	Shows [Avatar] preview for the provided parameters.
"@Preview(showBackground = true, name = ""Avatar Preview (Without image URL)"") @Composable private fun AvatarWithoutImageUrlPreview() { AvatarPreview(imageUrl ="""",initials = ""JC"" ) }"	Preview of [Avatar] for a user which is online.Should show a background gradient with fallback initials.
"@Preview(showBackground = true, name = ""Avatar Preview (With image URL)"") @Composable private fun AvatarWithImageUrlPreview() { AvatarPreview( imageUrl = ""https://sample.com/image.png"", initials = ""JC"" ) }"	Preview of [Avatar] for a valid image URL.Should show the provided image.
"@Composable public fun Avatar( imageUrl: String, initials: String, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.avatar, textStyle: TextStyle = ChatTheme.typography.title3Bold, placeholderPainter: Painter? = null, contentDescription: String? = null, initialsAvatarOffset: DpOffset = DpOffset(0.dp, 0.dp), onClick: (() -> Unit)? = null, ) { if (LocalInspectionMode.current && imageUrl.isNotBlank()) { ImageAvatar( modifier = modifier, shape = shape, painter = painterResource(id = R.drawable.stream_compose_preview_avatar), contentDescription = contentDescription,onClick = onClick)return}if (imageUrl.isBlank()) {InitialsAvatar(modifier = modifier, initials = initials, shape = shape,textStyle = textStyle,onClick = onClick,avatarOffset = initialsAvatarOffset)return}val painter = rememberStreamImagePainter(data = imageUrl,placeholderPainter = painterResource(id = R.drawable.stream_compose_preview_avatar))if (painter.state is AsyncImagePainter.State.Error)  {InitialsAvatar( modifier = modifier, initials = initials, shape = shape, textStyle = textStyle, onClick = onClick, avatarOffset = initialsAvatarOffset ) } else if (painter.state is AsyncImagePainter.State.Loading && placeholderPainter != null) { ImageAvatar( modifier = modifier, shape = shape, painter = placeholderPainter, contentDescription = contentDescription, onClick = onClick ) } else { ImageAvatar( modifier = modifier, shape = shape, painter = painter, contentDescription = contentDescription, onClick = onClick ) } }"	"An avatar that renders an image from the provided image URL. In case the image URL was empty or there was an error loading the image, it falls back to the initials avatar."
"@Composable private fun ChannelAvatarPreview(channel: Channel) { ChatTheme { ChannelAvatar( channel = channel, currentUser = PreviewUserData.user1, modifier = Modifier.size(36.dp) ) } }"	Shows [ChannelAvatar] preview for the provided parameters.
"@Preview(showBackground = true, name = ""ChannelAvatar Preview (Many members)"") @Composable private fun ChannelAvatarForChannelWithManyMembersPreview() {ChannelAvatarPreview(PreviewChannelData.channelWithManyMembers) }"	Preview of [ChannelAvatar] for a channel without image and with many members. Should show an avatar with 4 sections that represent the avatars of the first 4 members of the channel.
"@Composable public fun ChannelAvatar( channel: Channel,currentUser: User?,modifier: Modifier = Modifier,shape: Shape = ChatTheme.shapes.avatar,textStyle: TextStyle = ChatTheme.typography.title3Bold,groupAvatarTextStyle: TextStyle = ChatTheme.typography.captionBold,showOnlineIndicator: Boolean = true,onlineIndicatorAlignment: OnlineIndicatorAlignment = OnlineIndicatorAlignment.TopEnd,onlineIndicator: @Composable BoxScope.() -> Unit = {DefaultOnlineIndicator(onlineIndicatorAlignment)}, contentDescription: String? = null,onClick: (() -> Unit)? = null,) {val members = channel.membersval memberCount = members.sizewhen {channel.image.isNotEmpty() ->  { Avatar( modifier = modifier,imageUrl = channel.image,initials = channel.initials,textStyle = textStyle,shape = shape,contentDescription = contentDescription,onClick = onClick)}memberCount == 1 -> {val user = members.first().userUserAvatar(modifier = modifier,user = user,shape = shape,contentDescription = user.name, showOnlineIndicator = showOnlineIndicator,onlineIndicatorAlignment = onlineIndicatorAlignment,onlineIndicator = onlineIndicator,onClick = onClick)}memberCount == 2 && members.any { it.user.id == currentUser?.id } -> {val user = members.first { it.user.id != currentUser?.id }.user UserAvatar(modifier = modifier,user = user,shape = shape, contentDescription = user.name,showOnlineIndicator = showOnlineIndicator,onlineIndicatorAlignment = onlineIndicatorAlignment,onlineIndicator = onlineIndicator, onClick = onClick)}else -> {val users = members.filter { it.user.id != currentUser?.id }.map { it.user }GroupAvatar(users = users,modifier = modifier,shape = shape,textStyle = groupAvatarTextStyle,onClick = onClick,)}}}"	"Represents the [Channel] avatar that's shown when browsing channels or when you open the Messages screen.Based on the state of the [Channel] and the number of members, it shows different types of images."
"@Preview(showBackground = true, name = ""ChannelAvatar Preview (With image)"") @Composable private fun ChannelWithImageAvatarPreview() { ChannelAvatarPreview(PreviewChannelData.channelWithImage) }"	Preview of [ChannelAvatar] for a channel with an avatar image. Should show a channel image.
"@Preview(showBackground = true, name = ""ChannelAvatar Preview (Online user)"") @Composable private fun ChannelAvatarForDirectChannelWithOnlineUserPreview() { ChannelAvatarPreview(PreviewChannelData.channelWithOnlineUser) }"	Preview of [ChannelAvatar] for a direct conversation with an online user. Should show a user avatar with an online indicator.
"@Preview(showBackground = true, name = ""ChannelAvatar Preview (Only one user)"")@Composableprivate fun ChannelAvatarForDirectChannelWithOneUserPreview() { ChannelAvatarPreview(PreviewChannelData.channelWithOneUser) }"	Preview of [ChannelAvatar] for a direct conversation with only one user.Should show a user avatar with an online indicator.
"@Preview(showBackground = true, name = ""ChannelAvatar Preview (Few members)"") @Composable private fun ChannelAvatarForChannelWithFewMembersPreview() { ChannelAvatarPreview(PreviewChannelData.channelWithFewMembers) }"	Preview of [ChannelAvatar] for a channel without image and with few members.Should show an avatar with 2 sections that represent the avatars of the first 2 members of the channel.
"@Composable public fun GroupAvatar( users: List<User>, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.avatar, textStyle: TextStyle = ChatTheme.typography.captionBold, onClick: (() -> Unit)? = null, ) { val avatarUsers = users.take(DefaultNumberOfAvatars) val imageCount = avatarUsers.size  val clickableModifier: Modifier = if (onClick != null) { modifier.clickable( onClick = onClick, indication = rememberRipple(bounded = false), interactionSource = remember { MutableInteractionSource() } ) } else { modifier }  Row(clickableModifier.clip(shape)) { Column( modifier = Modifier .weight(1f, fill = false).fillMaxHeight()) {for (imageIndex in 0 until imageCount step 2) {if (imageIndex < imageCount) {UserAvatar(modifier = Modifier.weight(1f).fillMaxSize(),user = avatarUsers[imageIndex],shape =  RectangleShape,textStyle = textStyle,showOnlineIndicator = false,initialsAvatarOffset = getAvatarPositionOffset(dimens = ChatTheme.dimens,userPosition = imageIndex, memberCount = imageCount))}}}Column(modifier = Modifier.weight(1f, fill = false).fillMaxHeight()) {for (imageIndex in 1 until imageCount step 2) {if (imageIndex < imageCount) {UserAvatar(modifier = Modifier.weight(1f).fillMaxSize(),user = avatarUsers[imageIndex],shape = RectangleShape,textStyle = textStyle,showOnlineIndicator = false,initialsAvatarOffset = getAvatarPositionOffset(dimens = ChatTheme.dimens,userPosition = imageIndex,memberCount = imageCount))}}}}}"	Represents an avatar with a matrix of user images or initials.
"@Composable public fun ImageAvatar( painter: Painter, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.avatar, contentDescription: String? = null, onClick: (() -> Unit)? = null, ) { val clickableModifier: Modifier = if (onClick != null) { modifier.clickable( onClick = onClick, indication = rememberRipple(bounded = false), interactionSource = remember { MutableInteractionSource() } ) } else { modifier }  Image( modifier = clickableModifier.clip(shape), contentScale = ContentScale.Crop,painter = painter, contentDescription = contentDescription ) }"	"Renders an image the [painter] provides. It allows for customization,uses the 'avatar' shape from [ChatTheme.shapes] for the clipping and exposes an [onClick] action."
"@Composable public fun InitialsAvatar( initials: String, modifier: Modifier = Modifier,shape: Shape = ChatTheme.shapes.avatar,textStyle: TextStyle = ChatTheme.typography.title3Bold,avatarOffset: DpOffset = DpOffset(0.dp, 0.dp),onClick: (() -> Unit)? = null,) {val clickableModifier: Modifier = if (onClick != null) { modifier.clickable(onClick = onClick,indication = rememberRipple(bounded = false),interactionSource = remember { MutableInteractionSource() })} else {modifier } val initialsGradient = initialsGradient(initials = initials) Box( modifier = clickableModifier.clip(shape).background(brush = initialsGradient)) { Text(modifier = Modifier.align(Alignment.Center) .offset(avatarOffset.x, avatarOffset.y),text = initials,style = textStyle,color = Color.White)} }"	Represents a special avatar case when we need to show the initials instead of an image. Usually happens when there are no images to show in the avatar.
"@Composable public fun UserAvatar( user: User, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.avatar, textStyle: TextStyle = ChatTheme.typography.title3Bold, contentDescription: String? = null, showOnlineIndicator: Boolean = true, onlineIndicatorAlignment: OnlineIndicatorAlignment = OnlineIndicatorAlignment.TopEnd, initialsAvatarOffset: DpOffset = DpOffset(0.dp, 0.dp), onlineIndicator: @Composable BoxScope.() -> Unit = { DefaultOnlineIndicator(onlineIndicatorAlignment) }, onClick: (() -> Unit)? = null, ) { Box(modifier = modifier) { Avatar( modifier = Modifier.fillMaxSize(), imageUrl = user.image, initials = user.initials, textStyle = textStyle, shape = shape, contentDescription = contentDescription, onClick = onClick, initialsAvatarOffset = initialsAvatarOffset ) if (showOnlineIndicator && user.online) { onlineIndicator() } } }"	"Represents the [User] avatar that's shown on the Messages screen or in headers of DMs. Based on the state within the [User], we either show an image or their initials."
@Composable internal fun BoxScope.DefaultOnlineIndicator(onlineIndicatorAlignment: OnlineIndicatorAlignment) { OnlineIndicator(modifier = Modifier.align(onlineIndicatorAlignment.alignment)) }	The default online indicator for channel members.
"@Preview(showBackground = true, name = ""UserAvatar Preview (With avatar image)"") @Composable private fun UserAvatarForUserWithImagePreview() { UserAvatarPreview(PreviewUserData.userWithImage) }"	Preview of [UserAvatar] for a user with avatar image. Should show a placeholder that represents user avatar image.
"@Preview(showBackground = true, name = ""UserAvatar Preview (With online status)"") @Composable private fun UserAvatarForOnlineUserPreview() { UserAvatarPreview(PreviewUserData.userWithOnlineStatus) }"	Preview of [UserAvatar] for a user which is online. Should show an avatar with an online indicator in the upper right corner.
"@Preview(showBackground = true, name = ""UserAvatar Preview (Without avatar image)"") @Composable private fun UserAvatarForUserWithoutImagePreview() { UserAvatarPreview(PreviewUserData.userWithoutImage) }"	Preview of [UserAvatar] for a user without avatar image.Should show background gradient and user initials.
"@Composable private fun UserAvatarPreview(user: User) { ChatTheme { UserAvatar( modifier = Modifier.size(36.dp), user = user, showOnlineIndicator = true, ) } }"	Shows [UserAvatar] preview for the provided parameters.
"@Composable public fun ChannelMembers(members: List<Member>,modifier: Modifier = Modifier,) {LazyRow(modifier = modifier.fillMaxWidth().padding(vertical = 24.dp),horizontalArrangement = Arrangement.Center,contentPadding = PaddingValues(start = 16.dp, end = 16.dp)) {items(members) { member ->ChannelMembersItem( modifier = Modifier.width(ChatTheme.dimens.selectedChannelMenuUserItemWidth).padding(horizontal = ChatTheme.dimens.selectedChannelMenuUserItemHorizontalPadding),member = member,)}}}"	Represents a list of members in the channel.
"@Preview(showBackground = true, name = ""ChannelMembers Preview (One member)"") @Composable private fun OneMemberChannelMembersPreview() { ChatTheme { ChannelMembers(members = PreviewMembersData.oneMember) } }"	Preview of [ChannelMembers] with one channel member.
"@Preview(showBackground = true, name = ""ChannelMembers Preview (Many members)"")@Composableprivate fun ManyMembersChannelMembersPreview() {ChatTheme { ChannelMembers(members = PreviewMembersData.manyMembers) } }"	Preview of [ChannelMembers] with many channel members.
"@Composable internal fun ChannelMembersItem( member: Member, modifier: Modifier = Modifier, ) { val memberName = member.user.name Column( modifier = modifier, verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) {  UserAvatar( modifier = Modifier.size(ChatTheme.dimens.selectedChannelMenuUserItemAvatarSize), user = member.user, contentDescription = memberName )  Text( text = memberName, style = ChatTheme.typography.footnoteBold, overflow = TextOverflow.Ellipsis, maxLines = 1, color = ChatTheme.colors.textHighEmphasis, ) } }"	"The UI component that shows a user avatar and user name, as a member of a channel."
"@Preview(showBackground = true, name = ""ChannelMembersItem Preview"") @Composable private fun ChannelMemberItemPreview() { ChatTheme { ChannelMembersItem(Member(user = PreviewUserData.user1)) } }"	Preview of [ChannelMembersItem].Should show user avatar and user name.
"@Composable public fun ChannelOptions( options: List<ChannelOptionState>, onChannelOptionClick: (ChannelAction) -> Unit, modifier: Modifier = Modifier, ) { LazyColumn( modifier = modifier.fillMaxWidth().wrapContentHeight()) {items(options) { option ->Spacer(modifier = Modifier.fillMaxWidth().height(0.5.dp).background(color = ChatTheme.colors.borders)) ChannelOptionsItem(title = option.title,titleColor = option.titleColor,leadingIcon = {Icon(modifier = Modifier.size(56.dp).padding(16.dp), painter = option.iconPainter,tint = option.iconColor,contentDescription = null)},onClick = { onChannelOptionClick(option.action) })}}}"	" This is the default bottom drawer UI that shows up when the user long taps on a channel item. It sets up different actions that we provide, based on user permissions."
"@Composable public fun buildDefaultChannelOptionsState( selectedChannel: Channel, isMuted: Boolean, ownCapabilities: Set<String>, ): List<ChannelOptionState> { val canLeaveChannel = ownCapabilities.contains(ChannelCapabilities.LEAVE_CHANNEL) val canDeleteChannel = ownCapabilities.contains(ChannelCapabilities.DELETE_CHANNEL) return listOfNotNull( ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_view_info), titleColor = ChatTheme.colors.textHighEmphasis, iconPainter = painterResource(id = R.drawable.stream_compose_ic_person), iconColor = ChatTheme.colors.textLowEmphasis, action = ViewInfo(selectedChannel) ), if (canLeaveChannel) { ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_leave_group), titleColor = ChatTheme.colors.textHighEmphasis, iconPainter = painterResource(id = R.drawable.stream_compose_ic_person_remove), iconColor = ChatTheme.colors.textLowEmphasis, action = LeaveGroup(selectedChannel) ) } else null, if (isMuted) { ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_unmute_channel), titleColor = ChatTheme.colors.textHighEmphasis, iconPainter = painterResource(id = R.drawable.stream_compose_ic_unmute), iconColor = ChatTheme.colors.textLowEmphasis, action = UnmuteChannel(selectedChannel) ) } else { ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_mute_channel), titleColor = ChatTheme.colors.textHighEmphasis, iconPainter = painterResource(id = R.drawable.stream_compose_ic_mute), iconColor = ChatTheme.colors.textLowEmphasis, action = MuteChannel(selectedChannel) ) }, if (canDeleteChannel) { ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_delete_conversation), titleColor = ChatTheme.colors.errorAccent, iconPainter = painterResource(id = R.drawable.stream_compose_ic_delete), iconColor = ChatTheme.colors.errorAccent, action = DeleteConversation(selectedChannel) ) } else null, ChannelOptionState( title = stringResource(id = R.string.stream_compose_selected_channel_menu_dismiss), titleColor = ChatTheme.colors.textHighEmphasis, iconPainter = painterResource(id = R.drawable.stream_compose_ic_clear), iconColor = ChatTheme.colors.textLowEmphasis, action = Cancel, ) ) }"	"Builds the default list of channel options, based on the current user and the state of the channel."
"@Preview(showBackground = true, name = ""ChannelOptions Preview"") @Composable private fun ChannelOptionsPreview() { ChatTheme { ChannelOptions( options = buildDefaultChannelOptionsState( selectedChannel = PreviewChannelData.channelWithMessages, isMuted = false, ownCapabilities = ChannelCapabilities.toSet() ), onChannelOptionClick = {} ) } }"	Preview of [ChannelOptions]. Should show a list of available actions for the channel.
"@Composable internal fun ChannelOptionsItem( title: String,titleColor: Color,leadingIcon: @Composable () -> Unit,onClick: () -> Unit,modifier: Modifier = Modifier,) {Row( modifier.fillMaxWidth().height(56.dp).clickable(onClick = onClick,indication = rememberRipple(),interactionSource = remember { MutableInteractionSource() }), verticalAlignment = Alignment.CenterVertically,horizontalArrangement = Arrangement.Start) {leadingIcon()Text(text = title,style = ChatTheme.typography.bodyBold,color = titleColor)}}"	Default component for selected channel menu options.
"@Preview(showBackground = true, name = ""ChannelOptionsItem Preview"") @Composableprivate fun ChannelOptionsItemPreview() {ChatTheme {ChannelOptionsItem( title = stringResource(id = R.string.stream_compose_selected_channel_menu_view_info),titleColor = ChatTheme.colors.textHighEmphasis,leadingIcon = {Icon(modifier = Modifier.size(56.dp).padding(16.dp),painter = painterResource(id = R.drawable.stream_compose_ic_person),tint = ChatTheme.colors.textLowEmphasis,contentDescription = null)}, onClick = {} ) } }"	Preview of [ChannelOptionsItem]. Should show a channel action item with an icon and a name.
"@Composable public fun MessageReadStatusIcon( channel: Channel, message: Message, currentUser: User?, modifier: Modifier = Modifier, ) { val readStatues = channel.getReadStatuses(userToIgnore = currentUser)val readCount = readStatues.count { it.time >= message.getCreatedAtOrThrow().time }val isMessageRead = readCount != 0 MessageReadStatusIcon(message = message,isMessageRead = isMessageRead,modifier = modifier,)}"	Shows a delivery status indicator for a particular message
"@Composable public fun MessageReadStatusIcon(message: Message,isMessageRead: Boolean,modifier: Modifier = Modifier,) {val syncStatus = message.syncStatus when { isMessageRead -> { Icon( modifier = modifier, painter = painterResource(id = R.drawable.stream_compose_message_seen), contentDescription = null, tint = ChatTheme.colors.primaryAccent, ) } syncStatus == SyncStatus.SYNC_NEEDED || syncStatus == SyncStatus.AWAITING_ATTACHMENTS -> { Icon( modifier = modifier, painter = painterResource(id = R.drawable.stream_compose_ic_clock), contentDescription = null, tint = ChatTheme.colors.textLowEmphasis, ) } syncStatus == SyncStatus.COMPLETED -> { Icon( modifier = modifier, painter = painterResource(id = R.drawable.stream_compose_message_sent), contentDescription = null, tint = ChatTheme.colors.textLowEmphasis, ) } } }"	Shows a delivery status indicator for a particular message.
"@Preview(showBackground = true, name = ""MessageReadStatusIcon Preview (Seen message)"")@Composableprivate fun SeenMessageReadStatusIcon() {ChatTheme { MessageReadStatusIcon( message = PreviewMessageData.message2, isMessageRead = true, ) }}"	Preview of [MessageReadStatusIcon] for a seen message. Should show a double tick indicator.
"@Composable public fun UnreadCountIndicator( unreadCount: Int, modifier: Modifier = Modifier, color: Color = ChatTheme.colors.errorAccent, ) { val displayText = if (unreadCount > LimitTooManyUnreadCount) UnreadCountMany else unreadCount.toString() val shape = RoundedCornerShape(9.dp)  Box( modifier = modifier .defaultMinSize(minWidth = 18.dp, minHeight = 18.dp) .background(shape = shape, color = color) .padding(horizontal = 4.dp), contentAlignment = Alignment.Center ) { Text( text = displayText, color = Color.White, textAlign = TextAlign.Center, style = ChatTheme.typography.captionBold ) } }"	"Shows the unread count badge for each channel item, to showcase how many messages the user didn't read."
"@Preview(showBackground = true, name = ""UnreadCountIndicator Preview (Few unread messages)"")@Composableprivate fun FewMessagesUnreadCountIndicatorPreview() { ChatTheme { UnreadCountIndicator(unreadCount = 5) } }"	Preview of [UnreadCountIndicator] with few unread messages.Should show a badge with the number of unread messages.
"@Preview(showBackground = true, name = ""UnreadCountIndicator Preview (Many unread messages)"") @Composableprivate fun ManyMessagesUnreadCountIndicatorPreview() {ChatTheme {UnreadCountIndicator(unreadCount = 200)} }"	Preview of [UnreadCountIndicator] with many unread messages. Should show a badge with the placeholder text.
"@Composable public fun CoolDownIndicator( coolDownTime: Int, modifier: Modifier = Modifier, ) {Box( modifier = modifier.size(48.dp).padding(12.dp).background(shape = RoundedCornerShape(24.dp), color = ChatTheme.colors.disabled),contentAlignment = Alignment.Center) {Text(text = coolDownTime.toString(),color = Color.White,textAlign = TextAlign.Center,style = ChatTheme.typography.bodyBold)}}"	Represent a timer that show the remaining time until the user is allowed to send the next message.
"@Composablepublic fun InputField(value: String,onValueChange: (String) -> Unit,modifier: Modifier = Modifier,enabled: Boolean = true,maxLines: Int = Int.MAX_VALUE,border: BorderStroke = BorderStroke(1.dp, ChatTheme.colors.borders),innerPadding: PaddingValues = PaddingValues(horizontal = 16.dp, vertical = 8.dp),keyboardOptions: KeyboardOptions = KeyboardOptions(capitalization = KeyboardCapitalization.Sentences),decorationBox: @Composable (innerTextField:@Composable () -> Unit) -> Unit,) {var textFieldValueState by remember { mutableStateOf(TextFieldValue(text = value)) } val selection = if (textFieldValueState.isCursorAtTheEnd()) {TextRange(value.length)} else {textFieldValueState.selection}val textFieldValue = textFieldValueState.copy(text = value,selection = selection) val description = stringResource(id = R.string.stream_compose_cd_message_input) BasicTextField(modifier = modifier.border(border = border, shape =ChatTheme.shapes.inputField).clip(ChatTheme.shapes.inputField).background(ChatTheme.colors.inputBackground).padding(innerPadding).semantics {contentDescription = description },value = textFieldValue,onValueChange = {textFieldValueState = itif (value != it.text) {onValueChange(it.text)}},textStyle = ChatTheme.typography.body.copy(color = ChatTheme.colors.textHighEmphasis,textDirection = TextDirection.Content),cursorBrush = SolidColor(ChatTheme.colors.primaryAccent),decorationBox = { innerTextField -> decorationBox(innerTextField) },maxLines = maxLines,singleLine = maxLines == 1,enabled = enabled,keyboardOptions = keyboardOptions)}"	"Custom input field that we use for our UI. It's fairly simple - shows a basic input with clipped corners and a border stroke, with some extra padding on each side.Within it, we allow for custom decoration, so that the user can define what the input field looks like when filled with content."
private fun TextFieldValue.isCursorAtTheEnd(): Boolean {val textLength = text.lengthval selectionStart = selection.startval selectionEnd = selection.endreturn textLength == selectionStart && textLength == selectionEnd}	Check if the [TextFieldValue] state represents a UI with the cursor at the end of the input.
"@Composable public fun MessageInputOptions( activeAction: MessageAction,onCancelAction: () -> Unit,modifier: Modifier = Modifier,) {val optionImage =painterResource(id = if (activeAction is Reply) R.drawable.stream_compose_ic_reply else R.drawable.stream_compose_ic_edit)val title = stringResource(id = if (activeAction is Reply) R.string.stream_compose_reply_to_messageelse R.string.stream_compose_edit_message)Row(modifier, verticalAlignment = Alignment.CenterVertically,horizontalArrangement = Arrangement.SpaceBetween) {Icon(modifier = Modifier.padding(4.dp), painter = optionImage,contentDescription = null,tint = ChatTheme.colors.textLowEmphasis,)Text(text = title,style = ChatTheme.typography.bodyBold,color = ChatTheme.colors.textHighEmphasis,)Icon(modifier = Modifier.padding(4.dp).clickable(onClick = onCancelAction,indication = rememberRipple(bounded = false), interactionSource = remember { MutableInteractionSource() }),painter = painterResource(id = R.drawable.stream_compose_ic_close),contentDescription = stringResource(id= R.string.stream_compose_cancel),tint = ChatTheme.colors.textLowEmphasis,)}}"	"Shows the options ""header"" for the message input component. This is based on the currently active message action - [io.getstream.chat.android.common.state.Reply] or [io.getstream.chat.android.common.state.Edit]."
"@Composable public fun MessageOptionItem( option: MessageOptionItemState, modifier: Modifier = Modifier, verticalAlignment: Alignment.Vertical = Alignment.CenterVertically, horizontalArrangement: Arrangement.Horizontal = Arrangement.Start, ) { val title = stringResource(id = option.title)  Row( modifier = modifier, verticalAlignment = verticalAlignment,horizontalArrangement = horizontalArrangement ) { Icon( modifier = Modifier.padding(horizontal = 16.dp), painter = option.iconPainter, tint = option.iconColor, contentDescription = title, )  Text( text = title, style = ChatTheme.typography.body, color = option.titleColor ) } }"	Each option item in the column of options.
"@Preview(showBackground = true, name = ""MessageOptionItem Preview"")@Composableprivate fun MessageOptionItemPreview() {ChatTheme {val option = MessageOptionItemState(title = R.string.stream_compose_reply,iconPainter = painterResource(R.drawable.stream_compose_ic_reply),action = Reply(PreviewMessageData.message1),titleColor = ChatTheme.colors.textHighEmphasis,iconColor = ChatTheme.colors.textLowEmphasis,)MessageOptionItem(modifier = Modifier.fillMaxWidth(),option = option)}}"	Preview of [MessageOptionItem].
"@Preview(showBackground = true, name = ""MessageOptions Preview (Own Message)"") @Composableprivate fun MessageOptionsForOwnMessagePreview() { MessageOptionsPreview( messageUser = PreviewUserData.user1, currentUser = PreviewUserData.user1, syncStatus = SyncStatus.COMPLETED, ) }"	Preview of [MessageOptions] for a delivered message of the current user.
"@Preview(showBackground = true, name = ""MessageOptions Preview (Theirs Message)"") @Composable private fun MessageOptionsForTheirsMessagePreview() { MessageOptionsPreview( messageUser = PreviewUserData.user1, currentUser = PreviewUserData.user2, syncStatus = SyncStatus.COMPLETED, ) }"	Preview of [MessageOptions] for theirs message.
"@Preview(showBackground = true, name = ""MessageOptions Preview (Failed Message)"") @Composable private fun MessageOptionsForFailedMessagePreview() { MessageOptionsPreview( messageUser = PreviewUserData.user1, currentUser = PreviewUserData.user1, syncStatus = SyncStatus.FAILED_PERMANENTLY, ) }"	Preview of [MessageOptions] for a failed message.
"@Composable private fun MessageOptionsPreview( messageUser: User, currentUser: User, syncStatus: SyncStatus, ) { ChatTheme { val selectedMMessage = PreviewMessageData.message1.copy( user = messageUser, syncStatus = syncStatus ) val messageOptionsStateList = defaultMessageOptionsState( selectedMessage = selectedMMessage, currentUser = currentUser, isInThread = false, ownCapabilities = ChannelCapabilities.toSet() ) MessageOptions(options = messageOptionsStateList, onMessageOptionSelected = {}) } }"	Shows [MessageOptions] preview for the provided parameters.
"@Composable public fun ModeratedMessageDialog( message: Message, onDismissRequest: () -> Unit, onDialogOptionInteraction: (message: Message, option: ModeratedMessageOption) -> Unit, modifier: Modifier = Modifier, moderatedMessageOptions: List<ModeratedMessageOption> = defaultMessageModerationOptions(), dialogTitle: @Composable () -> Unit = { DefaultModeratedMessageDialogTitle() }, dialogDescription: @Composable () -> Unit = { DefaultModeratedMessageDialogDescription() }, dialogOptions: @Composable () -> Unit = { DefaultModeratedDialogOptions( message = message, moderatedMessageOptions = moderatedMessageOptions, onDialogOptionInteraction = onDialogOptionInteraction, onDismissRequest = onDismissRequest ) }, ) { Dialog(onDismissRequest = onDismissRequest) { Column( modifier = modifier, horizontalAlignment = Alignment.CenterHorizontally ) { dialogTitle()  dialogDescription()  dialogOptions() } } }"	"Dialog that is shown when user clicks or long taps on a moderated message. Gives the user the ability to either send the message again, edit it and then send it or to delete it."
"@Composable internal fun DefaultModeratedDialogOptions( message: Message, moderatedMessageOptions: List<ModeratedMessageOption>, onDialogOptionInteraction: (message: Message, option: ModeratedMessageOption) -> Unit, onDismissRequest: () -> Unit, ) { Spacer(modifier = Modifier.height(12.dp))  ModeratedMessageDialogOptions( message = message, options = moderatedMessageOptions, onDismissRequest = onDismissRequest,onDialogOptionInteraction onDialogOptionInteraction)}"	"Represents the default content shown for the moderated message dialog options.By default we show the options to send the message anyway, edit it or delete it."
"@Composable internal fun DefaultModeratedMessageDialogTitle() { Spacer(modifier = Modifier.height(12.dp))val painter = painterResource(id = R.drawable.stream_compose_ic_flag)Image(painter = painter,contentDescription = """",colorFilter = ColorFilter.tint(ChatTheme.colors.primaryAccent),)Spacer(modifier = Modifier.height(4.dp))Text(text = stringResource(id = R.string.stream_ui_moderation_dialog_title),textAlign = TextAlign.Center,style = ChatTheme.typography.title3,color =ChatTheme.colors.textHighEmphasis)}"	Moderated message dialog title composable. Shows an icon and a title.
"@Composableinternal fun DefaultModeratedMessageDialogDescription() {Spacer(modifier = Modifier.height(12.dp))Text(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp),text = stringResource(id = R.string.stream_ui_moderation_dialog_description),textAlign = TextAlign.Center,style = ChatTheme.typography.body,color = ChatTheme.colors.textLowEmphasis)]}"	Moderated message dialog description composable.
"@Composable public fun ModeratedMessageDialogOptions(message: Message,options: List<ModeratedMessageOption>,modifier: Modifier = Modifier,onDismissRequest:() -> Unit = {},onDialogOptionInteraction: (message: Message, option: ModeratedMessageOption) -> Unit = { _, _ -> },itemContent:@Composable(ModeratedMessageOption)-> Unit = { option ->DefaultModeratedMessageOptionItem(message, option, onDismissRequest, onDialogOptionInteraction)},) {LazyColumn(modifier = modifier){items(options) { option ->itemContent(option)}}}"	Composable that represents the dialog options a user can select to act upon a moderated message.
"@Composableinternal fun DefaultModeratedMessageOptionItem(message: Message,option: ModeratedMessageOption,onDismissRequest: () -> Unit,onDialogOptionInteraction: (message: Message, option: ModeratedMessageOption) -> Unit,) {ModeratedMessageOptionItem(option = option,modifier = Modifier.fillMaxWidth().height(50.dp).clickable(interactionSource = remember { MutableInteractionSource() },indication = rememberRipple()) {onDialogOptionInteraction(message, option)onDismissRequest()})}"	Represents the default moderated message options item. By default shows only text of the action a user can perform.
"@Composable public fun ModeratedMessageOptionItem( option: ModeratedMessageOption, modifier: Modifier = Modifier, ) { Divider(color = ChatTheme.colors.borders) Box( modifier = modifier, contentAlignment = Alignment.Center ) { Text( text = stringResource(id = option.text), style = ChatTheme.typography.body, color = ChatTheme.colors.primaryAccent ) } }"	Composable that represents a single option inside the [ModeratedMessageDialog].By default shows only text of the action a user can perform.
"@ExperimentalFoundationApi @Composable public fun ExtendedReactionsOptions( ownReactions: List<Reaction>, onReactionOptionSelected: (ReactionOptionItemState) -> Unit, modifier: Modifier = Modifier, cells: GridCells = GridCells.Fixed(DefaultNumberOfColumns), reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(), itemContent: @Composable LazyGridScope.(ReactionOptionItemState) -> Unit = { option -> DefaultExtendedReactionsItemContent( option = option, onReactionOptionSelected = onReactionOptionSelected ) }, ) { val options = reactionTypes.entries.map { (type, reactionIcon) - val isSelected = ownReactions.any { ownReaction -> ownReaction.type == type } ReactionOptionItemState( painter = reactionIcon.getPainter(isSelected), type = type ) } LazyVerticalGrid(modifier = modifier, columns = cells) { items(options) { item -> key(item.type) { this@LazyVerticalGrid.itemContent(item) } } } }"	Displays all available reactions a user can set on a message.
"@Composable internal fun DefaultExtendedReactionsItemContent( option: ReactionOptionItemState, onReactionOptionSelected: (ReactionOptionItemState) -> Unit, ) { ReactionOptionItem( modifier = Modifier .padding(vertical = 8.dp) .clickable( interactionSource = remember { MutableInteractionSource() }, indication = rememberRipple(bounded = false), onClick = { onReactionOptionSelected(option) } ), option = option) }"	The default item content inside [ExtendedReactionsOptions]. Shows an individual reaction.
"@ExperimentalFoundationApi @Preview(showBackground = true, name = ""ExtendedReactionOptions Preview"")@Composable internal fun ExtendedReactionOptionsPreview() { ChatTheme {ExtendedReactionsOptions(ownReactions = listOf(),onReactionOptionSelected = {})}}"	Preview for [ExtendedReactionsOptions] with no reaction selected.
"@ExperimentalFoundationApi @Preview(showBackground = true, name = ""ExtendedReactionOptions Preview (With Own Reaction)"") @Composable internal fun ExtendedReactionOptionsWithOwnReactionPreview() {ChatTheme {ExtendedReactionsOptions(ownReactions = listOf(Reaction(messageId = ""messageId"",type = ""haha""),onReactionOptionSelected = {})}}"	Preview for [ExtendedReactionsOptions] with a selected reaction.
"@Composable public fun ReactionOptionItem( option: ReactionOptionItemState, modifier: Modifier = Modifier, ) { Image( modifier = modifier, painter = option.painter, contentDescription = option.type, ) }"	Individual reaction item.
"@Preview(showBackground = true, name = ""ReactionOptionItem Preview (Not Selected)"") @Composableprivate fun ReactionOptionItemNotSelectedPreview() {ChatTheme {(option = PreviewReactionOptionData.reactionOption1())}}"	Preview of [ReactionOptionItem] in its non selected state.
"@Preview(showBackground = true, name = ""ReactionOptionItem Preview (Selected)"")@Composableprivate fun ReactionOptionItemSelectedPreview() {ChatTheme {ReactionOptionItem(option = PreviewReactionOptionData.reactionOption2())}}"	Preview of [ReactionOptionItem] in its selected state.
"@Composablepublic fun ReactionOptions(ownReactions: List<Reaction>,onReactionOptionSelected: (ReactionOptionItemState) -> Unit,onShowMoreReactionsSelected: () -> Unit,modifier: Modifier = Modifier,numberOfReactionsShown: Int = DefaultNumberOfReactionsShown,horizontalArrangement: Arrangement.Horizontal =Arrangement.SpaceBetween,reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(),@DrawableReshowMoreReactionsIcon: Int = R.drawable.stream_compose_ic_more, itemContent: @Composable RowScope.(ReactionOptionItemState) -> Unit = { option -> DefaultReactionOptionItem( option = option, onReactionOptionSelected = onReactionOptionSelected ) }, ) { val options = reactionTypes.entries.map { (type, reactionIcon) -> val isSelected = ownReactions.any { ownReaction -> ownReaction.type == type } val painter = reactionIcon.getPainter(isSelected) ReactionOptionItemState( painter = painter, type = type ) }Row( modifier = modifier, horizontalArrangement = horizontalArrangement ) { options.take(numberOfReactionsShown).forEach { option -> key(option.type) { itemContent(option) } } if(options.size > numberOfReactionsShown) { Icon( modifier = Modifier.clickable( interactionSource = remember { MutableInteractionSource() }, indication = rememberRipple(bounded = false), onClick = { onShowMoreReactionsSelected() } ), painter = painterResource(id = showMoreReactionsIcon), contentDescription = LocalContext.current.getString(R.string.stream_compose_show_more_reactions), tint = ChatTheme.colors.textLowEmphasis, ) } } }"	Displays all available reactions.
"@Composable internal fun DefaultReactionOptionItem(option: ReactionOptionItemState,onReactionOptionSelected: (ReactionOptionItemState) -> Unit,){ReactionOptionItem(modifier = Modifier.size(24.dp).size(ChatTheme.dimens.reactionOptionItemIconSize).clickable(interactionSource = remember { MutableInteractionSource() },indication = rememberRipple(bounded = false),onClick = { onReactionOptionSelected(option) }),option = option)}"	The default reaction option item.
"@Preview(showBackground = true, name = ""ReactionOptions Preview"") @Composable private fun ReactionOptionsPreview() { ChatTheme { val reactionType = ChatTheme.reactionIconFactory.createReactionIcons().keys.firstOrNull() if (reactionType != null) { ReactionOptions(ownReactions =listOf(Reaction(reactionType)),onReactionOptionSelected = {},onShowMoreReactionsSelected = {}}}"	Preview of [ReactionOptions] with a single item selected.
"@OptIn(ExperimentalFoundationApi::class) @Composable public fun ReactionsPicker( message: Message, onMessageAction: (MessageAction) -> Unit, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.bottomSheet, overlayColor: Color = ChatTheme.colors.overlay, cells: GridCells = GridCells.Fixed(DefaultNumberOfReactions), onDismiss: () -> Unit = {}, reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(), headerContent: @Composable ColumnScope.() -> Unit = {}, centerContent: @Composable ColumnScope.() -> Unit = { DefaultReactionsPickerCenterContent( message = message, onMessageAction = onMessageAction, cells = cells, reactionTypes = reactionTypes ) }, ) { SimpleMenu( modifier = modifier, shape = shape, overlayColor = overlayColor, headerContent = headerContent, centerContent = centerContent, onDismiss = onDismiss ) }"	Displays all of the available reactions the user can set on a message.
"@OptIn(ExperimentalFoundationApi::class) @Composable internal fun DefaultReactionsPickerCenterContent( message: Message, onMessageAction: (MessageAction) -> Unit, cells: GridCells = GridCells.Fixed(DefaultNumberOfReactions), reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(),{ ExtendedReactionsOptions(modifier = Modifier.padding(start = 16.dp, end = 16.dp, top = 12.dp, bottom = 12.dp),reactionTypes = reactionTypes,ownReactions = message.ownReactions,onReactionOptionSelected = { reactionOptionItemState ->onMessageAction(React(reaction = Reaction(messageId = message.id, reactionOptionItemState.type),message = message))},cells = cells)}"	The Default center content for the [ReactionsPicker]. Shows all available reactions.
"@ExperimentalFoundationApi@Preview(showBackground = true, name = ""ReactionPicker Preview"")@Composableinternal fun ReactionPickerPreview() {ChatTheme {ReactionsPicker(message = PreviewMessageData.messageWithOwnReaction,onMessageAction = {})}}"	Preview of [ReactionsPicker] with a reaction selected.
"@Composable public fun SelectedMessageMenu( message: Message, messageOptions: List<MessageOptionItemState>,ownCapabilities: Set<String>,onMessageAction: (MessageAction) -> Unit, onShowMoreReactionsSelected: () -> Unit, modifier: Modifier = Modifier, shape: Shape = ChatTheme.shapes.bottomSheet, overlayColor: Color = ChatTheme.colors.overlay, reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(), @DrawableRes showMoreReactionsIcon: Int = R.drawable.stream_compose_ic_more, onDismiss: () -> Unit = {}, headerContent: @Composable ColumnScope.() -> Unit = { val canLeaveReaction = ownCapabilities.contains(ChannelCapabilities.SEND_REACTION) if (canLeaveReaction) { DefaultSelectedMessageReactionOptions( message = message, reactionTypes = reactionTypes, showMoreReactionsDrawableRes = showMoreReactionsIcon, onMessageAction = onMessageAction, showMoreReactionsIcon = onShowMoreReactionsSelected ) } }, centerContent: @Composable ColumnScope.() -> Unit = {DefaultSelectedMessageOptions( messageOptions =messageOptions,onMessageAction = onMessageAction ) }, ) { SimpleMenu( modifier = modifier, shape = shape, overlayColor = overlayColor, onDismiss = onDismiss, headerContent = headerContent, centerContent = centerContent ) }"	Represents the options user can take after selecting a message.
"@Composable internal fun DefaultSelectedMessageOptions( messageOptions: List<MessageOptionItemState>, onMessageAction: (MessageAction) -> Unit, ) { MessageOptions( options = messageOptions, onMessageOptionSelected = { onMessageAction(it.action) } ) }"	Default selected message options.
"@Preview(showBackground = true, name = ""SelectedMessageMenu Preview"")@Composableprivate fun SelectedMessageMenuPreview() {ChatTheme {val messageOptionsStateList = defaultMessageOptionsState(selectedMessage = Message(),currentUser = User(),isInThread = false,ownCapabilities = ChannelCapabilities.toSet())SelectedMessageMenu(message = Message(),messageOptions = messageOptionsStateList,onMessageAction = {}, onShowMoreReactionsSelected = {},ownCapabilities = ChannelCapabilities.toSet())}}"	Preview of [SelectedMessageMenu].
"@Composable public fun SelectedReactionsMenu(message: Message,currentUser: User?,ownCapabilities: Set<String>,onMessageAction: (MessageAction) -> Unit,onShowMoreReactionsSelected: () -> Unit,modifier: Modifier = Modifier,shape: Shape = ChatTheme.shapes.bottomSheet,overlayColor: Color = ChatTheme.colors.overlay,reactionTypes: Map<String, ReactionIcon> = ChatTheme.reactionIconFactory.createReactionIcons(),@DrawableRes showMoreReactionsIcon: Int = R.drawable.stream_compose_ic_more,onDismiss: () -> Unit = {},headerContent: @Composable ColumnScope.() -> Unit = {val canLeaveReaction = ownCapabilities.contains(ChannelCapabilities.SEND_REACTION)if (canLeaveReaction) {DefaultSelectedReactionsHeaderContent(message = message,reactionTypes =reactionTypes,showMoreReactionsIcon = showMoreReactionsIcon,onMessageAction = onMessageAction,onShowMoreReactionsSelected =onShowMoreReactionsSelected)}},centerContent: @Composable ColumnScope.() -> Unit = {DefaultSelectedReactionsCenterContent(message = message,currentUser = currentUser)},) {SimpleMenu(modifier = modifier,shape = shape,overlayColor = overlayColor,onDismiss = onDismiss, headerContent = headerContent,centerContent = centerContent)}"	Represents the list of user reactions.
"@Composableinternal fun DefaultSelectedReactionsHeaderContent(message: Message,reactionTypes: Map<String, ReactionIcon>,@DrawableRes showMoreReactionsIcon: Int = R.drawable.stream_compose_ic_more,onMessageAction: (MessageAction) -> Unit,onShowMoreReactionsSelected: () -> Unit,) ReactionOptions(modifier = Modifier.fillMaxWidth().padding(start = 16.dp, end = 16.dp, bottom = 8.dp, top = 20.dp),reactionTypes = reactionTypes,showMoreReactionsIcon = showMoreReactionsIcon,onReactionOptionSelected = {onMessageAction(React(reaction = Reaction(messageId = message.id, type = it.type),message = message) ])},onShowMoreReactionsSelected = onShowMoreReactionsSelected,ownReactions = message.ownReactions)}"	Default header content for the selected reactions menu.
"@Composableinternal fun DefaultSelectedReactionsCenterContent(message: Message,currentUser: User?,) {UserReactions(modifier = Modifier.fillMaxWidth().heightIn(max = ChatTheme.dimens.userReactionsMaxHeight).padding(vertical = 16.dp),items = buildUserReactionItems(message = message,currentUser = currentUser))}"	Default center content for the selected reactions menu.
"@Composableprivate fun buildUserReactionItems(message: Message,currentUser: User?,): List<UserReactionItemState> {val iconFactory = ChatTheme.reactionIconFactoryreturn message.latestReactions.filter { it.user != null && iconFactory.isReactionSupported(it.type) }.map {val user = requireNotNull(it.user) val type = it.typeval isMine = currentUser?.id == user.idval painter = iconFactory.createReactionIcon(type).getPainter(isMine)UserReactionItemState(user = user,painter = painter,type = type)}}"	"Builds a list of user reactions, based on the current user and the selected message."
"@Preview@Composableprivate fun OneSelectedReactionMenuPreview() {ChatTheme {val message = Message(latestReactions = PreviewReactionData.oneReaction.toMutableList())SelectedReactionsMenu(message = message,currentUser = PreviewUserData.user1,onMessageAction = {} ,onShowMoreReactionsSelected = {},ownCapabilities = ChannelCapabilities.toSet())}}"	Preview of the [SelectedReactionsMenu] component with 1 reaction.
"@Preview@Composableprivate fun ManySelectedReactionsMenuPreview() {ChatTheme {val message = Message(latestReactions = PreviewReactionData.manyReaction.toMutableList())SelectedReactionsMenu(message = message,currentUser = PreviewUserData.user1,onMessageAction = {}, onShowMoreReactionsSelected = {},ownCapabilities = ChannelCapabilities.toSet())}}"	Preview of the [SelectedReactionsMenu] component with many reactions.
"@Composablepublic fun SuggestionList(modifier: Modifier = Modifier,shape: Shape = ChatTheme.shapes.suggestionList,contentPadding: PaddingValues = PaddingValues(vertical = ChatTheme.dimens.suggestionListPadding),headerContent: @Composable () -> Unit = {},centerContent: @Composable () -> Unit,) {Popup(popupPositionProvider = AboveAnchorPopupPositionProvider()) {Card(modifier = modifier,elevation = ChatTheme.dimens.suggestionListElevation,shape = shape,backgroundColor = ChatTheme.colors.barsBackground,) {Column(Modifier.padding(contentPadding)) {headerContent()centerContent()}}}}"	Represents the suggestion list popup that allows user to auto complete the current input.
"@Composable public fun MentionSuggestionList(users: List<User>,modifier: Modifier = Modifier,onMentionSelected: (User) -> Unit = {},itemContent: @Composable (User) > Unit = { user ->DefaultMentionSuggestionItem(user = user,onMentionSelected = onMentionSelected,)},) {SuggestionList(modifier = modifier.fillMaxWidth().heightIn(max = ChatTheme.dimens.suggestionListMaxHeight)) {LazyColumn(horizontalAlignment = Alignment.CenterHorizontally) {items(items = users,key = User::id) { user ->itemContent(user)}}}}"	Represents the mention suggestion list popup.
"@Composable internal fun DefaultMentionSuggestionItem(user: User, onMentionSelected: (User) -> Unit,) { MentionSuggestionItem( user = user, onMentionSelected = onMentionSelected, ) }"	The default mention suggestion item.
"@Composable public fun MentionSuggestionItem(user: User,onMentionSelected: (User) -> Unit,modifier: Modifier = Modifier,leadingContent: @Composable RowScope.(User) -> Unit = {DefaultMentionSuggestionItemLeadingContent(user = it)},centerContent: @Composable RowScope.(User) -> Unit = {DefaultMentionSuggestionItemCenterContent(user = it)},trailingContent: @Composable RowScope.(User) -> Unit = {DefaultMentionSuggestionItemTrailingContent()},) {Row(modifier = modifier.fillMaxWidth().wrapContentHeight().clickable(onClick = { onMentionSelected(user) },indication = rememberRipple(),interactionSource = remember { MutableInteractionSource() }).padding(vertical = ChatTheme.dimens.mentionSuggestionItemVerticalPadding,horizontal = ChatTheme.dimens.mentionSuggestionItemHorizontalPadding),verticalAlignment = Alignment.CenterVertically,) {leadingContent(user)centerContent(user)trailingContent(user)}}"	Represents the mention suggestion item in the mention suggestion list popup.
"@Composable internal fun DefaultMentionSuggestionItemLeadingContent(user: User) { UserAvatar( modifier = Modifier .padding(end = 8.dp) .size(ChatTheme.dimens.mentionSuggestionItemAvatarSize), user = user, showOnlineIndicator = true, ) }"	Represents the default content shown at the start of the mention list item.
"@Composable internal fun RowScope.DefaultMentionSuggestionItemCenterContent(user: User) {Column(modifier = Modifier.weight(1f).wrapContentHeight()) {Text(text = user.name,style = ChatTheme.typography.bodyBold,color = ChatTheme.colors.textHighEmphasis,maxLines = 1,overflow = TextOverflow.Ellipsis)Text(text = ""@${user.id}"",style = ChatTheme.typography.footnote,color = ChatTheme.colors.textLowEmphasis,maxLines = 1,overflow = TextOverflow.Ellipsis)}=}"	"Represents the center portion of the mention item, that show the user name and the user ID."
"@Composableinternal fun DefaultMentionSuggestionItemTrailingContent() {Icon(modifier = Modifier.padding(start = 8.dp).size(24.dp),painter = painterResource(id = R.drawable.stream_compose_ic_mention),contentDescription = null,tint = ChatTheme.colors.primaryAccent)}"	Represents the default content shown at the end of the mention list item.
"@Composable public fun CommandSuggestionItem( command: Command,modifier: Modifier = Modifier,onCommandSelected: (Command) -> Unit = {},leadingContent: @Composable RowScope.(Command) -> Unit = {DefaultCommandSuggestionItemLeadingContent()},centerContent: @Composable RowScope.(Command) -> Unit = {DefaultCommandSuggestionItemCenterContent(command = it)},) {Row(modifier = modifier.fillMaxWidth().wrapContentHeight().clickable(onClick = { onCommandSelected(command) },indication = rememberRipple(),interactionSource = remember { MutableInteractionSource() }).padding(vertical = ChatTheme.dimens.commandSuggestionItemVerticalPadding,horizontal = ChatTheme.dimens.commandSuggestionItemHorizontalPadding),verticalAlignment =Alignment.CenterVertically,) {leadingContent(command)centerContent(command)}}"	Represents the command suggestion item in the command suggestion list popup.
"@Composableinternal fun DefaultCommandSuggestionItemLeadingContent() {Image(modifier = Modifier.padding(end = 8.dp).size(ChatTheme.dimens.commandSuggestionItemIconSize),painter = painterResource(id = R.drawable.stream_compose_ic_giphy),contentDescription = null)}"	Represents the default content shown at the start of the command list item.
"@Composable internal fun RowScope.DefaultCommandSuggestionItemCenterContent(command: Command,modifier: Modifier = Modifier,) {val commandDescription = LocalContext.current.getString(R.string.stream_compose_message_composer_command_template,command.name,command.args)Row(modifier = modifier.weight(1f).wrapContentHeight(),verticalAlignment = Alignment.CenterVertically) {Text(text = command.name.replaceFirstChar(Char::uppercase),style = ChatTheme.typography.bodyBold,color = ChatTheme.colors.textHighEmphasis,maxLines = 1,overflow = TextOverflow.Ellipsis) Spacer(modifier = Modifier.width(8.dp))  Text(text = commandDescription, style = ChatTheme.typography.body,color = ChatTheme.colors.textLowEmphasis,maxLines = 1,overflow = TextOverflow.Ellipsis)}}"	"Represents the center portion of the command item, that show the user name and the user ID."
"@Composable public fun CommandSuggestionList(commands: List<Command>,modifier: Modifier = Modifier,onCommandSelected: (Command) -> Unit = {},itemContent: @Composable (Command) -> Unit = { command -> DefaultCommandSuggestionItem( command = command, onCommandSelected = onCommandSelected, ) }, ) { SuggestionList( modifier = modifier.fillMaxWidth() .heightIn(max = ChatTheme.dimens.suggestionListMaxHeight) .padding(ChatTheme.dimens.suggestionListPadding), headerContent = {Row(modifier = Modifier.fillMaxWidth().height(40.dp),verticalAlignment = Alignment.CenterVertically) {Icon(modifier = Modifier.padding(horizontal = 8.dp).size(24.dp),painter = painterResource(id = R.drawable.stream_compose_ic_command),tint = ChatTheme.colors.primaryAccent,contentDescription = null)Text( text = stringResource(id = R.string.stream_compose_message_composer_instant_commands),style = ChatTheme.typography.body,maxLines = 1,color = ChatTheme.colors.textLowEmphasis)}}) {LazyColumn(horizontalAlignment = Alignment.CenterHorizontally) {items(items = commands,key = Command::name) { command -> itemContent(command)}}}}"	Represents the command suggestion list popup.
"@Composable internal fun DefaultCommandSuggestionItem(command: Command,onCommandSelected: (Command) -> Unit,) {CommandSuggestionItem(command = command, onCommandSelected = onCommandSelected) }"	The default command suggestion item.
"@Composable public fun UserReactionItem(item: UserReactionItemState,modifier: Modifier = Modifier,) {val (user, painter, type) = item Column(modifier = modifier,horizontalAlignment = Alignment.CenterHorizontally) {val isMine = user.id == ChatClient.instance().getCurrentUser()?.idval isStartAlignment = ChatTheme.messageOptionsUserReactionAlignment.isStartAlignment(isMine) val alignment = if (isStartAlignment) Alignment.BottomStart else Alignment.BottomEnd Box(modifier = Modifier.width(64.dp)) { UserAvatar(user = user,showOnlineIndicator = false,modifier = Modifier.size(ChatTheme.dimens.userReactionItemAvatarSize)) Image(modifier = Modifier.background(shape = RoundedCornerShape(16.dp), color = ChatTheme.colors.barsBackground).size(ChatTheme.dimens.userReactionItemIconSize).padding(4.dp).align(alignment),painter = painter,contentDescription = type,)} Spacer(modifier = Modifier.height(8.dp))Text(text = user.name,style = ChatTheme.typography.footnoteBold,maxLines = 1,overflow = TextOverflow.Ellipsis,color = ChatTheme.colors.textHighEmphasis,textAlign = TextAlign.Center,)}}"	Represent a reaction item with the user who left it.
@Preview@Composablepublic fun CurrentUserReactionItemPreview() {ChatTheme {UserReactionItem(item = PreviewUserReactionData.user1Reaction())}}	Preview of the [UserReactionItem] component with a reaction left by the current user.
@Preview@Composablepublic fun OtherUserReactionItemPreview() {ChatTheme {UserReactionItem(item = PreviewUserReactionData.user2Reaction()) }  }	Preview of the [UserReactionItem] component with a reaction left by another user.
"@OptIn(ExperimentalFoundationApi::class) @Composablepublic fun UserReactions( items: List<UserReactionItemState>,modifier: Modifier = Modifier,itemContent: @Composable (UserReactionItemState) -> Unit = {DefaultUserReactionItem(item = it)},) {val reactionCount = items.sizeval reactionCountText = LocalContext.current.resources.getQuantityString(R.plurals.stream_compose_message_reactions,reactionCount,reactionCount)Column(horizontalAlignment = Alignment.CenterHorizontally,modifier = modifier.background(ChatTheme.colors.barsBackground)) {Text(text = reactionCountText,style = ChatTheme.typography.title3Bold,maxLines = 1,overflow = TextOverflow.Ellipsis,color = ChatTheme.colors.textHighEmphasis) Spacer(modifier = Modifier.height(16.dp)) if (reactionCount > 0) {BoxWithConstraints(modifier = Modifier.fillMaxWidth(),contentAlignment = Alignment.Center) {val reactionItemWidth = ChatTheme.dimens.userReactionItemWidth val maxColumns = maxOf((maxWidth / reactionItemWidth).toInt(), 1)val columns = reactionCount.coerceAtMost(maxColumns) val reactionGridWidth = reactionItemWidth * columns LazyVerticalGrid(modifier = Modifier.width(reactionGridWidth).align(Alignment.Center),columns = GridCells.Fixed(columns)) {items(reactionCount) { index ->itemContent(items[index])}}}}}}"	Represent a section with a list of reactions left for the message.
"@Composable internal fun DefaultUserReactionItem(item: UserReactionItemState) {UserReactionItem(item = item,modifier = Modifier,)}"	Default user reactions item for the user reactions component.
@Preview @Composable private fun OneUserReactionPreview() {ChatTheme {UserReactions(items = PreviewUserReactionData.oneUserReaction())}}	Preview of the [UserReactions] component with one user reaction.
@Preview@Composable private fun ManyUserReactionsPreview() {ChatTheme {UserReactions(items = PreviewUserReactionData.manyUserReactions())}}	Preview of the [UserReactions] component with many user reactions.
"@OptIn(ExperimentalFoundationApi::class) @Composable public fun FileAttachmentContent( attachmentState: AttachmentState,modifier: Modifier = Modifier,) {val (message, onItemLongClick) = attachmentState val previewHandlers = ChatTheme.attachmentPreviewHandlers Column(modifier = modifier.combinedClickable( indication = null, interactionSource = remember { MutableInteractionSource() }, onClick = {}, onLongClick = { onItemLongClick(message) })) {for (attachment in message.attachments) {FileAttachmentItem(modifier = Modifier.padding(2.dp).fillMaxWidth().combinedClickable(indication = null,interactionSource = remember { MutableInteractionSource() },onClick = {previewHandlers.firstOrNull { it.canHandle(attachment) }.handleAttachmentPreview(attachment)},onLongClick = { onItemLongClick(message) },),attachment = attachment)}}}"	Builds a file attachment message which shows a list of files.
"@Composable public fun FileAttachmentItem(attachment: Attachment,modifier: Modifier = Modifier,) { Surface(modifier = modifier,color = ChatTheme.colors.appBackground,shape = ChatTheme.shapes.attachment) {Row(Modifier.fillMaxWidth().height(50.dp).padding(vertical = 8.dp, horizontal = 8.dp),verticalAlignment = Alignment.CenterVertically) {FileAttachmentImage(attachment = attachment)FileAttachmentDescription(attachment = attachment)FileAttachmentDownloadIcon(attachment = attachment)}}}"	Represents each file item in the list of file attachments.
"@Composable private fun FileAttachmentDescription(attachment: Attachment) {Column(modifier = Modifier.fillMaxWidth(0.85f).padding(start = 16.dp, end = 8.dp),horizontalAlignment = Alignment.Start,verticalArrangement = Arrangement.Center) {Text(text = attachment.title ?: attachment.name ?: """",style = ChatTheme.typography.bodyBold,maxLines = 1,overflow = TextOverflow.Ellipsis,color = ChatTheme.colors.textHighEmphasis)Text(text = MediaStringUtil.convertFileSizeByteCount(attachment.fileSize.toLong()),style = ChatTheme.typography.footnote,color = ChatTheme.colors.textLowEmphasis)}}"	Displays information about the attachment such as the attachment title and its size in bytes.
"@Composable private fun RowScope.FileAttachmentDownloadIcon(attachment: Attachment) {val permissionHandlers = ChatTheme.permissionHandlerProvider Icon( modifier = Modifier.align(Alignment.Top).padding(end = 2.dp).clickable(interactionSource = remember { MutableInteractionSource() },indication = rememberRipple(bounded = false)) {permissionHandlers.first { it.canHandle(Manifest.permission.WRITE_EXTERNAL_STORAGE) }.apply {onHandleRequest(mapOf(PayloadAttachment to attachment))}},painter = painterResource(id = R.drawable.stream_compose_ic_file_download),contentDescription = stringResource(id = R.string.stream_compose_download),tint = ChatTheme.colors.textHighEmphasis)}"	Downloads the given attachment when clicked.
"@Composable public fun FileAttachmentImage(attachment: Attachment) {val isImage = attachment.type == ""image""val painter = if (isImage) {val dataToLoad = attachment.imageUrl ?: attachment.upload rememberStreamImagePainter(dataToLoad)} else {painterResource(id = MimeTypeIconProvider.getIconRes(attachment.mimeType))} val shape = if (isImage) ChatTheme.shapes.imageThumbnail else nullval imageModifier = Modifier.size(height = 40.dp, width = 35.dp).let { baseModifier -> if (shape != null) baseModifier.clip(shape) else baseModifier } Image(modifier = imageModifier, painter = painter, contentDescription = null, contentScale = if (isImage) ContentScale.Crop else ContentScale.Fit) }"	Represents the image that's shown in file attachments. This can be either an image/icon that represents the file type or a thumbnail in case the file type is an image.
"@Suppress(""FunctionName"") public fun FileAttachmentFactory(): AttachmentFactory = AttachmentFactory( canHandle = { attachments ->attachments.any { it.isFile() } }, previewContent = @Composable { modifier, attachments, onAttachmentRemoved -> FileAttachmentPreviewContent(modifier = modifier, attachments = attachments, onAttachmentRemoved = onAttachmentRemoved)},content = @Composable { modifier, state ->FileAttachmentContent(modifier = modifier.wrapContentHeight().width(ChatTheme.dimens.attachmentsContentFileWidth),attachmentState = state)},)"	An [AttachmentFactory] that validates attachments as files and uses [FileAttachmentContent] to build the UI for the message.
"@Suppress(""FunctionName"") public fun GiphyAttachmentFactory(giphyInfoType: GiphyInfoType = GiphyInfoType.FIXED_HEIGHT_DOWNSAMPLED,giphySizingMode: GiphySizingMode = GiphySizingMode.ADAPTIVE,contentScale: ContentScale = ContentScale.Crop,): AttachmentFactory =AttachmentFactory(canHandle = { attachments -> attachments.any { it.type == ModelType.attach_giphy } },content = @Composable { modifier, state ->GiphyAttachmentContent(modifier = modifier.wrapContentSize(),attachmentState = state,giphyInfoType = giphyInfoType,giphySizingMode = giphySizingMode,contentScale = contentScale,)},)"	"An [AttachmentFactory] that validates and shows Giphy attachments using [GiphyAttachmentContent]. Has no ""preview content"", given that this attachment only exists after being sent."
"@Suppress(""FunctionName"") public fun ImageAttachmentFactory(): AttachmentFactory = AttachmentFactory( canHandle = { attachments -> attachments.all { it.isMedia() } }, previewContent = { modifier, attachments, onAttachmentRemoved -> ImageAttachmentPreviewContent(modifier = modifier,attachments = attachments, onAttachmentRemoved = onAttachmentRemoved )},content = @Composable { modifier, state ->ImageAttachmentContent(modifier = modifier.width(ChatTheme.dimens.attachmentsContentImageWidth).wrapContentHeight().heightIn(max = ChatTheme.dimens.attachmentsContentImageMaxHeight),attachmentState = state)},)"	An [AttachmentFactory] that validates attachments as images and uses [ImageAttachmentContent] to build the UI for the message.
"@Suppress(""FunctionName"") public fun LinkAttachmentFactory(linkDescriptionMaxLines: Int, ): AttachmentFactory = AttachmentFactory(canHandle = { links -> links.any { it.hasLink() && it.type != ModelType.attach_giphy } }, content = @Composable { modifier, state -> LinkAttachmentContent( modifier = modifier.width(ChatTheme.dimens.attachmentsContentLinkWidth).wrapContentHeight(),attachmentState = state,linkDescriptionMaxLines = linkDescriptionMaxLines)},)"	"An [AttachmentFactory] that validates attachments as images and uses [LinkAttachmentContent] to build the UI for the message. Has no ""preview content"", given that this attachment only exists after being sent."
"@Suppress(""FunctionName"") public fun QuotedAttachmentFactory(): AttachmentFactory = AttachmentFactory(canHandle = {if (it.isEmpty()) return@AttachmentFactory false val attachment = it.first() attachment.isFile() || attachment.isMedia() || attachment.hasLink() },content = @Composable { modifier, attachmentState ->val attachment = attachmentState.message.attachments.first() val isFile = attachment.isFile() val isImage = attachment.isMedia() val isLink = attachment.hasLink() when { isImage || isLink -> ImageAttachmentQuotedContent(modifier = modifier, attachment = attachment) isFile -> FileAttachmentQuotedContent(modifier = modifier, attachment = attachment)}})"	An [AttachmentFactory] that validates attachments as files and uses [ImageAttachmentQuotedContent] in case the attachment is a media attachment or [FileAttachmentQuotedContent] in case the attachment is a file to build the UI for the quoted message.
"@Suppress(""FunctionName"") public fun UploadAttachmentFactory(): AttachmentFactory = AttachmentFactory( canHandle = { attachments -> attachments.any {it.isUploading() } }, content = @Composable { modifier, state ->FileUploadContent(modifier = modifier.wrapContentHeight().width(ChatTheme.dimens.attachmentsContentFileUploadWidth),attachmentState = state)},)"	"An [AttachmentFactory] that validates and shows uploading attachments using [FileUploadContent]. Has no ""preview content"", given that this attachment only exists after being sent."
"public open class AttachmentFactory constructor( public val canHandle: (attachments: List<Attachment>) -> Boolean, public val previewContent: ( @Composable (modifier: Modifier,attachments: List<Attachment>,onAttachmentRemoved: (Attachment) -> Unit,) -> Unit)? = null,public val content: @Composable (modifier: Modifier,attachmentState: AttachmentState,) -> Unit,public val textFormatter: (attachments: Attachment) -> String = Attachment::previewText,)"	Holds the information required to build an attachment message.
"public fun defaultFactories( linkDescriptionMaxLines: Int = DEFAULT_LINK_DESCRIPTION_MAX_LINES,giphyInfoType: GiphyInfoType = GiphyInfoType.ORIGINAL,giphySizingMode: GiphySizingMode = GiphySizingMode.ADAPTIVE,contentScale: ContentScale = ContentScale.Crop,):List<AttachmentFactory> = listOf(UploadAttachmentFactory(),LinkAttachmentFactory(linkDescriptionMaxLines),GiphyAttachmentFactory(giphyInfoType = giphyInfoType,giphySizingMode = giphySizingMode,contentScale = contentScale,),ImageAttachmentFactory(),FileAttachmentFactory(),)"	"Default attachment factories we provide, which can transform image, file and link attachments."
public fun defaultQuotedFactories(): List<AttachmentFactory> = listOf(QuotedAttachmentFactory())}	"Default quoted attachment factories we provide, which can transform image, file and link attachments."
"@Composable public fun ChannelList(modifier: Modifier = Modifier,contentPadding: PaddingValues = PaddingValues(),viewModel: ChannelListViewModel = viewModel(factory =ChannelViewModelFactory(ChatClient.instance(),QuerySortByField.descByName(""last_updated""),filters = null)),lazyListState: LazyListState = rememberLazyListState(),onLastItemReached: () -> Unit = { viewModel.loadMore() },onChannelClick: (Channel) -> Unit = {},onChannelLongClick: (Channel) -> Unit = { viewModel.selectChannel(it) },loadingContent: @Composable () -> Unit = { LoadingIndicator(modifier) },emptyContent: @Composable () -> Unit = {DefaultChannelListEmptyContent(modifier) },emptySearchContent: @Composable (String) -> Unit = { searchQuery ->DefaultChannelSearchEmptyContent(searchQuery = searchQuery,modifier = modifier)},helperContent: @Composable BoxScope.() -> Unit = {},loadingMoreContent: @Composable () -> Unit = { DefaultChannelsLoadingMoreIndicator() },itemContent: @Composable (ChannelItemState) -> Unit = { channelItem ->val user by viewModel.user.collectAsState()DefaultChannelItem(channelItem = channelItem,currentUser = user,onChannelClick = onChannelClick,onChannelLongClick =onChannelLongClick)},divider: @Composable () -> Unit = { DefaultChannelItemDivider() },) {val user by viewModel.user.collectAsState()ChannelList(modifier = modifier,contentPadding = contentPadding,channelsState = viewModel.channelsState,currentUser = user,lazyListState = lazyListState,onLastItemReached =onLastItemReached,onChannelClick = onChannelClick,onChannelLongClick = onChannelLongClick,loadingContent = loadingContent,emptyContent = emptyContent,emptySearchContent = emptySearchContent,helperContent = helperContent,loadingMoreContent = loadingMoreContent,itemContent = itemContent,divider = divider)}"	"Default ChannelList component, that relies on the [ChannelListViewModel] to load the data and show it on the UI."
"@Composable public fun ChannelList( channelsState: ChannelsState,currentUser: User?,modifier: Modifier = Modifier,contentPadding: PaddingValues = PaddingValues(0.dp),lazyListState: LazyListState = rememberLazyListState(),onLastItemReached: () -> Unit = {},onChannelClick: (Channel) -> Unit = {},onChannelLongClick: (Channel) -> Unit = {},loadingContent: @Composable () -> Unit = { DefaultChannelListLoadingIndicator(modifier) },emptyContent: @Composable () -> Unit = { DefaultChannelListEmptyContent(modifier) },emptySearchContent: @Composable (String) -> Unit = { searchQuery ->DefaultChannelSearchEmptyContent(searchQuery = searchQuery,modifier = modifier)},helperContent: @Composable BoxScope.() -> Unit = {},loadingMoreContent: @Composable () -> Unit = {DefaultChannelsLoadingMoreIndicator() },itemContent: @Composable (ChannelItemState) -> Unit = { channelItem ->DefaultChannelItem(channelItem = channelItem,currentUser = currentUser,onChannelClick = onChannelClick,onChannelLongClick = onChannelLongClick)},divider: @Composable () -> Unit = { DefaultChannelItemDivider() },) {val (isLoading, _, _, channels, searchQuery) = channelsState when {isLoading -> loadingContent() !isLoading && channels.isNotEmpty() -> Channels( modifier = modifier, contentPadding = contentPadding, channelsState = channelsState, lazyListState = lazyListState, onLastItemReached = onLastItemReached, helperContent = helperContent, loadingMoreContent = loadingMoreContent, itemContent = itemContent, divider = divider searchQuery.isNotEmpty() -> emptySearchContent(searchQuery) else -> emptyContent()} }"	"Root Channel list component, that represents different UI, based on the current channel state.This is decoupled from ViewModels, so the user can provide manual and custom data handling,as well as define a completely custom UI component for the channel item.If there is no state, no query active or the data is being loaded, we show the [LoadingIndicator].If there are no results or we're offline, usually due to an error in the API or network, we show an [EmptyContent]. If there is data available and it is not empty, we show [Channels]."
"@Composable internal fun DefaultChannelItem( channelItem: ChannelItemState, currentUser: User?, onChannelClick: (Channel) -> Unit, onChannelLongClick: (Channel) -> Unit, ) {ChannelItem(channelItem = channelItem,currentUser = currentUser,onChannelClick = onChannelClick,onChannelLongClick = onChannelLongClick)}"	The default channel item.
@Composable internal fun DefaultChannelListLoadingIndicator(modifier: Modifier) {LoadingIndicator(modifier)}	Default loading indicator.
"@Composable internal fun DefaultChannelListEmptyContent(modifier: Modifier = Modifier) {EmptyContent(modifier = modifier,painter = painterResource(id = R.drawable.stream_compose_empty_channels),text = stringResource(R.string.stream_compose_channel_list_empty_channels),)}"	The default empty placeholder for the case when there are no channels available to the user.
"@Composable internal fun DefaultChannelSearchEmptyContent(searchQuery: String,modifier: Modifier = Modifier,) {EmptyContent(modifier = modifier,painter = painterResource(id = R.drawable.stream_compose_empty_search_results),text = stringResource(R.string.stream_compose_channel_list_empty_search_results, searchQuery),)}"	The default empty placeholder for the case when channel search returns no results.
@Composable public fun DefaultChannelItemDivider() { Spacer(modifier = Modifier.fillMaxWidth().height(0.5.dp).background(color = ChatTheme.colors.borders))}	Represents the default item divider in channel items.
"@Preview(showBackground = true, name = ""ChannelList Preview (Content state)"")@Composableprivate fun ChannelListForContentStatePreview() {ChannelListPreview(ChannelsState(isLoading = false,channelItems = listOf(ChannelItemState(channel = PreviewChannelData.channelWithImage),ChannelItemState(channel = PreviewChannelData.channelWithMessages),ChannelItemState(channel =PreviewChannelData.channelWithFewMembers),ChannelItemState(channel = PreviewChannelData.channelWithManyMembers),ChannelItemState(channel = PreviewChannelData.channelWithOnlineUser))))}"	Preview of [ChannelItem] for a list of channels. Should show a list of channels.
"@Preview(showBackground = true, name = ""ChannelList Preview (Empty state)"")@Composableprivate fun ChannelListForEmptyStatePreview() {ChannelListPreview(ChannelsState(isLoading = false,channelItems = emptyList()))}"	Preview of [ChannelItem] for an empty state.Should show an empty placeholder.
"@Preview(showBackground = true, name = ""ChannelList Preview (Loading state)"")@Composable private fun ChannelListForLoadingStatePreview() {ChannelListPreview(ChannelsState(isLoading = true))}"	Preview of [ChannelItem] for a loading state. Should show a progress indicator.
"@Composable private fun ChannelListPreview(channelsState: ChannelsState) {ChatTheme {ChannelList(modifier = Modifier.fillMaxSize(),channelsState = channelsState, currentUser = PreviewUserData.user1,)}}"	Shows [ChannelList] preview for the provided parameters.
"@Composable public fun Channels( channelsState: ChannelsState, lazyListState: LazyListState, onLastItemReached: () -> Unit, modifier: Modifier = Modifier, contentPadding: PaddingValues = PaddingValues(), helperContent: @Composable BoxScope.() -> Unit = {}, loadingMoreContent: @Composable () -> Unit = { DefaultChannelsLoadingMoreIndicator() }, itemContent: @Composable (ChannelItemState) -> Unit, divider: @Composable () -> Unit, ) { val (_, isLoadingMore, endOfChannels, channelItems) = channelsState Box(modifier = modifier) { LazyColumn( modifier = Modifier.fillMaxSize(), state = lazyListState, horizontalAlignment = Alignment.CenterHorizontally, contentPadding = contentPadding ) { item { DummyFirstChannelItem() }  items( items = channelItems, key = { it.channel.cid }) { item ->itemContent(item)divider()}if (isLoadingMore) {item {loadingMoreContent()}}} if (!endOfChannels && channelItems.isNotEmpty()) {LoadMoreHandler(lazyListState) {onLastItemReached() }}helperContent()}}"	"Builds a list of [ChannelItem] elements, based on [channelsState] and action handlers that it receives."
@Composable internal fun DefaultChannelsLoadingMoreIndicator() {LoadingFooter(modifier = Modifier.fillMaxWidth())}	The default loading more indicator.
@Composable private fun DummyFirstChannelItem() {Box(modifier = Modifier.height(1.dp).fillMaxWidth())}	"Represents an almost invisible dummy item to be added to the top of the list.If the list is scrolled to the top and a channel new item is added or moved to the position above, then the list will automatically autoscroll to it."
"@OptIn(ExperimentalFoundationApi::class)@Composablepublic fun ChannelItem(channelItem: ChannelItemState,currentUser: User?,onChannelClick: (Channel) -> Unit,onChannelLongClick: (Channel) -> Unit,modifier: Modifier = Modifier,leadingContent: @Composable RowScope.(ChannelItemState) -> Unit = {DefaultChannelItemLeadingContent(channelItem = it,currentUser = currentUser)},centerContent: @Composable RowScope.(ChannelItemState) -> Unit = { DefaultChannelItemCenterContent(channel = it.channel,isMuted = it.isMuted,currentUser = currentUser)},trailingContent: @Composable RowScope.(ChannelItemState) -> Unit = {DefaultChannelItemTrailingContent(channel = it.channel,currentUser = currentUser,)},) {val channel = channelItem.channelval description = stringResource(id = R.string.stream_compose_cd_channel_item)Column(modifier = modifier.fillMaxWidth().wrapContentHeight().semantics { contentDescription = description}.combinedClickable(onClick = { onChannelClick(channel) },onLongClick = { onChannelLongClick(channel) },indication = rememberRipple(),interactionSource = remember { MutableInteractionSource() }),) {Row(modifier = Modifier.fillMaxWidth(),verticalAlignment = Alignment.CenterVertically,) {leadingContent(channelItem)centerContent(channelItem)trailingContent(channelItem)}}}"	"The basic channel item, that shows the channel in a list and exposes single and long click actions."
"@Composable internal fun DefaultChannelItemLeadingContent(channelItem: ChannelItemState,currentUser: User?,) {ChannelAvatar(modifier = Modifier.padding(start = ChatTheme.dimens.channelItemHorizontalPadding,end = 4.dp,top = ChatTheme.dimens.channelItemVerticalPadding,bottom = ChatTheme.dimens.channelItemVerticalPadding).size(ChatTheme.dimens.channelAvatarSize),channel = channelItem.channel,currentUser = currentUser)}"	"Represents the default leading content of [ChannelItem], that shows the channel avatar."
"@Composableinternal fun RowScope.DefaultChannelItemCenterContent(channel: Channel,isMuted: Boolean,currentUser: User?,) {Column(modifier = Modifier.padding(start = 4.dp, end = 4.dp).weight(1f).wrapContentHeight(),verticalArrangement = Arrangement.Center) {val channelName: (@Composable (modifier: Modifier) -> Unit) = @Composable {Text(modifier = it,text = ChatTheme.channelNameFormatter.formatChannelName(channel, currentUser),style = ChatTheme.typography.bodyBold,fontSize = 16.sp,maxLines = 1,overflow = TextOverflow.Ellipsis,color = ChatTheme.colors.textHighEmphasis,)}if (isMuted) {Row(verticalAlignment = Alignment.CenterVertically) {channelName(Modifier.weight(weight = 1f, fill = false))Icon(modifier = Modifier.padding(start = 8.dp).size(16.dp), painter = painterResource(id = R.drawable.stream_compose_ic_muted),contentDescription = null,tint = ChatTheme.colors.textLowEmphasis,)}} else {channelName(Modifier)} val lastMessageText = channel.getLastMessage(currentUser)?.let { lastMessage -> ChatTheme.messagePreviewFormatter.formatMessagePreview(lastMessage, currentUser)} ?: AnnotatedString("""")if (lastMessageText.isNotEmpty()) {Text(text = lastMessageText,maxLines = 1,overflow = TextOverflow.Ellipsis,style = ChatTheme.typography.body,color = ChatTheme.colors.textLowEmphasis,)}}}"	"Represents the center portion of [ChannelItem], that shows the channel display name and the last message text preview."
"@Composable internal fun RowScope.DefaultChannelItemTrailingContent(channel: Channel,currentUser: User?,) {val lastMessage = channel.getLastMessage(currentUser) if (lastMessage != null) {Column(modifier = Modifier.padding(start = 4.dp,end = ChatTheme.dimens.channelItemHorizontalPadding,top = ChatTheme.dimens.channelItemVerticalPadding,bottom = ChatTheme.dimens.channelItemVerticalPadding).wrapContentHeight().align(Alignment.Bottom),horizontalAlignment = Alignment.End) {val unreadCount = channel.unreadCountif (unreadCount != null && unreadCount > 0) {UnreadCountIndicator(modifier = Modifier.padding(bottom = 4.dp),unreadCount = unreadCount)}val isLastMessageFromCurrentUser = lastMessage.user.id == currentUser?.id Row(verticalAlignment = Alignment.CenterVertically) {if (isLastMessageFromCurrentUser) {MessageReadStatusIcon(channel = channel,message = lastMessage,currentUser = currentUser,modifier = Modifier.padding(end = 8.dp).size(16.dp))} Timestamp(date = channel.lastUpdated)}}}}"	"Represents the default trailing content for the channel item. By default it shows the the information about the last message for the channel item, such as its read state,timestamp and how many unread messages the user has."
"@Preview(showBackground = true, name = ""ChannelItem Preview (Channel with unread)"") @Composableprivate fun ChannelItemForChannelWithUnreadMessagesPreview() {ChannelItemPreview(channel = PreviewChannelData.channelWithMessages,currentUser = PreviewUserData.user1)}"	"Preview of the [ChannelItem] component for a channel with unread messages. Should show unread count badge, delivery indicator and timestamp."
"@Preview(showBackground = true, name = ""ChannelItem Preview (Muted channel)"") @Composableprivate fun ChannelItemForMutedChannelPreview() {ChannelItemPreview(channel = PreviewChannelData.channelWithMessages,currentUser = PreviewUserData.user1,isMuted = true)}"	Preview of [ChannelItem] for a muted channel. Should show a muted icon next to the channel name.
"@Preview(showBackground = true, name = ""ChannelItem Preview (Without messages)"") @Composableprivate fun ChannelItemForChannelWithoutMessagesPreview() { ChannelItemPreview(channel = PreviewChannelData.channelWithImage, isMuted = false,currentUser = PreviewUserData.user1)}"	Preview of [ChannelItem] for a channel without messages. Should show only channel name that is centered vertically.
"@Composable private fun ChannelItemPreview(channel: Channel,isMuted: Boolean = false,currentUser: User? = null,) {ChatTheme {ChannelItem(channelItem = ChannelItemState(channel = channel,isMuted = isMuted),currentUser = currentUser,onChannelClick = {},onChannelLongClick = {})}}"	Shows [ChannelItem] preview for the provided parameters.
"@Composable public fun SelectedChannelMenu(selectedChannel: Channel,isMuted: Boolean,currentUser: User?,onChannelOptionClick: (ChannelAction) -> Unit, onDismiss: () -> Unit,modifier: Modifier = Modifier,shape: Shape = ChatTheme.shapes.bottomSheet,overlayColor: Color = ChatTheme.colors.overlay,headerContent: @Composable ColumnScope.() -> Unit = { DefaultSelectedChannelMenuHeaderContent( selectedChannel = selectedChannel,currentUser = currentUser)}, centerContent: @Composable ColumnScope.() -> Unit = {DefaultSelectedChannelMenuCenterContent(selectedChannel = selectedChannel,isMuted = isMuted,onChannelOptionClick = onChannelOptionClick,ownCapabilities = selectedChannel.ownCapabilities)},) {SimpleMenu(modifier = modifier, shape = shape,overlayColor = overlayColor,onDismiss = onDismiss,headerContent = headerContent,centerContent = centerContent)}"	"Shows special UI when an item is selected. It also prepares the available options for the channel, based on if we're an admin or not."
"@Composable internal fun DefaultSelectedChannelMenuHeaderContent(selectedChannel: Channel,currentUser: User?,) {val channelMembers = selectedChannel.membersval membersToDisplay = if (selectedChannel.isOneToOne(currentUser)) {channelMembers.filter { it.user.id != currentUser?.id }} else {channelMembers } Text(modifier = Modifier.fillMaxWidth().padding(start = 16.dp, end = 16.dp, top = 16.dp),textAlign = TextAlign.Center,text = ChatTheme.channelNameFormatter.formatChannelName(selectedChannel, currentUser),style = ChatTheme.typography.title3Bold,color = ChatTheme.colors.textHighEmphasis,maxLines = 1,overflow = TextOverflow.Ellipsis)Text(modifier = Modifier.fillMaxWidth(),textAlign = TextAlign.Center,text = selectedChannel.getMembersStatusText(LocalContext.current, currentUser),style = ChatTheme.typography.footnoteBold,color = ChatTheme.colors.textLowEmphasis,) ChannelMembers(membersToDisplay) }"	Represents the default content shown at the top of [SelectedChannelMenu] dialog.
"@Composable internal fun DefaultSelectedChannelMenuCenterContent(selectedChannel: Channel,isMuted: Boolean,onChannelOptionClick: (ChannelAction) -> Unit,ownCapabilities: Set<String>,) {val channelOptions = buildDefaultChannelOptionsState(selectedChannel = selectedChannel,isMuted = isMuted,ownCapabilities = ownCapabilities)ChannelOptions(channelOptions, onChannelOptionClick)}"	Represents the default content shown at the center of [SelectedChannelMenu] dialog.
"@Preview(showBackground = true, name = ""SelectedChannelMenu Preview (Centered dialog)"") @Composableprivate fun SelectedChannelMenuCenteredDialogPreview() {ChatTheme {Box(modifier = Modifier.fillMaxSize()) {SelectedChannelMenu(modifier = Modifier.padding(16.dp).fillMaxWidth().wrapContentHeight().align(Alignment.Center),shape = RoundedCornerShape(16.dp),selectedChannel =PreviewChannelData.channelWithManyMembers,isMuted = false,currentUser = PreviewUserData.user1,onChannelOptionClick = {},onDismiss = {})}}}"	Preview of [SelectedChannelMenu] styled as a centered modal dialog. Should show a centered dialog with channel members and channel options.
"@Preview(showBackground = true, name = ""SelectedChannelMenu Preview (Bottom sheet dialog)"") @Composableprivate fun SelectedChannelMenuBottomSheetDialogPreview() { ChatTheme {Box(modifier = Modifier.fillMaxSize()) {SelectedChannelMenu(modifier = Modifier.fillMaxWidth().wrapContentHeight().align(Alignment.BottomCenter),shape = ChatTheme.shapes.bottomSheet,selectedChannel = PreviewChannelData.channelWithManyMembers,isMuted = false,currentUser = PreviewUserData.user1,onChannelOptionClick = {},onDismiss = {})}}}"	Preview of [SelectedChannelMenu] styled as a bottom sheet dialog. Should show a bottom sheet dialog with channel members and channel options.
"@Composable public fun ChannelListHeader(modifier: Modifier = Modifier,title: String = """",currentUser: User? = null,connectionState: ConnectionState ConnectionState.CONNECTED,color: Color = ChatTheme.colors.barsBackground,shape: Shape = ChatTheme.shapes.header,elevation: Dp ChatTheme.dimens.headerElevation,onAvatarClick: (User?) -> Unit = {},onHeaderActionClick: () -> Unit = {},leadingContent: @Composable RowScope.() -> Unit = { DefaultChannelHeaderLeadingContent(currentUser = currentUser,onAvatarClick = onAvatarClick)},centerContent: @Composable RowScope.() -> Unit = { DefaultChannelListHeaderCenterContent( connectionState = connectionState,title = title)},trailingContent: @Composable RowScope.() -> Unit = {DefaultChannelListHeaderTrailingContent(onHeaderActionClick = onHeaderActionClick)},) {Surface(modifier = modifier.fillMaxWidth(),elevation = elevation,color = color,shape = shape) {Row(Modifier.fillMaxWidth().padding(8.dp),verticalAlignment = Alignment.CenterVertically,) {leadingContent()centerContent()trailingContent()}}}"	"A clean, decoupled UI element that doesn't rely on ViewModels or our custom architecture setup. This allows the user to fully govern how the [ChannelListHeader] behaves, by passing in all the data that's required to display it and drive its actions."
"@Composable internal fun DefaultChannelHeaderLeadingContent(currentUser: User?,onAvatarClick: (User?) -> Unit,) {val size = Modifier.size(40.dp)if (currentUser != null) { UserAvatar(modifier = size,user = currentUser,contentDescription = currentUser.name,showOnlineIndicator = false,onClick = { onAvatarClick(currentUser) })} else {Spacer(modifier = size)}}"	"Represents the default leading content for the [ChannelListHeader], which is a [UserAvatar]. We show the avatar if the user is available, otherwise we add a spacer to make sure the alignment is correct."
"@Composable internal fun RowScope.DefaultChannelListHeaderCenterContent( connectionState: ConnectionState, title: String,) {when (connectionState) {ConnectionState.CONNECTED -> {Text(modifier = Modifier.weight(1f).wrapContentWidth().padding(horizontal = 16.dp),text = title,style = ChatTheme.typography.title3Bold,maxLines = 1,color = ChatTheme.colors.textHighEmphasis)}ConnectionState.CONNECTING -> NetworkLoadingIndicator(modifier = Modifier.weight(1f))ConnectionState.OFFLINE -> {Text(modifier = Modifier.weight(1f).wrapContentWidth().padding(horizontal = 16.dp),text = stringResource(R.string.stream_compose_disconnected),style = ChatTheme.typography.title3Bold,maxLines = 1,color = ChatTheme.colors.textHighEmphasis)}}}"	"Represents the channel header's center slot. It either shows a [Text] if [connectionState] is [ConnectionState.CONNECTED], or a [NetworkLoadingIndicator] if there is no connections."
"@OptIn(ExperimentalMaterialApi::class) @Composableinternal fun DefaultChannelListHeaderTrailingContent(onHeaderActionClick: () -> Unit,) {Surface(modifier =Modifier.size(40.dp), onClick = onHeaderActionClick,interactionSource = remember { MutableInteractionSource() },color = ChatTheme.colors.primaryAccent,shape = ChatTheme.shapes.avatar,elevation = 4.dp) {Icon(modifier = Modifier.wrapContentSize(),painter = painterResource(id = R.drawable.stream_compose_ic_new_chat),contentDescription = stringResource(id = R.string.stream_compose_channel_list_header_new_chat),tint = Color.White,)}}"	"Represents the default trailing content for the [ChannelListHeader], which is an action icon."
"@Preview(name = ""ChannelListHeader Preview (Connected state)"")@Composableprivate fun ChannelListHeaderForConnectedStatePreview(){ChannelListHeaderPreview(connectionState = ConnectionState.CONNECTED)}"	"Preview of [ChannelListHeader] for the client that is connected to the WS. Should show a user avatar, a title, and an action button."
"@Preview(name = ""ChannelListHeader Preview (Connecting state)"") @Composable private fun ChannelListHeaderForConnectingStatePreview()  {ChannelListHeaderPreview(connectionState = ConnectionState.CONNECTING)}"	"Preview of [ChannelListHeader] for the client that is trying to connect to the WS. Should show a user avatar, ""Waiting for network"" caption, and an action button."
"@Composable private fun ChannelListHeaderPreview(title: String = ""Stream Chat"",currentUser: User? = PreviewUserData.user1,connectionState: ConnectionState = ConnectionState.CONNECTED,) {ChatTheme {ChannelListHeader(title = title,currentUser = currentUser,connectionState = connectionState)}}"	Shows [ChannelListHeader] preview for the provided parameters.
"internal class AboveAnchorPopupPositionProvider : PopupPositionProvider { override fun calculatePosition(anchorBounds: IntRect,windowSize: IntSize,layoutDirection: LayoutDirection,popupContentSize: IntSize,): IntOffset {return IntOffset(x = 0,y = anchorBounds.top - popupContentSize.height)}}"	Calculates the position of the suggestion list [Popup] on the screen.
"public fun defaultFormatter( context: Context,maxMembers: Int = 5,): ChannelNameFormatter {return DefaultChannelNameFormatter(context, maxMembers)}}}"	Build the default channel name formatter.
"private class DefaultChannelNameFormatter(private val context: Context,private val maxMembers: Int,) : ChannelNameFormatter {}"	A simple implementation of [ChannelNameFormatter] that allows to generate a name for a channel based on the following rules:
"override fun formatChannelName(channel: Channel, currentUser: User?): String {return channel.getDisplayName(context, currentUser,R.string.stream_compose_untitled_channel, maxMembers)}}"	Generates a name for the given channel.
public fun Channel.getLastMessage(currentUser: User?): Message? = getPreviewMessage(currentUser)	"Returns channel's last regular or system message if exists. Deleted and silent messages, as well as messages from shadow-banned users, are not taken into account."
public fun Channel.getReadStatuses(userToIgnore: User?): List<Date> { return read.filter { it.user.id != userToIgnore?.id }.mapNotNull { it.lastRead }}	Filters the read status of each person other than the target user.
"public fun Channel.isDistinct(): Boolean = cid.contains(""!members"")"	"Checks if the channel is distinct. A distinct channel is a channel created without ID based on members. Internally the server creates a CID which starts with ""!members"" prefix and is unique for this particular group of users."
public fun Channel.isOneToOne(currentUser: User?): Boolean { return isDistinct() && members.size == 2 && members.any { it.user.id == currentUser?.id } }	Checks if the channel is a direct conversation between the current user and some other user. A one-to-one chat is basically a corner case of a distinct channel with only 2 members.
"public fun Channel.getMembersStatusText(context: Context, currentUser: User?): String { return getMembersStatusText(context = context,currentUser = currentUser, userOnlineResId = R.string.stream_compose_user_status_online, userLastSeenJustNowResId = R.string.stream_compose_user_status_last_seen_just_now, userLastSeenResId = R.string.stream_compose_user_status_last_seen, memberCountResId = R.plurals.stream_compose_member_count, memberCountWithOnlineResId = R.string.stream_compose_member_count_online,) }"	Returns a string describing the member status of the channel: either a member count for a group channel or the last seen text for a direct one-to-one conversation with the current user.
public fun Channel.getOtherUsers(currentUser: User?): List<User> { val currentUserId = currentUser?.id return if (currentUserId != null) {members.filterNot { it.user.id == currentUserId }} else {members}.map { it.user } }	Returns a list of users that are members of the channel excluding the currently logged in user.
"@Composable @ReadOnlyComposable internal fun initialsGradient(initials: String): Brush {val gradientBaseColors = LocalContext.current.resources.getIntArray(R.array.stream_compose_avatar_gradient_colors)val baseColorIndex = abs(initials.hashCode()) % gradientBaseColors.sizeval baseColor = gradientBaseColors[baseColorIndex]return Brush.linearGradient(listOf(Color(adjustColorBrightness(baseColor, GradientDarkerColorFactor)),Color(adjustColorBrightness(baseColor, GradientLighterColorFactor)),))}"	Generates a gradient for an initials avatar based on the user initials.
"public fun Modifier.mirrorRtl(layoutDirection: LayoutDirection): Modifier { return this.scale( scaleX = if (layoutDirection == LayoutDirection.Ltr) 1f else -1f, scaleY = 1f ) }"	Applies the given mirroring scaleX based on the [layoutDirection] that's currently configured in the UI. Useful since the Painter from Compose doesn't know how to parse autoMirrored` flags in SVGs.
"@Composable public fun rememberStreamImagePainter( data: Any?, placeholderPainter: Painter? = null, errorPainter: Painter? = null, fallbackPainter: Painter? = errorPainter, onLoading: ((AsyncImagePainter.State.Loading) -> Unit)? = null, onSuccess: ((AsyncImagePainter.State.Success) -> Unit)? = null, onError: ((AsyncImagePainter.State.Error) -> Unit)? = null, contentScale: ContentScale = ContentScale.Fit, filterQuality: FilterQuality = DrawScope.DefaultFilterQuality, ): AsyncImagePainter { return rememberAsyncImagePainter( model = ImageRequest.Builder(LocalContext.current) .data(data).build(), imageLoader = LocalStreamImageLoader.current, placeholder = placeholderPainter, error = errorPainter, fallback = fallbackPainter, contentScale = contentScale, onSuccess = onSuccess, onError = onError, onLoading = onLoading, filterQuality = filterQuality ) }"	"Wrapper around the [coil.compose.rememberAsyncImagePainter] that plugs in our [LocalStreamImageLoader] singleton that can be used to customize all image loading requests, like adding headers, interceptors and similar."
public val LocalStreamImageLoader: StreamImageLoaderProvidableCompositionLocal = StreamImageLoaderProvidableCompositionLocal()	"A [CompositionLocal] that returns the current [ImageLoader] for the composition. If a local [ImageLoader] has not been provided, it returns the singleton instance of [ImageLoader] in [Coil]. "
"@JvmInline public value class StreamImageLoaderProvidableCompositionLocal internal constructor(private val delegate: ProvidableCompositionLocal<ImageLoader?> = staticCompositionLocalOf { null }, ) {public val current: ImageLoader@Composable@ReadOnlyComposableget() = delegate.current ?: LocalContext.current.imageLoader public infix fun provides(value: ImageLoader): ProvidedValue<ImageLoader?> = delegate provides value }"	A provider of [CompositionLocal] that returns the current [ImageLoader] for the composition.
"@Composable public fun rememberMessageListState(initialFirstVisibleItemIndex: Int = 0,initialFirstVisibleItemScrollOffset: Int = 0,parentMessageId: String? = null,): LazyListState {val baseListState = rememberLazyListState(initialFirstVisibleItemIndex, initialFirstVisibleItemScrollOffset) return if (parentMessageId != null) { rememberLazyListState() } else { baseListState } }"	"Provides a [LazyListState] that's tied to a given message list. This is the default behavior, where we keep the base scroll position of the list persisted at all times, while the thread scroll state is always new, whenever we enter a thread. In case you want to customize the behavior, provide the [LazyListState] based on your logic and conditions."
"private class DefaultMessagePreviewFormatter( private val context: Context,private val messageTextStyle: TextStyle,private val senderNameTextStyle: TextStyle,private val attachmentTextFontStyle: TextStyle,private val attachmentFactories: List<AttachmentFactory>,) : MessagePreviewFormatter {"	"The default implementation of [MessagePreviewFormatter] that allows to generate a preview text for a message with the following spans: sender name, message text, attachments preview text."
"override fun formatMessagePreview(message: Message,currentUser: User?,): AnnotatedString {return buildAnnotatedString {message.let { message ->val messageText = message.text.trim()if (message.isSystem()) {append(messageText)} else {appendSenderName(message = message,currentUser = currentUser,senderNameTextStyle = senderNameTextStyle)appendMessageText(messageText = messageText,messageTextStyle = messageTextStyle)appendAttachmentText(attachments = message.attachments, attachmentFactories = attachmentFactories,attachmentTextStyle = attachmentTextFontStyle)}}}}"	Generates a preview text for the given message.
"private fun AnnotatedString.Builder.appendSenderName(message: Message,currentUser: User?,senderNameTextStyle: TextStyle,) {val sender = message.getSenderDisplayName(context, currentUser)if (sender != null) {append(""$sender: "")addStyle(SpanStyle(fontStyle = senderNameTextStyle.fontStyle,fontWeight = senderNameTextStyle.fontWeight,fontFamily = senderNameTextStyle.fontFamily),start = 0,end = sender.length)}}"	Appends the sender name to the [AnnotatedString].
"private fun AnnotatedString.Builder.appendMessageText(messageText: String,messageTextStyle: TextStyle,) {if (messageText.isNotEmpty()) {val startIndex = this.lengthappend(""$messageText "")addStyle(SpanStyle(fontStyle = messageTextStyle.fontStyle,fontFamily = messageTextStyle.fontFamily),start = startIndex,end = startIndex + messageText.length)}}"	Appends the message text to the [AnnotatedString].
"private fun AnnotatedString.Builder.appendAttachmentText(attachments: List<Attachment>,attachmentFactories: List<AttachmentFactory>,attachmentTextStyle: TextStyle,) {if (attachments.isNotEmpty()) {attachmentFactories.firstOrNull { it.canHandle(attachments) }?.textFormatter?.let { textFormatter ->attachments.mapNotNull { attachment ->textFormatter.invoke(attachment).let { previewText ->previewText.ifEmpty { null }}}.joinToString()}?.let { attachmentText ->val startIndex = this.lengthappend(attachmentText) addStyle(SpanStyle(fontStyle = attachmentTextStyle.fontStyle,fontFamily = attachmentTextStyle.fontFamily),start = startIndex,end = startIndex + attachmentText.length)}}}}"	Appends a string representations of [attachments] to the [AnnotatedString].
fun getIconRes(mimeType: String?): Int {if (mimeType == null) {return R.drawable.stream_compose_ic_file_generic}return mimeTypesToIconResMap[mimeType] ?: when { mimeType.contains(ModelType.attach_audio) -> R.drawable.stream_compose_ic_file_audio_genericmimeType.contains(ModelType.attach_video) -> R.drawable.stream_compose_ic_file_video_genericelse -> R.drawable.stream_compose_ic_file_generic}}	Returns a drawable resource for the given MIME type.
"private class DefaultReactionIconFactory( private val supportedReactions: Map<String, ReactionDrawable> = mapOf(THUMBS_UP to ReactionDrawable(iconResId = R.drawable.stream_compose_ic_reaction_thumbs_up,selectedIconResId = R.drawable.stream_compose_ic_reaction_thumbs_up_selected),LOVE to ReactionDrawable(iconResId = R.drawable.stream_compose_ic_reaction_love,selectedIconResId = R.drawable.stream_compose_ic_reaction_love_selected),LOL to ReactionDrawable(iconResId = R.drawable.stream_compose_ic_reaction_lol,selectedIconResId = R.drawable.stream_compose_ic_reaction_lol_selected),WUT to ReactionDrawable(iconResId = R.drawable.stream_compose_ic_reaction_wut,selectedIconResId = R.drawable.stream_compose_ic_reaction_wut_selected),THUMBS_DOWN to ReactionDrawable(iconResId = R.drawable.stream_compose_ic_reaction_thumbs_down,selectedIconResId = R.drawable.stream_compose_ic_reaction_thumbs_down_selected)),) : ReactionIconFactory { }"	The default implementation of [ReactionIconFactory] that uses drawable resources to create reaction icons.
override fun isReactionSupported(type: String): Boolean {return supportedReactions.containsKey(type)}	Checks if the factory is capable of creating an icon for the given reaction type.
"@Composable override fun createReactionIcon(type: String): ReactionIcon {val reactionDrawable = requireNotNull(supportedReactions[type])return ReactionIcon(painter = painterResource(reactionDrawable.iconResId),selectedPainter = painterResource(reactionDrawable.selectedIconResId))}"	Creates an instance of [ReactionIcon] for the given reaction type.
"@Composable override fun createReactionIcons(): Map<String, ReactionIcon> {return supportedReactions.mapValues { createReactionIcon(it.key)}} companion object { private const val LOVE: String = ""love"" private const val THUMBS_UP: String = ""like""private const val THUMBS_DOWN: String = ""sad""private const val LOL: String = ""haha""private const val WUT: String = ""wow""}}"	Creates [ReactionIcon]s for all the supported reaction types.
"public data class ReactionDrawable(@DrawableRes public val iconResId: Int,@DrawableRes public val selectedIconResId: Int,)"	Contains drawable resources for normal and selected reaction states.
"public data class ReactionIcon(val painter: Painter,val selectedPainter: Painter,) {}"	Contains [Painter]s for normal and selected states of the reaction icon.
public fun getFiles(): List<AttachmentMetaData> { return attachmentFilter.filterAttachments(storageHelper.getFileAttachments(context)) }	Loads a list of file metadata from the system and filters it against file types accepted by the backend.
public fun getMedia(): List<AttachmentMetaData> { return attachmentFilter.filterAttachments(storageHelper.getMediaAttachments(context)) }	Loads a list of media metadata from the system.
public fun getAttachmentsForUpload(attachments: List<AttachmentMetaData>): List<Attachment> { return getAttachmentsFromMetaData(attachments) }	Transforms a list of [AttachmentMetaData] into a list of [Attachment]s. This is required because we need to prepare the files for upload.
"private fun getAttachmentsFromMetaData(metaData: List<AttachmentMetaData>): List<Attachment> { return metaData.map { val fileFromUri = storageHelper.getCachedFileFromUri(context, it) Attachment( upload = fileFromUri, type = it.type, name = it.title ?: fileFromUri.name ?: """", fileSize = it.size.toInt(), mimeType = it.mimeType ) } }"	"Loads attachment files from the provided metadata, so that we can upload them."
public fun getAttachmentsFromUris(uris: List<Uri>): List<Attachment> { return getAttachmentsMetadataFromUris(uris).let(::getAttachmentsFromMetaData) }	Takes a list of file Uris and transforms them into a list of [Attachment]s so that we can upload them.
"public fun getAttachmentsMetadataFromUris(uris: List<Uri>): List<AttachmentMetaData> { return storageHelper.getAttachmentsFromUriList(context, uris) .let(attachmentFilter::filterAttachments) }"	Takes a list of file Uris and transforms them into a list of [AttachmentMetaData].
"public fun User.getLastSeenText(context: Context): String { return getLastSeenText(context = contextuserOnlineResId = R.string.stream_compose_user_status_online,userLastSeenJustNowResId = R.string.stream_compose_user_status_last_seen_just_now,userLastSeenResId = R.string.stream_compose_user_status_last_seen,)}"	"Returns a string describing the elapsed time since the user was online (was watching the channel). Depending on the elapsed time, the string can have one of the following formats:- Online - Last seen just now - Last seen 13 hours ago"
"@Composable public fun AttachmentsPicker(attachmentsPickerViewModel: AttachmentsPickerViewModel,onAttachmentsSelected: (List<Attachment>) -> Unit,onDismiss: () -> Unit, modifier: Modifier = Modifier, tabFactories: List<AttachmentsPickerTabFactory> = ChatTheme.attachmentsPickerTabFactories,shape: Shape = ChatTheme.shapes.bottomSheet,) {var selectedTabIndex by remember { mutableStateOf(0) }Box(modifier = Modifier.fillMaxSize().background(ChatTheme.colors.overlay).clickable(onClick = onDismiss,indication = null,interactionSource = remember { MutableInteractionSource() })) {Card(modifier = modifier.clickable(indication = null,onClick = {},interactionSource = remember { MutableInteractionSource() }),elevation = 4.dp,shape = shape,backgroundColor = ChatTheme.colors.inputBackground,) {Column {AttachmentPickerOptions(hasPickedAttachments = attachmentsPickerViewModel.hasPickedAttachments,tabFactories = tabFactories,tabIndex = selectedTabIndex,onTabClick = { index, attachmentPickerMode -> selectedTabIndex = indexattachmentsPickerViewModel.changeAttachmentPickerMode(attachmentPickerMode) { false }},onSendAttachmentsClick = {onAttachmentsSelected(attachmentsPickerViewModel.getSelectedAttachments())},)Surface(modifier = Modifier.fillMaxSize(),shape = RoundedCornerShape(topStart =16.dp, topEnd = 16.dp),color = ChatTheme.colors.barsBackground,) {tabFactories.getOrNull(selectedTabIndex)?.pickerTabContent(attachments =attachmentsPickerViewModel.attachments,onAttachmentItemSelected = attachmentsPickerViewModel::changeSelectedAttachments,onAttachmentsChanged = { attachmentsPickerViewModel.attachments = it },onAttachmentsSubmitted = {onAttachmentsSelected(attachmentsPickerViewModel.getAttachmentsFromMetaData(it))},)}}}}}"	"Represents the bottom bar UI that allows users to pick attachments. The picker renders its tabs based on the [tabFactories] parameter. Out of the box we provide factories for images, files and media capture tabs."
"Composable private fun AttachmentPickerOptions( hasPickedAttachments: Boolean, tabFactories: List<AttachmentsPickerTabFactory>, tabIndex: Int, onTabClick: (Int, AttachmentsPickerMode) -> Unit, onSendAttachmentsClick: () -> Unit, ) { Row( Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically ) { Row(horizontalArrangement = Arrangement.SpaceEvenly) { tabFactories.forEachIndexed { index, tabFactory -> val isSelected = index == tabIndex val isEnabled = isSelected || (!isSelected && !hasPickedAttachments) IconButton( enabled = isEnabled, content = { tabFactory.pickerTabIcon( isEnabled = isEnabled, isSelected = isSelected ) }, onClick = { onTabClick(index, tabFactory.attachmentsPickerMode) } ) } }  Spacer(modifier = Modifier.weight(1f))  IconButton( enabled = hasPickedAttachments, onClick = onSendAttachmentsClick, content = { val layoutDirection = LocalLayoutDirection.current  Icon( modifier = Modifier .weight(1f).mirrorRtl(layoutDirection = layoutDirection),painter = painterResource(id = R.drawable.stream_compose_ic_circle_left),contentDescription = stringResource(id = R.string.stream_compose_send_attachment),tint = if (hasPickedAttachments){ChatTheme.colors.primaryAccent} else {ChatTheme.colors.textLowEmphasis})})}}"	The options for the Attachment picker. Shows tabs based on the provided list of [tabFactories] and a button to submit the selected attachments.
"@Composable override fun pickerTabIcon(isEnabled: Boolean, isSelected: Boolean) {Icon(painter = painterResource(id =R.drawable.stream_compose_ic_media_picker),contentDescription = stringResource(id = R.string.stream_compose_capture_option),tint = when {isSelected -> ChatTheme.colors.primaryAccentisEnabled -> ChatTheme.colors.textLowEmphasiselse -> ChatTheme.colors.disabled},)}"	Emits a camera icon for this tab.
"@OptIn(ExperimentalPermissionsApi::class) @Composable override fun pickerTabContent(attachments: List<AttachmentPickerItemState>,onAttachmentsChanged: (List<AttachmentPickerItemState>) -> Unit,onAttachmentItemSelected: (AttachmentPickerItemState) -> Unit,onAttachmentsSubmitted: (List<AttachmentMetaData>) -> Unit,) {val context = LocalContext.current val requiresCameraPermission = isCameraPermissionDeclared(context) val cameraPermissionState = if (requiresCameraPermission) rememberPermissionState(permission = Manifest.permission.CAMERA) else null val mediaCaptureResultLauncher = rememberLauncherForActivityResult(contract = CaptureMediaContract()) { file: File? -> val attachments = if (file == null) {emptyList()} else {listOf(AttachmentMetaData(context, file))} onAttachmentsSubmitted(attachments) }  if (cameraPermissionState == null || cameraPermissionState.status == PermissionStatus.Granted) { Box(modifier = Modifier.fillMaxSize()) { LaunchedEffect(Unit) { mediaCaptureResultLauncher.launch(Unit) } } } else if (cameraPermissionState.status is PermissionStatus.Denied) { MissingPermissionContent(cameraPermissionState) } }"	Emits content that allows users to start media capture.
"private fun isCameraPermissionDeclared(context: Context): Boolean { return context.packageManager.getPackageInfo(context.packageName, PackageManager.GET_PERMISSIONS) .requestedPermissions .contains(Manifest.permission.CAMERA) }"	Returns if we need to check for the camera permission or not.
"public fun defaultFactories(imagesTabEnabled: Boolean = true,filesTabEnabled: Boolean = true,mediaCaptureTabEnabled: Boolean = true,): List<AttachmentsPickerTabFactory> {return listOfNotNull(if (imagesTabEnabled) AttachmentsPickerImagesTabFactory() else null,if (filesTabEnabled) AttachmentsPickerFilesTabFactory() else null,if (mediaCaptureTabEnabled) AttachmentsPickerMediaCaptureTabFactory() else null,)}"	Builds the default list of attachment picker tab factories.
"@Composable public fun pickerTabContent(attachments: List<AttachmentPickerItemState>,onAttachmentsChanged: (List<AttachmentPickerItemState>) -> Unit,onAttachmentItemSelected: (AttachmentPickerItemState) -> Unit,onAttachmentsSubmitted: (List<AttachmentMetaData>) -> Unit,)"	Emits a content for the tab.
"@Composable public fun pickerTabIcon(isEnabled: Boolean, isSelected: Boolean)"	Emits an icon for the tab.
private val filterFlow: MutableStateFlow<FilterObject?> = MutableStateFlow(initialFilters)	State flow that keeps the value of the current [FilterObject] for channels.
private val querySortFlow: MutableStateFlow<QuerySorter<Channel>> = MutableStateFlow(initialSort)	State flow that keeps the value of the current [QuerySorter] for channels.
"private val queryConfigFlow = filterFlow.filterNotNull().combine(querySortFlow) { filters, sort -> QueryConfig(filters = filters, querySort = sort) }"	"The currently active query configuration, stored in a [MutableStateFlow]. It's created using the `initialFilters` parameter and the initial sort, but can be changed."
"private val searchQuery = MutableStateFlow("""")"	"The current state of the search input. When changed, it emits a new value in a flow, which queries and loads new data."
public var channelsState: ChannelsState by mutableStateOf(ChannelsState()) private set	The current state of the channels screen. It holds all the information required to render the UI.
public var selectedChannel: MutableState<Channel?> = mutableStateOf(null) private set	"Currently selected channel, if any. Used to show the bottom drawer information when long tapping on a list item."
public var activeChannelAction: ChannelAction? by mutableStateOf(null) private set	"Currently active channel action, if any. Used to show a dialog for deleting or leaving a channel/conversation."
public val connectionState: StateFlow<ConnectionState> = chatClient.clientState.connectionState	"The state of our network connection - if we're online, connecting or offline."
public val user: StateFlow<User?> = chatClient.clientState.user	The state of the currently logged in user.
public val channelMutes: StateFlow<List<ChannelMute>> = chatClient.globalState.channelMutes	Gives us the information about the list of channels mutes by the current user.
private fun buildDefaultFilter(): Flow<FilterObject> { return chatClient.clientState.user.map(Filters::defaultChannelListFilter).filterNotNull() }	"Builds the default channel filter, which represents ""messaging"" channels that the current user is a part of."
public fun isChannelMuted(cid: String): Boolean {return channelMutes.value.any { cid == it.channel.cid }}	Checks if the channel is muted for the current user.
private var queryChannelsState: StateFlow<QueryChannelsState?> = MutableStateFlow(null)	"Current query channels state that contains filter, sort and other states related to channels query."
init { if (initialFilters == null) {viewModelScope.launch {val filter = buildDefaultFilter().first()this@ChannelListViewModel.filterFlow.value = filter}}viewModelScope.launch {init()}}	Combines the latest search query and filter to fetch channels and emit them to the UI.
"private suspend fun init() { logger.d { ""Initializing ChannelListViewModel"" } searchQuery.combine(queryConfigFlow) { query, config -> query to config }.collectLatest { (query, config) ->val queryChannelsRequest = QueryChannelsRequest(filter = createQueryChannelsFilter(config.filters, query),querySort = config.querySort,limit = channelLimit,messageLimit = messageLimit,memberLimit = memberLimit,) logger.d { ""Querying channels as state"" } queryChannelsState = chatClient.queryChannelsAsState( request = queryChannelsRequest, chatEventHandlerFactory = chatEventHandlerFactory, coroutineScope = viewModelScope, )observeChannels(searchQuery = query)}}"	Makes the initial query to request channels and starts observing state changes.
"private fun createQueryChannelsFilter(filter: FilterObject, searchQuery: String): FilterObject { return if (searchQuery.isNotEmpty()) {Filters.and(Filter,Filters.or(Filters.and( Filters.autocomplete(""member.user.name"", searchQuery),Filters.notExists(""name"")),Filters.autocomplete(""name"", searchQuery)))} else {filter}}"	"Creates a filter that is used to query channels. If the [searchQuery] is empty, then returns the original [filter] provided by the user. Otherwise, returns a wrapped [filter] that also checks that the channel name match the [searchQuery]."
"private suspend fun observeChannels(searchQuery: String) { logger.d { ""ViewModel is observing channels. When state is available, it will be notified"" }queryChannelsState.filterNotNull().collectLatest { queryChannelsState ->channelMutes.combine(queryChannelsState.channelsStateData, ::Pair).map { (channelMutes, state) ->when (state) {ChannelsStateData.NoQueryActive,ChannelsStateData.Loading,-> channelsState.copy(isLoading = true,searchQuery = searchQuery).also {logger.d { ""Loading state for query"" }}ChannelsStateData.OfflineNoResults -> {logger.d { ""No offline results. Channels are empty"" }channelsState.copy(isLoading = false,channelItems = emptyList(),searchQuery = searchQuery)}is ChannelsStateData.Result -> {logger.d { ""Received result for state of channels"" }channelsState.copy(isLoading = false,channelItems = createChannelItems(state.channels, channelMutes),isLoadingMore = false,endOfChannels = queryChannelsState.endOfChannels.value,searchQuery = searchQuery)}}}.collectLatest { newState -> channelsState = newState }}}"	"Kicks off operations required to combine and build the [ChannelsState] object for the UI. t connects the 'loadingMore', 'channelsState' and 'endOfChannels' properties from the [queryChannelsState]. @param searchQuery The search query string used to search channels."
public fun selectChannel(channel: Channel?) { this.selectedChannel.value = channel}	Changes the currently selected channel state. This updates the UI state and allows us to observe the state change.
public fun setSearchQuery(newQuery: String) { this.searchQuery.value = newQuery}	Changes the current query state. This updates the data flow and triggers another query operation. The new operation will hold the channels that match the new query.
public fun setFilters(newFilters: FilterObject) {this.filterFlow.tryEmit(value = newFilters)}	Allows for the change of filters used for channel queries.
public fun setQuerySort(querySort: QuerySorter<Channel>) {this.querySortFlow.tryEmit(value = querySort)}	Allows for the change of the query sort used for channel queries.
"public fun loadMore() {logger.d { ""Loading more channels"" }if (chatClient.clientState.isOffline) returnval currentConfig = QueryConfigfilters = filterFlow.value ?: return, querySort = querySortFlow.value)channelsState = channelsState.copy(isLoadingMore = true)val currentQuery = queryChannelsState.value?.nextPageRequest?.value currentQuery?.copy( filter = createQueryChannelsFilter(currentConfig.filters, searchQuery.value),querySort = currentConfig.querySort)?.let { queryChannelsRequest ->chatClient.queryChannels(queryChannelsRequest).enqueue()}}"	Loads more data when the user reaches the end of the channels list.
public fun performChannelAction(channelAction: ChannelAction) { if (channelAction is Cancel) {selectedChannel.value = null}activeChannelAction = if (channelAction == Cancel) {null} else { channelAction} }	"Clears the active action if we've chosen [Cancel], otherwise, stores the selected action as the currently active action, in [activeChannelAction]."
"public fun muteChannel(channel: Channel) { dismissChannelAction()  chatClient.muteChannel(channel.type, channel.id).enqueue() }"	Mutes a channel.
"public fun unmuteChannel(channel: Channel) { dismissChannelAction() chatClient.unmuteChannel(channel.type, channel.id).enqueue() }"	Unmutes a channel. @param channel The channel to unmute.
public fun deleteConversation(channel: Channel) { dismissChannelAction() chatClient.channel(channel.cid).delete().toUnitCall().enqueue() }	"Deletes a channel, after the user chooses the delete [ChannelAction]. It also removes the [activeChannelAction], to remove the dialog from the UI."
"public fun leaveGroup(channel: Channel) { dismissChannelAction()  chatClient.getCurrentUser()?.let { user -> chatClient.channel(channel.type, channel.id).removeMembers(listOf(user.id)).enqueue() } }"	"Leaves a channel, after the user chooses the leave [ChannelAction]. It also removes the [activeChannelAction], to remove the dialog from the UI."
public fun dismissChannelAction() { activeChannelAction = null selectedChannel.value = null }	Dismisses the [activeChannelAction] and removes it from the UI.
"private fun createChannelItems(channels: List<Channel>, channelMutes: List<ChannelMute>): List<ChannelItemState> { val mutedChannelIds = channelMutes.map { channelMute -> channelMute.channel.cid }.toSet() return channels.map { ChannelItemState(it, it.cid in mutedChannelIds) } }"	Creates a list of [ChannelItemState] that represents channel items we show in the list of channels.
public val user: StateFlow<User?> = chatClient.clientState.user	The currently logged in user.
public var message: Message by mutableStateOf(Message()) private set	Represents the message that we observe to show the UI data.
public var isShowingOptions: Boolean by mutableStateOf(false) private set	Shows or hides the image options menu and overlay in the UI.
public var isShowingGallery: Boolean by mutableStateOf(false) private set	Shows or hides the image gallery menu in the UI.
init { chatClient.getMessage(messageId).enqueue { result ->if (result.isSuccess) {this.message = result.data()}}}	"Loads the message data, which then updates the UI state to shows images."
public fun toggleImageOptions(isShowingOptions: Boolean) {this.isShowingOptions = isShowingOptions}	Toggles if we're showing the image options menu.
public fun toggleGallery(isShowingGallery: Boolean) {this.isShowingGallery = isShowingGallery}	Toggles if we're showing the gallery screen.
public fun deleteCurrentImage(currentImage: Attachment) {val attachments = message.attachmentsval numberOfAttachments = attachments.sizeif (message.text.isNotEmpty() || numberOfAttachments > 1) {val imageUrl = currentImage.assetUrl ?: currentImage.imageUrlval message = message attachments.removeAll { it.assetUrl == imageUrl || it.imageUrl == imageUrl} chatClient.updateMessage(message).enqueue()} else if (message.text.isEmpty() && numberOfAttachments == 1) { chatClient.deleteMessage(message.id).enqueue { result ->if (result.isSuccess) { message = result.data()}}}}	"Deletes the current image from the message we're observing, if possible. This will in turn update the UI accordingly or finish this screen in case there are no more images to show."
public var attachmentsPickerMode: AttachmentsPickerMode by mutableStateOf(Images) private set	"Currently selected picker mode. [Images], [Files] or [MediaCapture]."
public var images: List<AttachmentPickerItemState> by mutableStateOf(emptyList())	"List of images available, from the system."
public var files: List<AttachmentPickerItemState> by mutableStateOf(emptyList())	"List of files available, from the system."
public var attachments: List<AttachmentPickerItemState> by mutableStateOf(emptyList())	"List of attachments available, from the system."
public val hasPickedFiles: Boolean get() = files.any { it.isSelected }	Gives us info if there are any file items that are selected.
public val hasPickedImages: Boolean get() = images.any { it.isSelected }	Gives us info if there are any image items that are selected.
public val hasPickedAttachments: Boolean get() = attachments.any { it.isSelected }	Gives us info if there are any attachment items that are selected.
public var isShowingAttachments: Boolean by mutableStateOf(false) private set	Gives us information if we're showing the attachments picker or not.
public fun loadData() { loadAttachmentsData(attachmentsPickerMode)}	Loads all the items based on the current type.
"public fun changeAttachmentPickerMode( attachmentsPickerMode: AttachmentsPickerMode, hasPermission: () -> Boolean = { true },) {this.attachmentsPickerMode = attachmentsPickerMode if (hasPermission()) loadAttachmentsData(attachmentsPickerMode) }"	Changes the currently selected [AttachmentsPickerMode] and loads the required data. If no permission is granted will not try and load data to avoid crashes.
public fun changeAttachmentState(showAttachments: Boolean) { isShowingAttachments = showAttachments  if (!showAttachments) {dismissAttachments()}}	Notifies the ViewModel if we should show attachments or not.
"private fun loadAttachmentsData(attachmentsPickerMode: AttachmentsPickerMode) { if (attachmentsPickerMode == Images) {val images = storageHelper.getMedia().map { AttachmentPickerItemState(it, false) } this.images = images this.attachments = images this.files = emptyList() } else if (attachmentsPickerMode == Files) {val files = storageHelper.getFiles().map { AttachmentPickerItemState(it, false) } this.files = files this.attachments = files this.images = emptyList() } }"	"Loads the attachment data, based on the [AttachmentsPickerMode]."
"public fun changeSelectedAttachments(attachmentItem: AttachmentPickerItemState) { val dataSet = attachments val itemIndex = dataSet.indexOf(attachmentItem) val newFiles = dataSet.toMutableList() val newItem = dataSet[itemIndex].copy(isSelected = !newFiles[itemIndex].isSelected) newFiles.removeAt(itemIndex)  newFiles.add(itemIndex, newItem) if (attachmentsPickerMode == Files) { files = newFiles } else if (attachmentsPickerMode == Images) { images = newFiles } attachments = newFiles }"	"Triggered when an [AttachmentMetaData] is selected in the list. Added or removed from the corresponding list, be it [files] or [images], based on [attachmentsPickerMode]."
public fun getSelectedAttachments(): List<Attachment> { val dataSet = if (attachmentsPickerMode == Files) files else images val selectedAttachments = dataSet.filter { it.isSelected } return storageHelper.getAttachmentsForUpload(selectedAttachments.map { it.attachmentMetaData }) }	"Loads up the currently selected attachments. It uses the [attachmentsPickerMode] to know which attachments to use - files or images. It maps all files to a list of [Attachment] objects, based on their type."
public fun getAttachmentsFromUris(uris: List<Uri>): List<Attachment> { return storageHelper.getAttachmentsFromUris(uris) }	Transforms selected file Uris to a list of [Attachment]s we can upload.
public fun getAttachmentsFromMetaData(metaData: List<AttachmentMetaData>): List<Attachment> { return storageHelper.getAttachmentsForUpload(metaData) }	Transforms the selected meta data into a list of [Attachment]s we can upload.
public fun dismissAttachments() { attachmentsPickerMode = Images images = emptyList() files = emptyList() }	"Triggered when we dismiss the attachments picker. We reset the state to show images and clear the items for now, until the user needs them again."
"private val channelState: StateFlow<ChannelState?> = chatClient.watchChannelAsState( cid = channelId, messageLimit = messageLimit, coroutineScope = viewModelScope)"	Holds information about the current state of the [Channel].
"private val ownCapabilities: StateFlow<Set<String>> = channelState.filterNotNull().flatMapLatest { it.channelData }.map { it.ownCapabilities }.stateIn(scope =viewModelScope,started = SharingStarted.Eagerly,initialValue = setOf())"	Holds information about the abilities the current user is able to exercise in the given channel.
public val currentMessagesState: MessagesState get() = if (isInThread) threadMessagesState else messagesState	"State handler for the UI, which holds all the information the UI needs to render messages. It chooses between [threadMessagesState] and [messagesState] based on if we're in a thread or not."
private var messagesState: MessagesState by mutableStateOf(MessagesState())	"State of the screen, for [MessageMode.Normal]."
private var threadMessagesState: MessagesState by mutableStateOf(MessagesState())	"State of the screen, for [MessageMode.MessageThread]."
public var messageMode: MessageMode by mutableStateOf(MessageMode.Normal) private set	Holds the current [MessageMode] that's used for the messages list. [MessageMode.Normal] by default.
public var channel: Channel by mutableStateOf(Channel()) private set	The information for the current [Channel].
public var typingUsers: List<User> by mutableStateOf(emptyList()) private set	The list of typing users.
public var messageActions: Set<MessageAction> by mutableStateOf(mutableSetOf()) private set	"Set of currently active [MessageAction]s. Used to show things like edit, reply, delete and similar actions."
public val isInThread: Boolean get() = messageMode is MessageMode.MessageThread	Gives us information if we're currently in the [Thread] message mode.
public val isShowingOverlay: Boolean get() = messagesState.selectedMessageState != null || threadMessagesState.selectedMessageState != null	Gives us information if we have selected a message.
public val connectionState: StateFlow<ConnectionState> by chatClient.clientState::connectionState	Gives us information about the online state of the device.
public val isOnline: Flow<Boolean> get() = chatClient.clientState.connectionState.map { it == ConnectionState.CONNECTED }	Gives us information about the online state of the device.
public val user: StateFlow<User?> get() = chatClient.clientState.user	Gives us information about the logged in user state.
private var threadJob: Job? = null	[Job] that's used to keep the thread data loading operations. We cancel it when the user goes out of the thread state.
private var lastLoadedMessage: Message? = null	"Represents the last loaded message in the list, for comparison when determining the [NewMessageState] for the screen."
private var lastLoadedThreadMessage: Message? = null	"Represents the last loaded message in the thread, for comparison when determining the NewMessage"
private var lastSeenChannelMessage: Message? by mutableStateOf(null)	Represents the latest message we've seen in the channel.
private var lastSeenThreadMessage: Message? by mutableStateOf(null)	Represents the latest message we've seen in the active thread.
private var scrollToMessage: Message? = null	Represents the message we wish to scroll to.
"private val logger = StreamLog.getLogger(""Chat:MessageListViewModel"")"	Instance of [TaggedLogger] to log exceptional and warning cases in behavior.
init { observeTypingUsers() observeMessages() observeChannel()}	Sets up the core data loading operations - such as observing the current channel and loading messages and other pieces of information.
"private fun observeMessages() { viewModelScope.launch { channelState.filterNotNull().collectLatest { channelState ->combine(channelState.messagesState, user, channelState.reads) { state, user, reads -> when (state) { is io.getstream.chat.android.offline.plugin.state.channel.MessagesState.NoQueryActive,is io.getstream.chat.android.offline.plugin.state.channel.MessagesState.Loading, -> messagesState.copy(isLoading = true) is io.getstream.chat.android.offline.plugin.state.channel.MessagesState.OfflineNoResults -> messagesState.copy( isLoading = false, messageItems = emptyList(), ) is io.getstream.chat.android.offline.plugin.state.channel.MessagesState.Result -> { messagesState.copy( isLoading = false, messageItems = groupMessages( messages = filterMessagesToShow(state.messages), isInThread = false, reads = reads, ), isLoadingMore = false, endOfMessages = channelState.endOfOlderMessages.value, currentUser = user, ) } } } .catch { it.cause?.printStackTrace() showEmptyState() } .collect { newState -> val newLastMessage = (newState.messageItems.firstOrNull { it is MessageItemState } as? MessageItemState)?.message val hasNewMessage = lastLoadedMessage != null && messagesState.messageItems.isNotEmpty() && newLastMessage?.id != lastLoadedMessage?.id messagesState = if (hasNewMessage) { val newMessageState = getNewMessageState(newLastMessage, lastLoadedMessage) newState.copy( newMessageState = newMessageState, unreadCount = getUnreadMessageCount(newMessageState) ) } else { newState }  messagesState.messageItems.firstOrNull { it is MessageItemState && it.message.id == scrollToMessage?.id }?.let { focusMessage((it as MessageItemState).message.id) }  lastLoadedMessage = newLastMessage } } } }"	"Starts observing the messages in the current channel. We observe the 'messagesState', 'user' and endOfOlderMessages' states, as well as build the `newMessageState` using [getNewMessageState] and combine it into a [MessagesState] that holds all the information required for the screen."
private fun observeTypingUsers() { viewModelScope.launch { channelState.filterNotNull().flatMapLatest { it.typing }.collect { typingUsers = it.users }} }	Starts observing the list of typing users.
"private fun observeChannel() { viewModelScope.launch {channelState.filterNotNull().flatMapLatest { state  >combine(state.channelData,state.membersCount,state.watcherCount,) { _, _, _ ->state.toChannel()}}.collect { channel  >chatClient.notifications.dismissChannelNotifications(channelType = channel.type,channelId = channel.id)setCurrentChannel(channel)}}}"	"Starts observing the current [Channel] created from [ChannelState]. It emits new data when either channel data, member count or online member count updates."
private fun setCurrentChannel(channel: Channel) { this.channel = channel }	"Sets the current channel, used to show info in the UI."
private fun filterMessagesToShow(messages: List<Message>): List<Message> { val currentUser = user.value return messages.filter { val shouldShowIfDeleted = when (deletedMessageVisibility) { DeletedMessageVisibility.ALWAYS_VISIBLE -> true DeletedMessageVisibility.VISIBLE_FOR_CURRENT_USER -> { !(it.deletedAt != null && it.user.id != currentUser?.id) } else -> it.deletedAt == null } val isSystemMessage = it.isSystem() || it.isError()  shouldShowIfDeleted || (isSystemMessage && showSystemMessages) } }	Used to filter messages which we should show to the current user.
"private fun getNewMessageState(lastMessage: Message?, lastLoadedMessage: Message?): NewMessageState? { val currentUser = user.value  return if (lastMessage != null && lastLoadedMessage != null && lastMessage.id != lastLoadedMessage.id) { if (lastMessage.user.id == currentUser?.id) { MyOwn } else { Other } } else { null } }"	"Builds the [NewMessageState] for the UI, whenever the message state changes. This is used to allow us to show the user a floating button giving them the option to scroll to the bottom when needed."
private fun getUnreadMessageCount(newMessageState: NewMessageState? = currentMessagesState.newMessageState): Int { if (newMessageState == null || newMessageState == MyOwn) return 0  val messageItems = currentMessagesState.messageItems val lastSeenMessagePosition = getLastSeenMessagePosition(if (isInThread) lastSeenThreadMessage else lastSeenChannelMessage) var unreadCount = 0  for (i in 0..lastSeenMessagePosition) { val messageItem = messageItems[i]  if (messageItem is MessageItemState && !messageItem.isMine && messageItem.message.deletedAt == null) { unreadCount++ } }  return unreadCount }	"Counts how many messages the user hasn't read already. This is based on what the last message they've seen is, and the current message state."
private fun getLastSeenMessagePosition(lastSeenMessage: Message?): Int { if (lastSeenMessage == null) return 0  return currentMessagesState.messageItems.indexOfFirst { it is MessageItemState && it.message.id == lastSeenMessage.id } }	Gets the list position of the last seen message in the list.
public fun updateLastSeenMessage(message: Message) { val lastSeenMessage = if (isInThread) lastSeenThreadMessage else lastSeenChannelMessage  if (lastSeenMessage == null) { updateLastSeenMessageState(message) return }  if (message.id == lastSeenMessage.id) { return }  val lastSeenMessageDate = lastSeenMessage.createdAt ?: Date() val currentMessageDate = message.createdAt ?: Date() if (currentMessageDate < lastSeenMessageDate) { return } updateLastSeenMessageState(message) } 	Attempts to update the last seen message in the channel or thread. We only update the last seen message the first time the data loads and whenever we see a message that's newer than the current last seen message.
"private fun updateLastSeenMessageState(currentMessage: Message) { if (isInThread) { lastSeenThreadMessage = currentMessage  threadMessagesState = threadMessagesState.copy(unreadCount = getUnreadMessageCount()) } else { lastSeenChannelMessage = currentMessage  messagesState = messagesState.copy(unreadCount = getUnreadMessageCount()) }  val (channelType, id) = channelId.cidToTypeAndId()  val latestMessage: MessageItemState? = currentMessagesState.messageItems.firstOrNull { messageItem -> messageItem is MessageItemState } as? MessageItemState  if (currentMessage.id == latestMessage?.message?.id) { chatClient.markRead(channelType, id).enqueue() } }"	Updates the state of the last seen message. Updates corresponding state based on [isInThread].
"private fun showEmptyState() { messagesState = messagesState.copy(isLoading = false, messageItems = emptyList()) }"	"If there's an error, we just set the current state to be empty - 'isLoading' as false and 'messages' as an empty list."
"public fun loadMore() { if (chatClient.clientState.isOffline) return val messageMode = messageMode  if (messageMode is MessageMode.MessageThread) { threadLoadMore(messageMode) } else { messagesState = messagesState.copy(isLoadingMore = true) chatClient.loadOlderMessages(channelId, messageLimit).enqueue() } }"	Triggered when the user loads more data by reaching the end of the current messages.
"private fun threadLoadMore(threadMode: MessageMode.MessageThread) { threadMessagesState = threadMessagesState.copy(isLoadingMore = true) if (threadMode.threadState != null) { chatClient.getRepliesMore( messageId = threadMode.parentMessage.id, firstId = threadMode.threadState?.oldestInThread?.value?.id ?: threadMode.parentMessage.id, limit = DefaultMessageLimit, ).enqueue() } else { threadMessagesState = threadMessagesState.copy(isLoadingMore = false) logger.w { ""Thread state must be not null for offline plugin thread load more!"" } } }"	Load older messages for the specified thread [MessageMode.MessageThread.parentMessage].
"private fun loadMessage(message: Message) { val cid = channelState.value?.cid if (cid == null || chatClient.clientState.isOffline) return  chatClient.loadMessageById(cid, message.id).enqueue() }"	Loads the selected message we wish to scroll to when the message can't be found in the current list.
"public fun selectMessage(message: Message?) { if (message != null) {changeSelectMessageState(if (message.isModerationFailed(chatClient)) {SelectedMessageFailedModerationState(message = message,ownCapabilities = ownCapabilities.value)} else {SelectedMessageOptionsState(message = message,ownCapabilities = ownCapabilities.value)})}}"	Triggered when the user long taps on and selects a message.
"public fun selectReactions(message: Message?) {if (message != null) {changeSelectMessageState(SelectedMessageReactionsState(message = message,ownCapabilities = ownCapabilities.value))}}"	Triggered when the user taps on and selects message reactions.
"public fun selectExtendedReactions(message: Message?) {if (message != null) {changeSelectMessageState(SelectedMessageReactionsPickerState(message = message,ownCapabilities = ownCapabilities.value))}}"	Triggered when the user taps the show more reactions button.
private fun changeSelectMessageState(selectedMessageState: SelectedMessageState) {if (isInThread) {threadMessagesState = threadMessagesState.copy(selectedMessageState = selectedMessageState)} else {messagesState = messagesState.copy(selectedMessageState = selectedMessageState)}}	Changes the state of [threadMessagesState] or [messagesState] depending on the thread mode.
public fun openMessageThread(message: Message) {loadThread(message)}	Triggered when the user taps on a message that has a thread active.
"private fun loadThread(parentMessage: Message) {val threadState = chatClient.getRepliesAsState(parentMessage.id, DefaultMessageLimit)val channelState = channelState.value ?: returnmessageMode = MessageMode.MessageThread(parentMessage, threadState)observeThreadMessages(threadId = threadState.parentId,messages = threadState.messages,endOfOlderMessages = threadState.endOfOlderMessages,reads = channelState.reads)}"	Changes the current [messageMode] to be [Thread] with [ThreadState] and Loads thread data using ChatClient directly. The data is observed by using [ThreadState].
"private fun observeThreadMessages( threadId: String,messages: StateFlow<List<Message>>,endOfOlderMessages: StateFlow<Boolean>,reads: StateFlow<List<ChannelUserRead>>,) {threadJob = viewModelScope.launch {combine(user, endOfOlderMessages, messages, reads) { user, endOfOlderMessages, messages, reads ->threadMessagesState.copy(isLoading = false,messageItems = groupMessages(messages = filterMessagesToShow(messages),isInThread = true,reads = reads,),isLoadingMore = false,endOfMessages = endOfOlderMessages,currentUser = user,parentMessageId = threadId)}.collect { newState ->val newLastMessage =(newState.messageItems.firstOrNull { it is MessageItemState } as? MessageItemState)?.messagethreadMessagesState = newState.copy(newMessageState getNewMessageState(newLastMessage, lastLoadedThreadMessage))lastLoadedThreadMessage = newLastMessage}}}"	"Observes the currently active thread. In process, this creates a [threadJob] that we can cancel once we leave the thread."
"private fun groupMessages(messages: List<Message>,isInThread: Boolean,reads: List<ChannelUserRead>,): List<MessageListItemState> {val parentMessageId =(messageMode as? MessageMode.MessageThread)?.parentMessage?.idval currentUser = user.valueval groupedMessages = mutableListOf<MessageListItemState>()val lastRead = reads.filter { it.user.id != currentUser?.id }.mapNotNull { it.lastRead }.maxOrNull() messages.forEachIndexed { index, message ->val user = message.user val previousMessage = messages.getOrNull(index - 1) val nextMessage = messages.getOrNull(index + 1) val previousUser = previousMessage?.user val nextUser = nextMessage?.user val willSeparateNextMessage = nextMessage?.let { shouldAddDateSeparator(message, it) } ?: false  val position = when { previousUser != user && nextUser == user && !willSeparateNextMessage -> MessageItemGroupPosition.Top previousUser == user && nextUser == user && !willSeparateNextMessage -> MessageItemGroupPosition.Middle previousUser == user && nextUser != user -> MessageItemGroupPosition.Bottom else -> MessageItemGroupPosition.None }  val isLastMessageInGroup = position == MessageItemGroupPosition.Bottom || position == MessageItemGroupPosition.None  val shouldShowFooter = messageFooterVisibility.shouldShowMessageFooter( message = message, isLastMessageInGroup = isLastMessageInGroup, nextMessage = nextMessage )  if (shouldAddDateSeparator(previousMessage, message)) { groupedMessages.add(DateSeparatorState(message.getCreatedAtOrThrow())) }  if (message.isSystem() || message.isError()) { groupedMessages.add(SystemMessageState(message = message)) } else { val isMessageRead = message.createdAt ?.let { lastRead != null && it <= lastRead } ?: false  groupedMessages.add( MessageItemState( message = message, currentUser = currentUser, groupPosition = position, parentMessageId = parentMessageId, isMine = user.id == currentUser?.id, isInThread = isInThread, isMessageRead = isMessageRead, shouldShowFooter = shouldShowFooter, deletedMessageVisibility = deletedMessageVisibility ) ) }  if (index == 0 && isInThread) { groupedMessages.add(ThreadSeparatorState(message.replyCount)) } }  return groupedMessages.reversed() }"	"Takes in the available messages for a [Channel] and groups them based on the sender ID. We put the message in a group, where the positions can be [MessageItemGroupPosition.Top], [MessageItemGroupPosition.Middle],  [MessageItemGroupPosition.Bottom] or [MessageItemGroupPosition.None] if the message isn't in a group."
"private fun shouldAddDateSeparator(previousMessage: Message?, message: Message): Boolean { return if (!showDateSeparators) { false } else if (previousMessage == null) { true } else { val timeDifference = message.getCreatedAtOrThrow().time - previousMessage.getCreatedAtOrThrow().time  return timeDifference > dateSeparatorThresholdMillis } }"	Decides if we need to add a date separator or not.
"@JvmOverloads @Suppress(""ConvertArgumentToSet"") public fun deleteMessage(message: Message, hard: Boolean = false) { messageActions = messageActions - messageActions.filterIsInstance<Delete>() removeOverlay()  chatClient.deleteMessage(message.id, hard).enqueue() }"	"Removes the delete actions from our [messageActions], as well as the overlay, before deleting the selected message."
"@Suppress(""ConvertArgumentToSet"") public fun flagMessage(message: Message) { messageActions = messageActions - messageActions.filterIsInstance<Flag>() removeOverlay()  chatClient.flagMessage(message.id).enqueue() }"	"Removes the flag actions from our [messageActions], as well as the overlay, before flagging  the selected message."
"private fun resendMessage(message: Message) { val (channelType, channelId) = message.cid.cidToTypeAndId()  chatClient.sendMessage(channelType, channelId, message).enqueue() }"	Retries sending a message that has failed to send.
private fun copyMessage(message: Message) { clipboardHandler.copyMessage(message) }	Copies the message content using the [ClipboardHandler] we provide. This can copy both attachment and text messages.
private fun updateUserMute(user: User) { val isUserMuted = chatClient.globalState.muted.value.any { it.target.id == user.id }  if (isUserMuted) { unmuteUser(user.id) } else { muteUser(user.id) } }	Mutes or unmutes the user that sent a particular message.
"public fun muteUser( userId: String, timeout: Int? = null, ) { chatClient.muteUser(userId, timeout) .enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to mute the user"" StreamLog.e(""MessageListViewModel.muteUser"") { errorMessage } }) }"	Mutes the given user inside this channel.
"public fun unmuteUser(userId: String) { chatClient.unmuteUser(userId) .enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to unmute the user""  StreamLog.e(""MessageListViewModel.unMuteUser"") { errorMessage } }) }"	Unmutes the given user inside this channel.
"public fun banUser( userId: String, reason: String? = null, timeout: Int? = null, ) { chatClient.channel(channelId).banUser(userId, reason, timeout) .enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to ban the user""  StreamLog.e(""MessageListViewModel.banUser"") { errorMessage } }) }"	Bans the given user inside this channel.
"public fun unbanUser(userId: String) { chatClient.channel(channelId).unbanUser(userId).enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to unban the user""  StreamLog.e(""MessageListViewModel.unban"") { errorMessage } }) }"	Unbans the given user inside this channel.
"public fun shadowBanUser( userId: String, reason: String? = null, timeout: Int? = null, ) { chatClient.channel(channelId).shadowBanUser(userId, reason, timeout) .enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to shadow ban the user""  StreamLog.e(""MessageListViewModel.shadowBanUser"") { errorMessage } }) }"	Shadow bans the given user inside this channel.
"public fun removeShadowBanFromUser(userId: String) { chatClient.channel(channelId).removeShadowBan(userId) .enqueue(onError = { chatError -> val errorMessage = chatError.message ?: chatError.cause?.message ?: ""Unable to remove the user shadow ban""  StreamLog.e(""MessageListViewModel.removeShadowBanFromUser"") { errorMessage } }) }"	Removes the shaddow ban for the given user inside this channel.
"private fun reactToMessage(reaction: Reaction, message: Message) { val channelState = channelState.value ?: return  if (message.ownReactions.any { it.messageId == reaction.messageId && it.type == reaction.type }) { chatClient.deleteReaction( messageId = message.id, reactionType = reaction.type, cid = channelState.cid ).enqueue() } else { chatClient.sendReaction( reaction = reaction, enforceUnique = enforceUniqueReactions, cid = channelState.cid ).enqueue() } }"	"Triggered when the user chooses the [React] action for the currently selected message. If the message already has that reaction, from the current user, we remove it. Otherwise we add a new reaction."
"private fun updateMessagePin(message: Message) { val updateCall = if (message.pinned) { chatClient.unpinMessage(message) } else { chatClient.pinMessage(message = message, expirationDate = null) }  updateCall.enqueue() }"	Pins or unpins the message from the current channel based on its state.
public fun leaveThread() { messageMode = MessageMode.Normal messagesState = messagesState.copy(selectedMessageState = null) threadMessagesState = MessagesState() lastSeenThreadMessage = null threadJob?.cancel() }	Leaves the thread we're in and resets the state of the [messageMode] and both of the [MessagesState]s.
public fun removeOverlay() { threadMessagesState = threadMessagesState.copy(selectedMessageState = null) messagesState = messagesState.copy(selectedMessageState = null) }	"Resets the [MessagesState]s, to remove the message overlay, by setting 'selectedMessage' to null."
"public fun clearNewMessageState() { threadMessagesState = threadMessagesState.copy(newMessageState = null, unreadCount = 0) messagesState = messagesState.copy(newMessageState = null, unreadCount = 0) }"	"Clears the [NewMessageState] from our UI state, after the user taps on the ""Scroll to bottom"" or ""New Message"" actions in the list or simply scrolls to the bottom."
public fun focusMessage(messageId: String) { val messages = currentMessagesState.messageItems.map { if (it is MessageItemState && it.message.id == messageId) { it.copy(focusState = MessageFocused) } else { it } }  viewModelScope.launch { updateMessages(messages) delay(RemoveMessageFocusDelay) removeMessageFocus(messageId) } }	"Sets the focused message to be the message with the given ID, after which it removes it from focus with a delay."
private fun removeMessageFocus(messageId: String) { val messages = currentMessagesState.messageItems.map { if (it is MessageItemState && it.message.id == messageId) { it.copy(focusState = MessageFocusRemoved) } else { it } }  if (scrollToMessage?.id == messageId) { scrollToMessage = null }  updateMessages(messages) }	Removes the focus from the message with the given ID.
private fun updateMessages(messages: List<MessageListItemState>) { if (isInThread) { this.threadMessagesState = threadMessagesState.copy(messageItems = messages) } else { this.messagesState = messagesState.copy(messageItems = messages) } }	Updates the current message state with new messages.
public fun getMessageWithId(messageId: String): Message? { val messageItem =currentMessagesState.messageItems.firstOrNull { it is MessageItemState && it.message.id == messageId }  return (messageItem as? MessageItemState)?.message }	Returns a message with the given ID from the [currentMessagesState].
public fun performGiphyAction(action: GiphyAction) { val message = action.message when (action) { is SendGiphy -> chatClient.sendGiphy(message) is ShuffleGiphy -> chatClient.shuffleGiphy(message) is CancelGiphy -> chatClient.cancelEphemeralMessage(message) }.exhaustive.enqueue() }	Executes one of the actions for the given ephemeral giphy message.
public fun scrollToSelectedMessage(message: Message) { val isMessageInList = currentMessagesState.messageItems.firstOrNull { it is MessageItemState && it.message.id == message.id } != null  if (isMessageInList) { focusMessage(message.id) } else { scrollToMessage = message loadMessage(message = message) } }	Scrolls to message if in list otherwise get the message from backend.
"fun save(filename: String?): Boolean { try { mOutput = FileOutputStream(filename) val output = ByteArray(BUFFER_SIZE) while (mInput.available() > 0) { val size: Int = read(output) if (size > 0) { mOutput.write(output, 0, size) } else break } mInput.close() mOutput.close() return true } catch (e: Exception) { e.printStackTrace() } try { if (mInput != null) mInput.close() if (mOutput != null) mOutput.close() } catch (e: IOException) { e.printStackTrace() } return false }"	Saves an unencrypted copy of the music file as an Mp3
fun isSingleton(): Boolean { return true }	Always returns < code > true < /code > .
fun append(s: String?) { compoundID.append(s) }	Append a new segment to the compound name of the operator
fun eUnset(featureID: Int) { when (featureID) { TypesPackage.TSTRUCT_GETTER__DEFINED_MEMBER -> { setDefinedMember(null as TStructMember?) return } } super.eUnset(featureID) }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
private fun doSetRhythmDrawable(@Nullable drawable: RhythmDrawable) { if (mRhythmDrawable != null) { mRhythmDrawable.setCallback(null) } mRhythmDrawable = drawable if (mRhythmDrawable != null) { mRhythmDrawable.setBounds(mBounds) mRhythmDrawable.setCallback(this) } }	Links new drawable to this view
protected fun AbstractSVGFilterPrimitiveElementBridge() {}	Constructs a new bridge for a filter primitive element .
"@Pointcut(""within(@javax.persistence.Entity *) || "" + ""within(@javax.persistence.MappedSuperclass *) || "" + ""within(@javax.persistence.Embeddable *)"") fun jpa() { }"	Pointcut for jpa entities
"fun OMGrid( lat: Double, lon: Double, x: Int, y: Int, vResolution: Double, hResolution: Double, data: Array<IntArray?>? ) { setRenderType(RENDERTYPE_OFFSET) set(lat, lon, x, y, vResolution, hResolution, data) }"	"Create a OMGrid that covers a x/y screen area , anchored to a lat/lon point . Column major by default . If your data is row major , use null for the data , set the major direction , and then set the data ."
"operator fun compareTo(other: SpatialObjectPair): Int { return java.lang.Double.compare(this.distance, other.distance) }"	"Compares this object with the specified object for order . Returns a negative integer , zero , or a positive integer as this object is less than , equal to , or greater than the specified object . < p/ >"
"fun checkLabel(label: Label?, checkVisited: Boolean, msg: String) { requireNotNull(label) { ""Invalid $msg (must not be null)"" } require( (checkVisited && labels.get(label) == null)) { ""Invalid $msg (must be visited first)"" } }"	Checks that the given label is not null . This method can also check that the label has been visited .
"@Throws(MissingResourceException::class) fun MinecraftlyLogger(core: MinecraftlyCore, parentLogger: Logger) { super(""Core "" + parentLogger.getName(), parentLogger.getResourceBundleName()) core = core this.debug = File(core.getMinecraftlyDataFolder(), "".debugging"").exists() setParent(parentLogger) setUseParentHandlers(true) }"	Method to construct a logger for Minecraftly 's Core .
"fun cleanIndex( mutator: RowMutator, doType: DataObjectType, listToCleanRef: SoftReference<IndexCleanupList?> ) { val listToClean: IndexCleanupList = listToCleanRef.get() if (listToClean == null) { _log.warn( ""clean up list for {} has been recycled by GC, skip it"", doType.getClass().getName() ) return } val cleanList: Map<String, List<Column<CompositeColumnName>>> = listToClean.getColumnsToClean() val entryIt: Iterator<Map.Entry<String, List<Column<CompositeColumnName>>>> = cleanList.entries.iterator() val dependentFields: MutableMap<String, ColumnField> = HashMap() while (entryIt.hasNext()) { val (rowKey, cols) = entryIt.next() for (i in cols.indices) { val column: Column<CompositeColumnName> = cols[i] val field: ColumnField = doType.getColumnField(column.getName().getOne()) field.removeColumn(rowKey, column, mutator, listToClean.getAllColumns(rowKey)) for (depField in field.getDependentFields()) { dependentFields[depField.getName()] = depField } } for (depField in dependentFields.values) { depField.removeIndex( rowKey, null, mutator, listToClean.getAllColumns(rowKey), listToClean.getObject(rowKey) ) } } removeIndexOfInactiveObjects(mutator, doType, listToClean as IndexCleanupList, true) mutator.executeIndexFirst() }"	Clean out old column / index entries synchronously
@Throws(IOException::class) protected fun onPrepareRequest(request: HttpUriRequest?) { }	Called before the request is executed using the underlying HttpClient . < p > Overwrite in subclasses to augment the request. < /p >
"override fun toString(): String? { return super.toString() + ""NameConstraints: ["" + (if (permitted == null) """" else """""" Permitted:${permitted.toString()}"""""") + (if (excluded == null) """" else """""" Excluded:${excluded.toString()}"""""") + "" ]\n"" }"	Return the printable string .
"fun LRUCache(initialSize: Int, maxSize: Int) { this(initialSize, maxSize, 1) }"	Create a new LRU cache .
"@Throws(Exception::class) fun HarCapabilityContainerTest(testName: String?, testData: EnvironmentTestData?) { super(testName, testData) }"	Initializes the test case .
"private fun locate(name: String): File? { var prefix = """" var sourceFile: File? = null var idx = 0 while (true) { if (idx == 0 && ToolIO.getUserDir() != null) { sourceFile = File(ToolIO.getUserDir(), name) } else { sourceFile = File(prefix + name) } if (sourceFile.exists()) break if (idx >= libraryPathEntries.size()) break prefix = libraryPathEntries.elementAt(idx++) } return sourceFile }"	Searches for the file in current directory ( ToolIO.userDirectory ) and in library paths
"@JvmStatic fun main(args: Array<String>) { val timeResolution = TimeResolution() timeResolution.measureTimer() timeResolution.measureTimeFunctions(javax.accessibility.AccessibleAction.INCREMENT, MAX) timeResolution.measureSleep() timeResolution.measureWait() }"	Execute the various timer resolution tests .
"@Throws(IOException::class, ClassNotFoundException::class) private fun readObject(s: ObjectInputStream) { try { s.defaultReadObject() this.queue = arrayOfNulls<Any>(q.size()) comparator = q.comparator() addAll(q) } finally { q = null } }"	"Reconstitutes this queue from a stream ( that is , deserializes it ) ."
"fun createEdge(source: BasicBlock?, dest: BasicBlock?, @Edge.Type type: Int): Edge { val edge: Edge = createEdge(source, dest) edge.setType(type) return edge }"	Add a unique edge to the graph . There must be no other edge already in the CFG with the same source and destination blocks .
private fun initialize() { this.setContentPane(getJPanel()) this.pack() }	This method initializes this
"fun translate(x: Float, y: Float, z: Float) { val tmp = Matrix4f() tmp.loadTranslate(x, y, z) multiply(tmp) }"	Modifies the current matrix by post-multiplying it with a translation matrix of given dimensions
fun AdaptiveJobCountLoadProbe() {}	Initializes active job probe .
"fun primeFncName(s: Session?, line: Int) { primeAllFncNames(s) }"	Called in order to make sure that we have a function name available at the given location . For AVM+ swfs we do n't need a swd and therefore do n't have access to function names in the same fashion . We need to ask the player for a particular function name .
"fun <V> addDistinctEntry(sourceList: MutableList<V>?, entry: V): Boolean { return if (sourceList != null && !sourceList.contains(entry)) sourceList.add(entry) else false }"	add distinct entry to list
"protected fun initFromJar(file: File) { val jar: JarFile var entry: JarEntry val enm: Enumeration<JarEntry> if (VERBOSE) { println(""Analyzing jar: $file"") } if (!file.exists()) { println(""Jar does not exist: $file"") return } try { jar = JarFile(file) enm = jar.entries() while (enm.hasMoreElements()) { entry = enm.nextElement() if (entry.getName().endsWith("".class"")) { add(entry.getName()) } } initFromManifest(jar.getManifest()) } catch (e: Exception) { e.printStackTrace() } }"	Fills the class cache with classes from the specified jar .
"fun build(@Nullable quadConsumer: Consumer<UnpackedBakedQuad.Builder?>?): List<BakedQuad>? { val quads: MutableList<BakedQuad> = ArrayList<BakedQuad>(this.vertices.size() / 4) if (this.vertices.size() % 4 !== 0) throw RuntimeException(""Invalid number of vertices"") var i = 0 while (i < this.vertices.size()) { val vert1: sun.security.provider.certpath.Vertex = this.vertices.get(i) val vert2: sun.security.provider.certpath.Vertex = this.vertices.get(i + 1)"	Builds the quads . Specify a consumer to modify the quads
fun newJdbcExceptionTranslator(): SQLExceptionTranslator? { return SQLStateSQLExceptionTranslator() }	"Create an appropriate SQLExceptionTranslator for the given TransactionManager . If a DataSource is found , a SQLErrorCodeSQLExceptionTranslator for the DataSource is created ; else , a SQLStateSQLExceptionTranslator as fallback ."
"override fun onSaveInstanceState(outState: Bundle) { outState.putBoolean(""SlidingActivityHelper.open"", mSlidingMenu.isMenuShowing()) outState.putBoolean( ""SlidingActivityHelper.secondary"", mSlidingMenu.isSecondaryMenuShowing() ) }"	Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate ( Bundle ) or onRestoreInstanceState ( Bundle ) ( the Bundle populated by this method will be passed to both ) .
"fun `steFor_$fieldInit`(): SymbolTableEntryInternal? { return getSymbolTableEntryInternal(""\$fieldInit"", true) }"	`` $ fieldInit '' - retrieve the internal symbol table entry for the symbol `` $ fieldInit ''
"fun isProcessing(): Boolean { val oo: Any = get_Value(COLUMNNAME_Processing) return if (oo != null) { if (oo is Boolean) oo.toBoolean() else ""Y"" == oo } else false }"	Get Process Now .
"fun createFromCommandline(args: Array<String>): Profile? { val profile = Profile() var i = 0 while (i != args.size) { if (args[i] == ""-u"") { profile.setUser(args[i + 1])} else if (args[i] == ""-p"") { profile.setPassword(args[i + 1]) } else if (args[i] == ""-c"") { profile.setCharacter(args[i + 1]) } else if (args[i] == ""-h"") { profile.setHost(args[i + 1]) } else if (args[i] == ""-P"") { profile.setPort(args[i + 1].toInt()) } else if (args[i] == ""-S"") { profile.setSeed(args[i + 1]) } i++ } if (profile.getCharacter() == null) { profile.setCharacter(profile.getUser()) } return profile }"	create a profile based on command line arguments < ul > < li > -u : username < /li > < li > -p : password < /li > < li > -c : character name ( defaults to username ) < /li > < li > -h : hostname < /li > < li > -P : port < /li > < li > -S : pre authentication seed < /li > < /ul >
"fun MainWindow() { super(""Main Window"") settings = Settings() update = UpdateWindow() blocksWindow = BlockListWindow() consoleLog = GUIConsoleLog() if (settings.getPreferences().getBoolean(""OPEN_CONSOLE_ON_START"", true)) { consoleLog.setVisible(true) } export = ExportWindow() main = this setSize(1000, 800) setMinimumSize(Dimension(400, 400)) setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE) setTitle(""jMC2Obj"") setLocationRelativeTo(null) panel = MainPanel() add(panel) setVisible(true) }"	Window contructor .
fun findAndInit(it: Iterator<*>) { while (it.hasNext()) { findAndInit(it.next()) } }	"Eventually gets called when the MouseDelegator is added to the BeanContext , and when other objects are added to the BeanContext anytime after that . The MouseDelegator looks for a MapBean to manage MouseEvents for , and MouseModes to use to manage those events . If a MapBean is added to the BeanContext while another already is in use , the second MapBean will take the place of the first ."
fun wantsFutureVariantBases(): Boolean { return mHaplotypeA.wantsFutureVariantBases() || mHaplotypeB.wantsFutureVariantBases() }	Test whether a deficit of variant bases are upstream in the queue in order to perform a step .
"fun createPotentialProducer(baseObject: Any?,methodName: String?,dataType: Class<*>?): PotentialProducer? {val description: String = getDescriptionString(baseObject, methodName, dataType) return PotentialProducer(parentComponent,baseObject,methodName,dataType,null,null,description)}"	Create a potential producer ( without auxiliary arguments ) . This is probably the main method to use in a script .
"fun Hashtable() { this(11, 0.75f) }"	"Constructs a new , empty hashtable with a default initial capacity ( 11 ) and load factor , which is < tt > 0.75 < /tt > ."
"private fun runRoutesDistance(runNr: String, sc: Scenario) { val ug: UserGroup = UserGroup.URBAN val lastIteration: Int = sc.getConfig().controler().getLastIteration() val eventsFile: String = sc.getConfig().controler() .getOutputDirectory() + ""/ITERS/it."" + lastIteration + ""/"" + lastIteration + "".events.xml.gz"" val lmdfed = LegModeRouteDistanceDistributionAnalyzer() lmdfed.init(sc, eventsFile) lmdfed.preProcessData() lmdfed.postProcessData() File(RUN_DIR + ""/analysis/legModeDistributions/"").mkdirs() lmdfed.writeResults(RUN_DIR + ""/analysis/legModeDistributions/"" + runNr + ""_it."" + lastIteration + ""_"") }"	It will write route distance distribution from events and take the beeline distance for teleported modes
@Throws(IOException::class) fun findAvailableStrings(uri: String): List<String>? { _resourcesNotLoaded.clear() val fulluri: String = _path + uri val strings: MutableList<String> = ArrayList() val resources: Enumeration<URL> = getResources(fulluri) while (resources.hasMoreElements()) { val url: URL = resources.nextElement() try { val string: String = readContents(url) strings.add(string) } catch (notAvailable: IOException) { _resourcesNotLoaded.add(url.toExternalForm()) } } return strings }	Reads the contents of the found URLs as a Strings and returns them . Individual URLs that can not be read are skipped and added to the list of 'resourcesNotLoaded '
"fun computeInPlace(vararg dataset: Double): Double { checkArgument(dataset.size > 0, ""Cannot calculate quantiles of an empty dataset"")if (containsNaN(dataset))  return NaN } val numerator = index as Long * (dataset.size - 1) val quotient = LongMath.divide(numerator, scale, RoundingMode.DOWN) as Int val remainder = (numerator - quotient.toLong() * scale) as Int selectInPlace(quotient, dataset, 0, dataset.size - 1) return if (remainder == 0) { dataset[quotient] } else { selectInPlace(quotient + 1, dataset, quotient + 1, dataset.size - 1) interpolate(dataset[quotient], dataset[quotient + 1], remainder, scale) } }"	"Computes the quantile value of the given dataset , performing the computation in-place ."
"fun scale(factor: Double): Ellipse? { val r: RotatedRect = rect.clone() r.size = Size(factor * rect.size.width, factor * rect.size.height) return Ellipse(r) v }"	Scale this ellipse by a scaling factor about its center
"@Throws(Exception::class) private fun waitForReportRunCompletion( reporting: Dfareporting, userProfileId: Long, file: File ): File? { var file: File = file var interval: Int for (i in 0..MAX_POLLING_ATTEMPTS) { if (!file.getStatus().equals(""PROCESSING"")) { break } interval = (POLL_TIME_INCREMENT * Math.pow(1.6, i.toDouble())) System.out.printf(""Polling again in %s ms.%n"", interval) Thread.sleep(interval.toLong()) file = reporting.reports().files().get(userProfileId, file.getReportId(), file.getId()) .execute() } return file }"	Waits for a report file to generate with exponential back-off .
private fun showFeedback(message: String) { if (myHost != null) { myHost.showFeedback(message) } else { println(message) } }	Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface .
"fun AllocationSite() { this(0, 0) }"	An anonymous allocation site
@Synchronized override fun equals(o: Any?): Boolean { return super.equals(o) }	"Compares the specified Object with this Vector for equality . Returns true if and only if the specified Object is also a List , both Lists have the same size , and all corresponding pairs of elements in the two Lists are < em > equal < /em > . ( Two elements < code > e1 < /code > and < code > e2 < /code > are < em > equal < /em > if < code > ( e1==null ? e2==null : e1.equals ( e2 ) ) < /code > . ) In other words , two Lists are defined to be equal if they contain the same elements in the same order ."
protected fun makeConverter(): DateTimeConverter? { return jdk.internal.joptsimple.util.DateConverter() }	Create the Converter with no default value .
"fun skip(str: String, csq: CharSequence?): Boolean { return if (this.at(str, csq)) { index += str.length true } else { false } }"	"Moves this cursor forward only if at the specified string . This method is equivalent to : [ code ] if ( at ( str , csq ) ) increment ( str.length ( ) ) ; [ /code ]"
"fun deleteExpectedPartitionValues(expectedPartitionValuesDeleteRequest: ExpectedPartitionValuesDeleteRequest): ExpectedPartitionValuesInformation? { validateExpectedPartitionValuesDeleteRequest(expectedPartitionValuesDeleteRequest) val partitionKeyGroupEntity: PartitionKeyGroupEntity = partitionKeyGroupDaoHelper.getPartitionKeyGroupEntity( expectedPartitionValuesDeleteRequest.getPartitionKeyGroupKey() ) val expectedPartitionValueEntityMap: Map<String, ExpectedPartitionValueEntity> = getExpectedPartitionValueEntityMap(partitionKeyGroupEntity.getExpectedPartitionValues()) val deletedExpectedPartitionValueEntities: MutableCollection<ExpectedPartitionValueEntity> = ArrayList() for (expectedPartitionValue in expectedPartitionValuesDeleteRequest.getExpectedPartitionValues()) { val expectedPartitionValueEntity: ExpectedPartitionValueEntity? = expectedPartitionValueEntityMap[expectedPartitionValue] if (expectedPartitionValueEntity != null) { deletedExpectedPartitionValueEntities.add(expectedPartitionValueEntity) } else { throw ObjectNotFoundException( java.lang.String.format( ""Expected partition value \""%s\"" doesn't exist in \""%s\"" partition key group."", expectedPartitionValue, partitionKeyGroupEntity.getPartitionKeyGroupName() ) ) } } for (expectedPartitionValueEntity in deletedExpectedPartitionValueEntities) { partitionKeyGroupEntity.getExpectedPartitionValues() .remove(expectedPartitionValueEntity) } expectedPartitionValueDao.saveAndRefresh(partitionKeyGroupEntity) return createExpectedPartitionValuesInformationFromEntities( partitionKeyGroupEntity, deletedExpectedPartitionValueEntities ) }"	Deletes specified expected partition values from an existing partition key group which is identified by name .
"@JvmStatic fun main(args: Array<String>) { DOMTestCase.doMain(hasAttribute01::class.java, args) }"	Runs this test from the command line .
"fun launch() { val parentActivity: Activity = ActivityDelegate.getActivityForTabId(mParentId) mLaunchedId = ChromeLauncherActivity.launchDocumentInstance( parentActivity, mIsIncognito, mAsyncParams ) mLaunchTimestamp = SystemClock.elapsedRealtime() run()}"	Starts an Activity to with the stored parameters .
"fun unlink(succ: Index<V?>): Boolean { return !indexesDeletedNode() && casRight(succ, succ.right) }"	Tries to CAS right field to skip over apparent successor succ . Fails ( forcing a retraversal by caller ) if this node is known to be deleted .
"@Throws(IOException::class) fun wrap(reader: LeafReader?, sort: Sort?): LeafReader? { return wrap(reader, org.junit.runner.manipulation.Sorter(sort).sort(reader)) }"	"Return a sorted view of < code > reader < /code > according to the order defined by < code > sort < /code > . If the reader is already sorted , this method might return the reader as-is ."
"private fun fillPomsFromChildren( poms: MutableCollection<ArtifactInformation>, art: ArtifactInformation, artifacts: Map<String, ArtifactInformation> ): Int { var cnt = 0 for (childId in art.getChildIds()) { val child: ArtifactInformation? = artifacts[childId] if (child != null) { val childName: String = child.getName() if (isPomFileName(childName)) { poms.add(child) ++cnt } } } return cnt }"	Fill a collection with all POMs for the children of an artifact .
fun AxisSpace() { this.top = 0.0 this.bottom = 0.0 this.left = 0.0 this.right = 0.0 }	Creates a new axis space record .
fun FontConverter(mapper: jdk.internal.module.ModuleLoaderMap.Mapper) { mapper = mapper if (mapper == null) { textAttributeConverter = null } else { textAttributeConverter = TextAttributeConverter() } }	Constructs a FontConverter .
"fun typeName(): String? { return ""long"" }"	Returns a String description of what kind of entry this is .
"fun d(tag: String?, s: String?) { if (LOG.DEBUG >= LOGLEVEL) Log.d(tag, s) }"	Debug log message .
"fun EdgeInfo(start: Int, end: Int, cap: Int) { this(start, end, cap, 0) }"	"Construct EdgeInfo from ( start , end ) vertices with given capacity ."
"private fun isSessionPaused(session: FileSharingSession?): Boolean { if (session == null) { throw ServerApiGenericException(""Unable to check if transfer is paused since session with file transfer ID '$mFileTransferId' not available!"") } return session.isFileTransferPaused() }"	Is session paused ( only for HTTP transfer )
private fun processProtein(){}	"Implementation of Rob Finn 's algorithm for post processing , translated from Perl to Java . < p/ > Also includes additional code to ensure seed alignments are included as matches , regardless of score ."
"fun execute(timeSeries: MetricTimeSeries, functionValueMap: FunctionValueMap) { if (timeSeries.size() <= 0) { functionValueMap.add(this, Double.NaN) return } val values: DoubleArray = timeSeries.getValuesAsArray() var min = values[0] var max = values[0] for (i in 1 until values.size) { val current = values[i] if (current < min) { min = current } if (current > max) { max = current } } functionValueMap.add(this, Math.abs(max - min)) }"	Gets difference between the maximum and the minimum value . It is always a positive value .
private fun returnData(ret: Any) { if (myHost != null) { myHost.returnData(ret) } }	Used to communicate a return object from a plugin tool to the main Whitebox user-interface .
"fun ImpliedCovTable(wrapper: SemImWrapper, measured: Boolean, correlations: Boolean) { wrapper = wrapper measured = measured correlations = correlations this.nf = NumberFormatUtil.getInstance().getNumberFormat() if (measured() && covariances()) { matrix = getSemIm().getImplCovarMeas().toArray() } else if (measured() && !covariances()) { matrix = corr(getSemIm().getImplCovarMeas().toArray()) } else if (!measured() && covariances()) { val implCovarC: TetradMatrix = getSemIm().getImplCovar(false) matrix = implCovarC.toArray() } else if (!measured() && !covariances()) { val implCovarC: TetradMatrix = getSemIm().getImplCovar(false) matrix = corr(implCovarC.toArray()) }"	"Constructs a new table for the given covariance matrix , the nodes for which are as specified ( in the order they appear in the matrix ) ."
"fun create(): Graphics? { return PSPathGraphics( getDelegate().create() as Graphics2D, java.awt.print.PrinterJob.getPrinterJob(), sun.swing.text.TextComponentPrintable.getPrintable(), getPageFormat(), getPageIndex(), canDoRedraws() ) }"	Creates a new < code > Graphics < /code > object that is a copy of this < code > Graphics < /code > object .
"fun deriveThisOrNextChildKey(parent: DeterministicKey?, childNumber: Int): DeterministicKey? { var nAttempts = 0 var child = ChildNumber(childNumber) val isHardened: Boolean = child.isHardened() while (nAttempts < MAX_CHILD_DERIVATION_ATTEMPTS) { try { child = ChildNumber(child.num() + nAttempts, isHardened) return deriveChildKey(parent, child) } catch (ignore: HDDerivationException) { } nAttempts++ } throw HDDerivationException(""Maximum number of child derivation attempts reached, this is probably an indication of a bug."") }"	"Derives a key of the `` extended '' child number , ie . with the 0x80000000 bit specifying whether to use hardened derivation or not . If derivation fails , tries a next child ."
fun merge(state: LR1State): LR1State? { val items: HashSet<LR1Item> = HashSet<LR1Item>() for (item1 in items) { var newItem: LR1Item = item1 val item2: LR1Item = state.getItemByLR0Kernel(item1.getLR0Kernel()) newItem = newItem.merge(item2) items.add(newItem) } return LR1State(items) }	"Merges this state with the given one and returns the result . Only works , if both states have equal LR ( 0 ) kernels ."
"@DSComment(""constructor"") @DSSafe(DSCat.SAFE_OTHERS) @DSGenerator( tool_name = ""Doppelganger"",tool_version = ""2.0"", generated_on = ""2013-12-30 12:34:15.039 -0500"", hash_original_method = ""5474E95C495E2BDEA7848B2F1051B5AB"", hash_generated_method = ""1FFFECB7616C84868E8040908FCDEBA5"" ) @Deprecated("""") fun BitmapDrawable(`is`: InputStream) { this(BitmapState(BitmapFactory.decodeStream(`is`)), null) if (mBitmap == null) { Log.w(""BitmapDrawable"", ""BitmapDrawable cannot decode $`is`"") } }"	Create a drawable by decoding a bitmap from the given input stream .
"fun <T> toString(cls: Class<T>?,obj: T?,name0: String?,val0: Any,name1: String?,val1: Any,name2: String?,val2: Any): String? {}"	Produces auto-generated output of string presentation for given object and its declaration class .
"fun AsyncHttpClient(fixNoHttpResponseException: Boolean, httpPort: Int, httpsPort: Int) { this(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort)) }"	Creates new AsyncHttpClient using given params
"private void extractExtensionHeader ( byte [ ] data , int length , int dataId , RtpPacket packet ) { byte [ ] extensionHeaderData = new byte [ length * 4 ] ; System . arraycopy ( data , ++ dataId , extensionHeaderData , 0 , extensionHeaderData . length ) ; packet . extensionHeader = new RtpExtensionHeader ( ) ; int i = 0 ; while ( packet . extensionHeader . elementsCount ( ) < length ) { byte idAndLength = extensionHeaderData [ i ] ; if ( idAndLength == 0x00 ) { i = i + 1 ; continue ; } int elementId = ( idAndLength & 0xf0 ) > > > 4 ; if ( elementId > 0 && elementId < 15 ) { int elementLength = ( idAndLength & 0x0f ) ; byte [ ] elementData = new byte [ elementLength + 1 ] ; System . arraycopy ( extensionHeaderData , i + 1 , elementData , 0 , elementData . length ) ; packet . extensionHeader . addElement ( elementId , elementData ) ; i = i + elementData . length + 1 ; } else { break ; } } }"	Extract Extension Header
"fun showConfirmDialog( ctx: Context?, message: String?, yesListener: DialogInterface.OnClickListener?, noListener: DialogInterface.OnClickListener? ) { showConfirmDialog(ctx, message, yesListener, noListener, R.string.yes, R.string.no) }"	Creates a confirmation dialog with Yes-No Button . By default the buttons just dismiss the dialog .
fun TelefoneTextWatcher(callbackErros: EventoDeValidacao?) { setEventoDeValidacao(callbackErros) }	TODO Javadoc pendente
"fun RenameResourceProcessor(resource: IResource?) { require(!(resource == null || !resource.exists())) { ""resource must not be null and must exist"" } fResource = resource fRenameArguments = null fUpdateReferences = true setNewResourceName(resource.getName()) }"	Creates a new rename resource processor .
fun perform() { }	"Perform the operation by calling a function in the Python script . This method adapts each of the inputs into Python objects , calls the Python function , and then converts the outputs of the function back into Java objects and assigns them to the outputs array . The Python function should return a tuple , list , or other sequence containing the outputs . If there is only one output , it can just return a value . Either way , the number of inputs and outputs should match up with the number of parameters and return values of the function ."
"@Throws(JMSException::class) fun createConnectionConsumer( connection: Connection, destination: Destination?, ssp: ServerSessionPool? ): ConnectionConsumer? { return connection.createConnectionConsumer(destination, null, ssp, 1) }"	Creates a connection for a consumer .
"fun covarianceMatrix( data1: Array<DoubleArray?>, data2: Array<DoubleArray?>, delay: Int ): Array<DoubleArray>? { }"	"Compute the covariance matrix between all column pairs ( variables ) in the multivariate data set , which consists of two separate multivariate vectors ."
"fun isProcessed(): Boolean { val oo: Any = get_Value(COLUMNNAME_Processed) return if (oo != null) { if (oo is Boolean) oo.toBoolean() else ""Y"" == oo } else false }"	Get Processed .
"private fun quickSort1(x: CharArray, off: Int, len: Int, comp: CharComparator) { }"	Sorts the specified sub-array of chars into ascending order .
@Throws(NullPointerException::class) fun Sound(@Nonnull path: String?) { this(FileUtil.findURL(path)) }	Create a Sound object using the media file at path
"fun hasGwtFacet(project: IProject?): Boolean { var hasFacet = false try { hasFacet = FacetedProjectFramework.hasProjectFacet(project, ""com.gwtplugins.gwt.facet"") } catch (e: CoreException) { CorePluginLog.logInfo(""hasGetFacet: Error, can't figure GWT facet."", e) } return hasFacet }"	Returns if this project has a GWT facet . TODO use extension point to get query GwtWtpPlugin ...
"public Yytoken yylex ( ) throws java . io . IOException , ParseException { int zzInput ; int zzAction ; int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ_CMAP ; int [ ] zzTransL = ZZ_TRANS ; int [ ] zzRowMapL = ZZ_ROWMAP ; int [ ] zzAttrL = ZZ_ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar += zzMarkedPosL - zzStartRead ; zzAction = - 1 ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ_LEXSTATE [ zzLexicalState ] ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL ++ ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL ++ ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext == - 1 ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & 1 ) == 1 ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & 8 ) == 8 ) break zzForAction ; } } } zzMarkedPos = zzMarkedPosL ; switch ( zzAction < 0 ? zzAction : ZZ_ACTION [ zzAction ] ) { case 11 : { sb . append ( yytext ( ) ) ; } case 25 : break ; case 4 : { sb . delete ( 0 , sb . length ( ) ) ; yybegin ( STRING_BEGIN ) ; } case 26 : break ; case 16 : { sb . append ( '\b' ) ; } case 27 : break ; case 6 : { return new Yytoken ( Yytoken . TYPE_RIGHT_BRACE , null ) ; } case 28 : break ; case 23 : { Boolean val = Boolean . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 29 : break ; case 22 : { return new Yytoken ( Yytoken . TYPE_VALUE , null ) ; } case 30 : break ; case 13 : { yybegin ( YYINITIAL ) ; return new Yytoken ( Yytoken . TYPE_VALUE , sb . toString ( ) ) ; } case 31 : break ; case 12 : { sb . append ( '\\' ) ; } case 32 : break ; case 21 : { Double val = Double . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 33 : break ; case 1 : { throw new ParseException ( yychar , ParseException . ERROR_UNEXPECTED_CHAR , new Character ( yycharat ( 0 ) ) ) ; } case 34 : break ; case 8 : { return new Yytoken ( Yytoken . TYPE_RIGHT_SQUARE , null ) ; } case 35 : break ; case 19 : { sb . append ( '\r' ) ; } case 36 : break ; case 15 : { sb . append ( '/' ) ; } case 37 : break ; case 10 : { return new Yytoken ( Yytoken . TYPE_COLON , null ) ; } case 38 : break ; case 14 : { sb . append ( '""' ) ; } case 39 : break ; case 5 : { return new Yytoken ( Yytoken . TYPE_LEFT_BRACE , null ) ; } case 40 : break ; case 17 : { sb . append ( '\f' ) ; } case 41 : break ; case 24 : { try { int ch = Integer . parseInt ( yytext ( ) . substring ( 2 ) , 16 ) ; sb . append ( ( char ) ch ) ; } catch ( Exception e ) { throw new ParseException ( yychar , ParseException . ERROR_UNEXPECTED_EXCEPTION , e ) ; } } case 42 : break ; case 20 : { sb . append ( '\t' ) ; } case 43 : break ; case 7 : { return new Yytoken ( Yytoken . TYPE_LEFT_SQUARE , null ) ; } case 44 : break ; case 2 : { Long val = Long . valueOf ( yytext ( ) ) ; return new Yytoken ( Yytoken . TYPE_VALUE , val ) ; } case 45 : break ; case 18 : { sb . append ( '\n' ) ; } case 46 : break ; case 9 : { return new Yytoken ( Yytoken . TYPE_COMMA , null ) ; } case 47 : break ; case 3 : { } case 48 : break ; default : if ( zzInput == YYEOF && zzStartRead == zzCurrentPos ) { zzAtEOF = true ; return null ; } else { zzScanError ( ZZ_NO_MATCH ) ; } } } }"	"Resumes scanning until the next regular expression is matched , the end of input is encountered or an I/O-Error occurs ."
@Throws(IOException::class) fun encode(out: OutputStream) { val tmp: sun.security.util.DerOutputStream = sun.security.util.DerOutputStream() if (extensionValue == null) { extensionId = sun.security.x509.PKIXExtensions.PolicyConstraints_Id critical = false encodeThis() } super.encode(tmp) out.write(tmp.toByteArray()) }	Write the extension to the DerOutputStream .
"fun <T : Comparable<T>?> introSort(a: Array<T>?, fromIndex: Int, toIndex: Int) { if (toIndex - fromIndex <= 1) return introSort(a, fromIndex, toIndex, Comparator.naturalOrder()) }"	"Sorts the given array slice in natural order . This method uses the intro sort algorithm , but falls back to insertion sort for small arrays ."
" @Throws(IOException::class) fun deleteLabel(projectId: Serializable?, label: GitlabLabel) { deleteLabel(projectId, label.getName()) }"	Deletes an existing label .
" @Throws(ServiceException::class, IOException::class) private fun createSingleEvent( service: CalendarService, eventTitle: String, eventContent: String ): CalendarEventEntry? { return createEvent(service, eventTitle, eventContent, null, false.toInt(), null) }"	Creates a single-occurrence event .
" @Throws(Exception::class) fun testParams() { val sim: ClassicSimilarity = getSimilarity(""text_overlap"", ClassicSimilarity::class.java) assertEquals(false, sim.getDiscountOverlaps()) }"	Classic w/ explicit params
 fun registerRecipes() { registerRecipeClasses() addCraftingRecipes() addBrewingRecipes() }	Add this mod 's recipes .
fun taxApplies(): Boolean { val product: GenericValue = com.sun.org.apache.xml.internal.serializer.Version.getProduct() return if (product != null) { ProductWorker.taxApplies(product) } else { true } }	Returns true if tax charges apply to this item .
"@Action(value = ""/receipts/challan-printChallan"") fun printChallan(): String? { try { reportId = collectionCommon.generateChallan(receiptHeader, true) } catch (e: Exception) { LOGGER.error(CollectionConstants.REPORT_GENERATION_ERROR, e) throw ApplicationRuntimeException(CollectionConstants.REPORT_GENERATION_ERROR, e) } setSourcePage(""viewChallan"") return CollectionConstants.REPORT }"	This method generates the report for the requested challan
"fun testIsMultiValued() { val meta = SpellCheckedMetadata() assertFalse(meta.isMultiValued(""key"")) meta.add(""key"", ""value1"") assertFalse(meta.isMultiValued(""key"")) meta.add(""key"", ""value2"") assertTrue(meta.isMultiValued(""key"")) }"	Test for < code > isMultiValued ( ) < /code > method .
fun InitializeLoginAction() {}	Instantiates a new login action .
"fun Instrument( soundbank: javax.sound.midi.Soundbank?, patch: javax.sound.midi.Patch, name: String?, dataClass: Class<*>? ) { super(soundbank, name, dataClass) this.patch = patch }"	"Constructs a new MIDI instrument from the specified < code > Patch < /code > . When a subsequent request is made to load the instrument , the sound bank will search its contents for this instrument 's < code > Patch < /code > , and the instrument will be loaded into the synthesizer at the bank and program location indicated by the < code > Patch < /code > object ."
"private fun putBytes( tgtBytes: ByteArray, tgtOffset: Int, srcBytes: ByteArray, srcOffset: Int, srcLength: Int ): Int { System.arraycopy(srcBytes, srcOffset, tgtBytes, tgtOffset, srcLength) return tgtOffset + srcLength }"	Put bytes at the specified byte array position .
"fun HighlightTextView(context: Context?) { this(context, null) }"	Instantiates a new Highlight text view .
fun trim() {}	Does nothing .
fun reset(data: ByteArray) { pos = 0 mark = 0 buf = data count = data.size }	Resets this < tt > BytesInputStream < /tt > using the given byte [ ] as new input buffer .
"fun <T, V> ofObject( target: T, property: Property<T, V>?, evaluator: TypeEvaluator<V>?, vararg values: V ): ObjectAnimator? { val anim = ObjectAnimator(target, property) anim.setObjectValues(*values) anim.setEvaluator(evaluator) return anim }"	"Constructs and returns an ObjectAnimator that animates between Object values . A single value implies that that value is the one being animated to . Two values imply a starting and ending values . More than two values imply a starting value , values to animate through along the way , and an ending value ( these values will be distributed evenly across the duration of the animation ) ."
private fun updateProgress(progress: Int) { if (myHost != null && progress != previousProgress) { myHost.updateProgress(progress) } previousProgress = progress }	Used to communicate a progress update between a plugin tool and the main Whitebox user interface .
"fun execUpdateGeo( context: Context, latitude: Double, longitude: Double, selectedItems: SelectedFiles? ): Int { val where = QueryParameter() setWhereSelectionPaths(where, selectedItems) val values = ContentValues(2) values.put(SQL_COL_LAT, DirectoryFormatter.parseLatLon(latitude)) values.put(SQL_COL_LON, DirectoryFormatter.parseLatLon(longitude)) val resolver: ContentResolver = context.getContentResolver() return resolver.update( SQL_TABLE_EXTERNAL_CONTENT_URI, values, where.toAndroidWhere(), where.toAndroidParameters() ) }"	Write geo data ( lat/lon ) media database. < br/ >
fun reset() { windowedBlockStream.reset() }	reset the environment to reuse the resource .
"@Throws(InternalTranslationException::class) fun generate( environment: ITranslationEnvironment, offset: Long, instructions: MutableList<ReilInstruction?> ): Pair<org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize?, String?>? { Preconditions.checkNotNull(environment, ""Error: Argument environment can't be null"") Preconditions.checkNotNull(instructions, ""Error: Argument instructions can't be null"") Preconditions.checkArgument(offset >= 0, ""Error: Argument offset can't be less than 0"") val connected: String = environment.getNextVariableString() val negated: String = environment.getNextVariableString() instructions.add( ReilHelpers.createXor( offset, org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, SyncStateContract.Helpers.SIGN_FLAG, org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, SyncStateContract.Helpers.OVERFLOW_FLAG, org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, connected ) ) instructions.add( ReilHelpers.createXor( offset + 1, org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, connected, org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, ""1"", org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, negated ) ) return Pair<org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize, String>( org.graalvm.compiler.asm.amd64.AMD64Assembler.OperandSize.BYTE, negated ) }"	Generates code for the NotLess condition .
fun isFinished(): Boolean { return isCompleted() || isFailed() || isCanceled() }	"< p > Finished means it is either completed , failed or canceled. < /p >"
"private fun drawBackground() { val rect: java.awt.Rectangle = getClientArea() cachedGC.setForeground(gradientStart) cachedGC.setBackground(gradientEnd) cachedGC.fillGradientRectangle(rect.x, rect.y, rect.width, rect.height / 2, true) cachedGC.setForeground(gradientEnd) cachedGC.setBackground(gradientStart) cachedGC.fillGradientRectangle(rect.x, rect.height / 2, rect.width, rect.height / 2, true) }"	Draw the background
"fun read(buf: ByteArray) { var numToRead = buf.size if (position + numToRead > buffer.length) { numToRead = buffer.length - position System.arraycopy(buffer, position, buf, 0, numToRead) for (i in numToRead until buf.size) { buf[i] = 0 } } else { System.arraycopy(buffer, position, buf, 0, numToRead) } position += numToRead }"	Reads up to < tt > buf.length < /tt > bytes from the stream into the given byte buffer .
fun QueryExecutionTimeoutException(msg: String?) { super(msg) }	Constructs an instance of < code > QueryExecutionTimeoutException < /code > with the specified detail message .
"private fun displayInternalServerError() { alertDialog = CommonDialogUtils.getAlertDialogWithOneButtonAndTitle( context, getResources().getString(R.string.title_head_connection_error), getResources().getString(R.string.error_internal_server), getResources().getString(R.string.button_ok), null ) alertDialog.show() }"	Displays an internal server error message to the user .
"fun updateOrdering(database: SQLiteDatabase, originalPosition: Long, newPosition: Long) { Log.d(""ItemDAO"", ""original: $originalPosition, newPosition:$newPosition"") if (originalPosition > newPosition) { database.execSQL( UPDATE_ORDER_MORE, arrayOf(newPosition.toString(), originalPosition.toString()) ) } else { database.execSQL( UPDATE_ORDER_LESS, arrayOf(originalPosition.toString(), newPosition.toString()) ) } }"	Updates the orderings between the original and new positions
fun onAdChanged() { notifyDataSetChanged() }	Raised when the number of ads have changed . Adapters that implement this class should notify their data views that the dataset has changed .
"@Throws(IOException::class) fun createSocket(host: InetAddress?, port: Int): Socket { val socket: Socket = createSocket() connectSocket(socket, InetSocketAddress(host, port)) return socket }"	Creates a socket and connect it to the specified remote address on the specified remote port .
@Throws(Exception::class) fun openExistingFileForWrite(name: String?): sun.rmi.log.ReliableLog.LogFile? { val logfile = File(name) val tf: sun.rmi.log.ReliableLog.LogFile = sun.rmi.log.ReliableLog.LogFile(logfile) tf.openWrite() return tf }	Open an existing file for writing .
fun AgeGreaterThanCondition(age: Int) { this.age = age }	Creates a new AgeGreaterThanCondition .
"@ DSComment ( ""Private Method"" ) @ DSBan ( DSCat . PRIVATE_METHOD ) @ DSGenerator ( tool_name = ""Doppelganger"" , tool_version = ""2.0"" , generated_on = ""2013-12-30 12:57:24.266 -0500"" , hash_original_method = ""542A19C49303D6524BE63DEB812200B5"" , hash_generated_method = ""433131C2E635F21E7867A70992F1749C"" ) private ComparableTimSort ( Object [ ] a ) { this . a = a ; int len = a . length ; @ SuppressWarnings ( { ""unchecked"" , ""UnnecessaryLocalVariable"" } ) Object [ ] newArray = new Object [ len < 2 * INITIAL_TMP_STORAGE_LENGTH ? len > > > 1 : INITIAL_TMP_STORAGE_LENGTH ] ; tmp = newArray ; int stackLen = ( len < 120 ? 5 : len < 1542 ? 10 : len < 119151 ? 19 : 40 ) ; runBase = new int [ stackLen ] ; runLen = new int [ stackLen ] ; }"	Creates a TimSort instance to maintain the state of an ongoing sort .
"fun compare(left: Date, right: Double): Int { return compare( left.getTime() / 1000, DateTimeUtil.getInstance().toDateTime(right).getTime() / 1000 ) }"	compares a Date with a double
fun removeGraphNode(node: SpaceEffGraphNode) { if (node === _firstNode) { if (node === _lastNode) { _lastNode = null _firstNode = _lastNode } else { _firstNode = node.getNext() } } else if (node === _lastNode) { _lastNode = node.getPrev() } node.remove() numberOfNodes-- }	Remove a node from the graph .
"fun <T> fromJSONString(jsonString: String?, selectAs: String?): JSONProperty<T>? { return fromJSONFunction(jdk.nashorn.internal.runtime.JSONFunctions.json(jsonString), selectAs) }"	"Construct a JSONProperty from a JSON string and with the given alias , e.g . `` 'hello ' AS greeting '' . This is a convenience method equivalent to < code > fromJSONFunction ( JSONFunctions.json ( jsonString ) , selectAs ) < /code >"
"fun addGroupChatComposingStatus(chatId: String?, status: Boolean) { synchronized(getImsServiceSessionOperationLock()) { mGroupChatComposingStatusToNotify.put( chatId, status ) } }"	Adds the group chat composing status to the map to enable re-sending upon media session restart
"@Throws(IOException::class) fun createCmds(runConfiguration: ChromeRunnerRunOptions): Array<String?>? { val commands: ArrayList<String> = ArrayList() commands.add(nodeJsBinary.get().getBinaryAbsolutePath()) val nodeOptions = System.getProperty(NODE_OPTIONS) if (nodeOptions != null) { for (nodeOption in nodeOptions.split("" "".toRegex()).dropLastWhile { it.isEmpty() } .toTypedArray()) { commands.add(nodeOption) } } val elfData: StringBuilder = getELFCode( runConfiguration.getInitModules(), runConfiguration.getExecModule(), runConfiguration.getExecutionData() ) val elf: File = createTempFileFor(elfData.toString()) commands.add(elf.getCanonicalPath()) return commands.toArray(arrayOf()) }"	"Creates commands for calling Node.js on command line . Data wrapped in passed parameter is used to configure node itself , and to generate file that will be executed by Node ."
"fun mulComponentWise(other: Matrix4x3dc?): Matrix4x3d? { return mulComponentWise(other, this) }"	Component-wise multiply < code > this < /code > by < code > other < /code > .
"@Throws(Exception::class) fun testTypes() { try { this.stmt.execute(""DROP TABLE IF EXISTS typesRegressTest"") this.stmt.execute(""CREATE TABLE typesRegressTest (varcharField VARCHAR(32), charField CHAR(2), enumField ENUM('1','2'),"" + ""setField SET('1','2','3'), tinyblobField TINYBLOB, mediumBlobField MEDIUMBLOB, longblobField LONGBLOB, blobField BLOB)"") this.rs = this.stmt.executeQuery(""SELECT * from typesRegressTest"") val rsmd: ResultSetMetaData = this.rs.getMetaData() val numCols: Int = rsmd.getColumnCount() for (i in 0 until numCols) { val columnName: String = rsmd.getColumnName(i + 1) val columnTypeName: String = rsmd.getColumnTypeName(i + 1) println(""$columnName -> $columnTypeName"") } } finally { this.stmt.execute(""DROP TABLE IF EXISTS typesRegressTest"") } }"	Tests for types being returned correctly
"fun deleteFile(context: Context, file: File): Boolean { var success: Boolean = file.delete() if (!success && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { val document: DocumentFile = getDocumentFile(context, file, false, false) success = document != null && document.delete() } if (!success && Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) { val resolver: ContentResolver = context.getContentResolver() success = try { val uri: Uri? = null if (uri != null) { resolver.delete(uri, null, null) } !file.exists() } catch (e: Exception) { Log.e(TAG, ""Error when deleting file "" + file.getAbsolutePath(), e) return false } } if (success) scanFile(context, arrayOf(file.getPath())) return success }"	Delete a file . May be even on external SD card .
"fun displayInfoLine(infoLine: String?, labelDesignator: Int) { if (infoLineHolder != null) { setLabel( if (infoLine != null && infoLine.length > 0) infoLine else fudgeString, labelDesignator ) } }"	Display a line of text in a designated info line .
"fun addMember( parentType: sun.reflect.generics.tree.BaseType?, memberType: sun.reflect.generics.tree.BaseType? ): DependenceResult? { Preconditions.checkNotNull(parentType, ""IE02762: Parent type can not be null."") Preconditions.checkNotNull(memberType, ""IE02763: Member type can not be null."") val memberTypeNode: Node = Preconditions.checkNotNull( containedRelationMap.get(memberType), ""Type node for member type must exist prior to adding a member."" ) val parentNode: Node = Preconditions.checkNotNull( containedRelationMap.get(parentType), ""Type node for member parent must exist prior to adding a member"" ) if (willCreateCycle(parentType, memberType)) { return DependenceResult(false, ImmutableSet.of<sun.reflect.generics.tree.BaseType>()) } containedRelation.createEdge(memberTypeNode, parentNode) val search = TypeSearch(containedRelationMap.inverse()) search.start(containedRelation, containedRelationMap.get(parentType)) return DependenceResult(true, search.getDependentTypes()) }"	Adds a member to the dependence graph and returns the set of base types that are affected by the changed compound type . This method assumes that all base type nodes that correspond to the member base type already exist .
"int [ ] decodeStart ( BitArray row ) throws NotFoundException { int endStart = skipWhiteSpace ( row ) ; int [ ] startPattern = findGuardPattern ( row , endStart , START_PATTERN ) ; this . narrowLineWidth = ( startPattern [ 1 ] - startPattern [ 0 ] ) > > 2 ; validateQuietZone ( row , startPattern [ 0 ] ) ; return startPattern ; }"	Identify where the start of the middle / payload section starts .
"fun contains(array: IntArray?, value: Int): Boolean { return indexOf(array, value) !== -1 }"	Returns < code > true < /code > if an array contains given value .
fun acosh(value: Double): Double { if (value <= 1.0) { return if (ANTI_JIT_OPTIM_CRASH_ON_NAN) { if (value < 1.0) Double.NaN else value - 1.0 } else { if (value == 1.0) 0.0 else Double.NaN } } val result: Double if (value < ASINH_ACOSH_SQRT_ELISION_THRESHOLD) { result = log(value + sqrt(value * value - 1.0)) } else { result = LOG_2 + log(value) } return result }	"Some properties of acosh ( x ) = log ( x + sqrt ( x^2 - 1 ) ) : 1 ) defined on [ 1 , +Infinity [ 2 ) result in ] 0 , +Infinity [ ( by convention , since cosh ( x ) = cosh ( -x ) ) 3 ) acosh ( 1 ) = 0 4 ) acosh ( 1+epsilon ) ~= log ( 1 + sqrt ( 2*epsilon ) ) ~= sqrt ( 2*epsilon ) 5 ) lim ( acosh ( x ) , x- > +Infinity ) = +Infinity ( y increasing logarithmically slower than x )"
"fun fireDataStatusEEvent(AD_Message: String?, info: String?, isError: Boolean) { m_mTable.fireDataStatusEEvent(AD_Message, info, isError) }"	Create and fire Data Status Error Event
"fun AttributeDefinition(attrs: TextAttributeSet, beginIndex: Int, endIndex: Int) { this.attrs = attrs this.beginIndex = beginIndex this.endIndex = endIndex }"	Create new AttributeDefinition .
fun consumeGreedy(greedyToken: String) { if (greedyToken.length < sval.length()) { pushBack() setStartPosition(getStartPosition() + greedyToken.length) sval = sval.substring(greedyToken.length) } }	Consumes a substring from the current sval of the StreamPosTokenizer .
@Throws(HexFormatException::class) fun hexToDecimal(hex: String): Int { var decimalValue = 0 for (i in 0 until hex.length) { if (!(hex[i] >= '0' && hex[i] <= '9' || hex[i] >= 'A' && hex[i] <= 'F')) throw HexFormatException( hex ) val hexChar = hex[i] decimalValue = decimalValue * 16 + hexCharToDecimal(hexChar) } return decimalValue }	Converts a hex string into a decimal number and throws a HexFormatException if the string is not a hex string
"@Throws(NotFoundException::class, ChecksumException::class, FormatException::class) fun decode(image: BinaryBitmap?): Result? { return decode(image, null) }"	Locates and decodes a QR code in an image .
"fun listRawBackup(ignore: Boolean): BackupFileSet? { val clusterBackupFiles = BackupFileSet(this.quorumSize) val errorList: List<String> = ArrayList() try { val backupTasks: List<BackupProcessor.BackupTask<List<BackupSetInfo>>> = BackupProcessor(getHosts(), Arrays.asList(ports.get(2)), null).process( ListBackupCallable(), false ) var result: Throwable? = null for (task in backupTasks) { try { clusterBackupFiles.addAll( task.getResponse().getFuture().get(), task.getRequest().getNode() ) log.info(""List backup on node({})success"", task.getRequest().getHost()) } catch (e: CancellationException) { log.warn( ""The task of listing backup on node({}) was canceled"", task.getRequest().getHost(), e ) } catch (e: InterruptedException) { log.error( java.lang.String.format( ""List backup on node(%s:%d) failed"", task.getRequest().getHost(), task.getRequest().getPort() ), e ) result = result ?: e errorList.add(task.getRequest().getNode()) } catch (e: ExecutionException) { val cause: Throwable = e.getCause() if (ignore) { log.warn( java.lang.String.format( ""List backup on node(%s:%d) failed."", task.getRequest().getHost(), task.getRequest().getPort() ), cause ) } else { log.error( java.lang.String.format( ""List backup on node(%s:%d) failed."", task.getRequest().getHost(), task.getRequest().getPort() ), cause ) } result = result ?: cause errorList.add(task.getRequest().getNode()) } } if (result != null) { if (result is Exception) { throw (result as Exception?)!! } else { throw Exception(result) } } } catch (e: Exception) { val cause = if (e.cause == null) e else e.cause!! if (ignore) { log.warn( ""List backup on nodes({}) failed, but ignore the errors"", errorList.toString(), cause ) } else { log.error(""Exception when listing backups"", e) throw BackupException.fatals.failedToListBackup(errorList.toString(), cause) } } return clusterBackupFiles }"	Get a list of backup sets info
"fun CountingIdlingResource(resourceName: String, debugCounting: Boolean) { require(!TextUtils.isEmpty(resourceName)) { ""Resource name must not be empty or null"" } this.resourceName = resourceName this.debugCounting = debugCounting }"	Creates a CountingIdlingResource .
"fun create(thisSize: String): ImageReuseInfo? { val list = ArrayList<String>() var canBeReused = false for (i in 0 until mSizeList.length) { val size: String = mSizeList.get(i) if (!canBeReused && thisSize == size) { canBeReused = true continue } if (canBeReused && thisSize != size) { list.add(size) } } return if (list.size() === 0) { ImageReuseInfo(thisSize, null) } else { val sizeList = arrayOfNulls<String>(list.size()) list.toArray(sizeList) ImageReuseInfo(thisSize, sizeList) } }"	Find out the size list can be re-sued .
"fun sync(address: Address?, size: Int) { SysCall.sysCall.sysSyncCache(address, size) }"	Synchronize a region of memory : force data in dcache to be written out to main memory so that it will be seen by icache when instructions are fetched back .
"fun MonthDateFormat(locale: Locale?) { this(TimeZone.getDefault(), locale, 1, true, false) }"	Creates a new instance for the specified time zone .
"fun testConnectorSecuritySettingsSSL_alias_not_defined() { resetSecuritySystemProperties() var authInfo: sun.net.www.protocol.http.AuthenticationInfo? = null try { authInfo = SecurityHelper.loadAuthenticationInformation( ""test.ssl.alias.not.defined.security.properties"", true, TUNGSTEN_APPLICATION_NAME.CONNECTOR ) } catch (e: java.rmi.ServerRuntimeException) { assertTrue(""There should not be any exception thrown"", false) } catch (e: javax.naming.ConfigurationException) { assertFalse(""That should not be this kind of Exception being thrown"", true) } resetSecuritySystemProperties() }"	Confirm behavior when connector.security.use.SSL=true and alias are not defined This shows that it uses first alias it finds
"@Synchronized fun add(x: Double, y: Double) { add(x, y, 0.0) }"	Adds a new value to the series .
"@Synchronized fun add(x: Double, y: Double) { add(x, y, 0.0) }"	This method is called when a fatal error occurs during parsing . This method rethrows the exception
"fun run() { amIActive = true if (args.length < 2) { showFeedback(""Plugin parameters have not been set properly."") return } val inputHeader: String = args.get(0) val outputHeader: String = args.get(1) if (inputHeader == null || outputHeader == null) { showFeedback(""One or more of the input parameters have not been set properly."") return } try { var row: Int var col: Int var z: Double var progress: Int var oldProgress = -1 var data: DoubleArray val inputFile = WhiteboxRaster(inputHeader, ""r"") val rows: Int = inputFile.getNumberRows() val cols: Int = inputFile.getNumberColumns() val noData: Double = inputFile.getNoDataValue() val outputFile = WhiteboxRaster(outputHeader, ""rw"", inputHeader, WhiteboxRaster.DataType.FLOAT, noData) outputFile.setPreferredPalette(inputFile.getPreferredPalette()) row = 0 while (row < rows) { data = inputFile.getRowValues(row) col = 0 while (col < cols) { z = data[col] if (z != noData) { outputFile.setValue(row, col, Math.asin(z)) } col++ } progress = (100f * row / (rows - 1)).toInt() if (progress != oldProgress) { oldProgress = progress updateProgress(progress) if (cancelOp) { cancelOperation() return } } row++ } outputFile.addMetadataEntry(""Created by the "" + getDescriptiveName() + "" tool."") outputFile.addMetadataEntry(""Created on "" + Date()) inputFile.close() outputFile.close() returnData(outputHeader) } catch (oe: OutOfMemoryError) { myHost.showFeedback(""An out-of-memory error has occurred during operation."") } catch (e: Exception) { myHost.showFeedback(""An error has occurred during operation. See log file for details."") myHost.logException(""Error in "" + getDescriptiveName(), e) } finally { updateProgress(""Progress: "", 0) amIActive = false myHost.pluginComplete() } }"	Used to execute this plugin tool .
"fun addMoreComponents(cnt: Container, components: Array<Component?>?, areThereMore: Boolean) { val ia: InfiniteScrollAdapter = cnt.getClientProperty(""cn1\$infinite"") as InfiniteScrollAdapter ia.addMoreComponents(components, areThereMore) }"	"Invoke this method to add additional components to the container , if you use addComponent/removeComponent you will get undefined behavior . This is a convenience method saving the need to keep the InfiniteScrollAdapter as a variable"
fun progress(texture: CCTexture2D?): CCProgressTimer? { return CCProgressTimer(texture) }	Creates a progress timer with the texture as the shape the timer goes through
fun EntityMappingModelImpl() { super() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun match(): MatchResult? { check(matchSuccessful) return matcher.toMatchResult() }	Returns the result of the last matching operation . < p > The next* and find* methods return the match result in the case of a successful match .
"fun dispatch(event: IEvent) { val eventType: Class<out IEvent?> = event.getClass() Discord4J.logger.debug(""Dispatching event of type {}."", eventType.simpleName) if (listenerMap.containsKey(eventType)) { for (listener in listenerMap.get(eventType)) { listener.receive(event) } } }"	Sends an IEvent to all listeners that listen for that specific event .
fun createMouthComboBox(): javax.swing.JComboBox? { val cb: javax.swing.JComboBox = javax.swing.JComboBox() fillComboBox(cb) cb.addActionListener(this) return cb }	Creates the mouth combo box .
"fun leverageForRule( premise: AprioriItemSet?, consequence: AprioriItemSet, premiseCount: Int, consequenceCount: Int ): Double { val coverageForItemSet = consequence.m_counter as Double / m_totalTransactions as Double val expectedCoverageIfIndependent = premiseCount.toDouble() / m_totalTransactions as Double * (consequenceCount.toDouble() / m_totalTransactions as Double) return coverageForItemSet - expectedCoverageIfIndependent }"	Outputs the leverage for a rule . Leverage is defined as : < br > prob ( premise & consequence ) - ( prob ( premise ) * prob ( consequence ) )
"fun RdKNNNode(capacity: Int, isLeaf: Boolean) { super(capacity, isLeaf, RdKNNEntry::class.java) }"	Creates a new RdKNNNode object .
private fun adaptGridViewHeight() { if (gridView is DividableGridView) { (gridView as DividableGridView).adaptHeightToChildren() } }	"Adapts the height of the grid view , which is used to show the bottom sheet 's items ."
fun validateOnStatus() { if (Command.STATUS.equals(getCommand())) { } }	Validates the arguments passed to the Builder when the 'status ' command has been issued .
fun eagerCheck(): Optional<Boolean?>? { return Optional.ofNullable(this.eagerCheck) }	whether check errors as more as possible
"fun newInstance(song: Song?): NewPlaylistFragment? { val fragment = NewPlaylistFragment() val bundle = Bundle() bundle.putParcelable(KEY_SONG, song) fragment.setArguments(bundle) return fragment }"	Creates a new instance of the New Playlist dialog fragment to create a new playlist and add a song to it .
"@DSSink([DSSinkKind.LOG]) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:29:19.771 -0500"", hash_original_method = ""06AF2B97EC9C8BBE1303A237FE727449"", hash_generated_method = ""103A7E1B02C228D1981B721CBC7DAC4C"" ) fun updateCursor(view: View, left: Int, top: Int, right: Int, bottom: Int) { checkFocus() synchronized(mH) { if (mServedView !== view && (mServedView == null || !mServedView.checkInputConnectionProxy( view )) || mCurrentTextBoxAttribute == null || mCurMethod == null ) { return } mTmpCursorRect.set(left, top, right, bottom) if (!mCursorRect.equals(mTmpCursorRect)) { if (DEBUG) Log.d(TAG, ""updateCursor"") try { if (DEBUG) Log.v(TAG, ""CURSOR CHANGE: $mCurMethod"") mCurMethod.updateCursor(mTmpCursorRect) mCursorRect.set(mTmpCursorRect) } catch (e: RemoteException) { Log.w(TAG, ""IME died: $mCurId"", e) } } } }"	Report the current cursor location in its window .
"fun buildTextAnnotation( corpusId: String?, textId: String?, text: String?, tokens: Array<String?>, sentenceEndPositions: IntArray, sentenceViewGenerator: String?, sentenceViewScore: Double ): TextAnnotation? { require(sentenceEndPositions[sentenceEndPositions.size - 1] == tokens.size) { ""Invalid sentence boundary. Last element should be the number of tokens"" } val offsets: Array<IntPair> = TokenUtils.getTokenOffsets(text, tokens) assert(offsets.size == tokens.size) val ta = TextAnnotation(corpusId, textId, text, offsets, tokens, sentenceEndPositions) val view = SpanLabelView(ViewNames.SENTENCE, sentenceViewGenerator, ta, sentenceViewScore) var start = 0 for (s in sentenceEndPositions) { view.addSpanLabel(start, s, ViewNames.SENTENCE, 1.0) start = s } ta.addView(ViewNames.SENTENCE, view) val tokView = SpanLabelView(ViewNames.TOKENS, sentenceViewGenerator, ta, sentenceViewScore) for (tokIndex in tokens.indices) { tokView.addSpanLabel(tokIndex, tokIndex + 1, tokens[tokIndex], 1.0) } ta.addView(ViewNames.TOKENS, tokView) return ta }"	instantiate a TextAnnotation using a SentenceViewGenerator to create an explicit Sentence view
"import java.util.* private fun guessContentType(url: String): String? { var url = url url = url.lowercase(Locale.getDefault()) return if (url.endsWith("".webm"")) { ""video/webm"" } else if (url.endsWith("".mp4"")) { ""video/mp4"" } else if (url.matches("".*\\.jpe?g"")) { ""image/jpeg"" } else if (url.endsWith("".png"")) { ""image/png"" } else if (url.endsWith("".gif"")) { ""image/gif"" } else { ""application/octet-stream"" } }"	Guess a content type from the URL .
"fun FilteredTollHandler(simulationEndTime: Double, numberOfTimeBins: Int) { this(simulationEndTime, numberOfTimeBins, null, null) LOGGER.info(""No filtering is used, result will include all links, persons from all user groups."") }"	"No filtering will be used , result will include all links , persons from all user groups ."
fun isSecondHandVisible(): Boolean { return secondHandVisible }	Return secondHandVisible
"fun addStylesheet(href: String?, type: String?): XMLDocument? { val pi = PI() pi.setTarget(""xml-stylesheet"").addInstruction(""href"", href).addInstruction(""type"", type) prolog.addElement(pi) return this }"	This adds a stylesheet to the XML document .
"fun GenericMTreeDistanceSearchCandidate(mindist: Double, nodeID: Int, routingObjectID: DBID?) { this.mindist = mindist this.nodeID = nodeID this.routingObjectID = routingObjectID }"	Creates a new heap node with the specified parameters .
"private fun lf_delta1(x: Int): Int { return lf_S(x, 17) xor lf_S(x, 19) xor lf_R(x, 10) }"	logical function delta1 ( x ) - xor of results of right shifts/rotations
"fun extractBestMaxRuleParse(start: Int, end: Int, sentence: List<String?>?): Tree<String?>? { return extractBestMaxRuleParse1(start, end, 0, sentence) }"	"Returns the best parse , the one with maximum expected labelled recall . Assumes that the maxc* arrays have been filled ."
"fun lastIndexOf(ch: Char): Int { return lastIndexOf(ch, size - 1) }"	Searches the string builder to find the last reference to the specified char .
fun m00(m00: Float): Matrix4x3f? { this.m00 = m00 properties = properties and (PROPERTY_IDENTITY or PROPERTY_TRANSLATION).inv() return this }	Set the value of the matrix element at column 0 and row 0
"@Throws(Exception::class) private fun processTargetPortsToFormHSDs( hdsApiClient: HDSApiClient, storage: StorageSystem, targetURIList: List<URI>, hostName: String, exportMask: ExportMask, hostModeInfo: Pair<String, String>?, systemObjectID: String ): List<HostStorageDomain?>? { val hsdList: List<HostStorageDomain> = ArrayList<HostStorageDomain>() var hostMode: String? = null var hostModeOption: String? = null if (hostModeInfo != null) { hostMode = hostModeInfo.first hostModeOption = hostModeInfo.second } for (targetPortURI in targetURIList) { val storagePort: StoragePort = dbClient.queryObject(StoragePort::class.java, targetPortURI) val storagePortNumber: String = getStoragePortNumber(storagePort.getNativeGuid()) val dataSource: DataSource = dataSourceFactory.createHSDNickNameDataSource(hostName, storagePortNumber, storage) val hsdNickName: String = customConfigHandler.getComputedCustomConfigValue( CustomConfigConstants.HDS_HOST_STORAGE_DOMAIN_NICKNAME_MASK_NAME, storage.getSystemType(), dataSource ) if (Transport.IP.name().equalsIgnoreCase(storagePort.getTransportType())) { log.info(""Populating iSCSI HSD for storage: {}"", storage.getSerialNumber()) val hostGroup = HostStorageDomain( storagePortNumber, exportMask.getMaskName(), HDSConstants.ISCSI_TARGET_DOMAIN_TYPE, hsdNickName ) hostGroup.setHostMode(hostMode) hostGroup.setHostModeOption(hostModeOption) hsdList.add(hostGroup) } if (Transport.FC.name().equalsIgnoreCase(storagePort.getTransportType())) { log.info(""Populating FC HSD for storage: {}"", storage.getSerialNumber()) val hostGroup = HostStorageDomain( storagePortNumber, exportMask.getMaskName(), HDSConstants.HOST_GROUP_DOMAIN_TYPE, hsdNickName ) hostGroup.setHostMode(hostMode) hostGroup.setHostModeOption(hostModeOption) hsdList.add(hostGroup) } } return hsdList }"	This routine iterates through the target ports and prepares a batch of HostStorageDomain Objects with required information .
"private fun isInResults(results: ArrayList<Media>, id: String): Int { var i = 0 for (item in results) { if (item.videoId.equals(id)) return i i++ } return -1 }"	Test if there is an item that already exists
"private fun parseToken(terminators: CharArray): String? { var ch: Char i1 = pos i2 = pos while (hasChar()) { ch = chars.get(pos) if (isOneOf(ch, terminators)) { break } i2++ pos++ } return getToken(false) }"	Parse out a token until any of the given terminators is encountered .
"@Ignore(""TODO: disabled because rather than throwing an exception, getAll catches all exceptions and logs a warning message"") @Test fun testNonColocatedGetAll() { doNonColocatedbulkOp(OP.GETALL) }"	"disabled because rather than throwing an exception , getAll catches all exceptions and logs a warning message"
"fun buildMatchObject( sequenceIdentifier: String?, model: String?, signatureLibraryRelease: String?, seqStart: Int, seqEnd: Int, cigarAlign: String?, score: Double?, profileLevel: ProfileScanRawMatch.Level?, patternLevel: PatternScanMatch.PatternScanLocation.Level? ): PfScanRawMatch? { return HamapRawMatch( sequenceIdentifier, model, signatureLibraryRelease, seqStart, seqEnd, cigarAlign, score, profileLevel ) }"	Method to be implemented that builds the correct kind of PfScanRawMatch .
"private fun updateServerStatus() { try { val page = StringBuffer() page.append(""<?php\n"") page.append(""session_start();\n"") page.append(""\$username = 'Guest';\n"") page.append(""if (array_key_exists('username', $_SESSION)) { \$username = $_SESSION['username']; }\n"") page.append(""?>\n"") page.append(""<html>\n<head>\n <title>R Server</title>\n"") page.append("" <script>\n"") page.append("" function reload() { \n"") page.append("" var isIE = /*@cc_on!@*/false || !!document.documentMode;\n"") page.append("" if (!isIE) location.reload();\n"") page.append("" }\n"") page.append( """""" ${"" setTimeout(reload, $pageRefreshTime""}) """""".trimIndent() ) page.append("" </script>\n"") page.append("" <link rel=\""stylesheet\"" type=\""text/css\"" href=\""rserver.css\"">\n"") page.append(""</head>\n<body>\n"") page.append(""<div id=\""MainDiv\"">\n\n"") page.append(""<div id=\""HeaderDiv\"">\n"") page.append("" <div id=\""NavHeaderDiv\""></div>\n"") page.append("" <div id=\""NavLogo\""></div>\n"") page.append("" <a id=\""newHeaderNavigation-logo\"" href=\""/RServer\"" title=\""R Server\""></a>\n"") page.append("" <ul id=\""NavBar\"">\n"") page.append("" <li><a href=\""https://github.com/bgweber/RServer\"">EA RServer</a></li>\n"") page.append("" <li><a href=\""NewTask.php\"">Submit New Task</a>\n"") page.append("" <li><a href=\""Reports.php\"">Reports</a></li>\n"") page.append("" <li><a href=\""logs\"">Server Logs</a></li>\n"") page.append("" <li><a href=\""Rout\"">Script Results</a></li>\n"") page.append("" <li><a href=\""reports/RServer/RServerTasks.html\"">Task Report</a></li>\n"") page.append("" </ul>\n\n"") page.append(""</div>\n\n"") page.append("" <div id=\""SubHeaderDiv\"">\n"") page.append("" <h2 id=\""RHeader\"">R Server: </h2>\n"") page.append( """""" <?php if ((time() - ${System.currentTimeMillis() / 1000}) < 10) { echo ""<h2 id=\""ServerOnline\"">Online</h2>""; } else { echo ""<h2 id=\""ServerOffline\"">Offline</h2>""; } ?> """""".trimIndent() ) page.append("" </div>\n\n"") page.append("" <div id=\""ContentDiv\"">\n"") page.append("" <script>\n"") page.append("" var isIE = /*@cc_on!@*/false || !!document.documentMode;\n"") page.append("" if (isIE) document.write('<p><h2>Note: Auto-reload is disabled for Internet Explorer. Please use Chrome, Firefox, or Opera.<h2>'); \n"") page.append("" </script>\n"") page.append(""<h3 id=\""StatsHeader\"">Server Statistics</h3>\n"") page.append(""<table id=\""StatsTable\"">\n"") page.append("" <thead>\n"") page.append("" <th>Property</th>\n <th>Value</th>\n"") page.append("" </thead>\n"") if (fullHostName != null) { page.append( """""" ${"" <tr><td>Server Name</td><td>$fullHostName""}</td></tr> """""".trimIndent() ) } page.append( """""" ${"" <tr><td>Server Updated</td><td>"" + Date(System.currentTimeMillis()).toString()}</td></tr> """""".trimIndent() ) val runtime = Runtime.getRuntime() val memory = ((runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024).toString() + "" / "" + runtime.totalMemory() / 1024 / 1024 + "" MB"" try { var totalMem: Double = sigar.getMem().getTotal() / 1024 / 1024 / 1024.0 var usedMem: Double = (sigar.getMem().getTotal() - sigar.getMem().getFree()) / 1024 / 1024 / 1024.0 cpuLoad = 1 - sigar.getCpuPerc().getIdle() totalMem = (totalMem * 10).toInt() / 10.0 usedMem = (usedMem * 10).toInt() / 10.0 page.append("" <tr><td>Server CPU Usage</td><td>"" + (cpuLoad * 1000) as Int / 10.0 + ""%</td></tr>\n"") page.append("" <tr><td>Server Memory</td><td>$usedMem / $totalMem GB</td></tr>\n"") } catch (e: Exception) { log(""ERROR: unable to update system stats: "" + e.message) } page.append("" <tr><td>Application Memory</td><td>$memory</td></tr>\n"") page.append( """""" <tr><td>Thread Count</td><td>${Thread.activeCount()}</td></tr> """""" ) page.append( """""" <tr><td>Git Updated</td><td>${if (lastPerforceUpdate > 0) Date(lastPerforceUpdate).toString() else ""No history""}</td></tr> """""" ) page.append( """""" ${"" <tr><td>Server Launched</td><td>"" + Date(bootTime).toString()}</td></tr> """""".trimIndent() ) page.append( """""" ${"" <tr><td>Server Version</td><td>$ServerDate""}</td></tr> """""".trimIndent() ) page.append(""</table>\n\n"") page.append(""<h3 id=\""LogHeader\"">R Server Reports</h3>\n"") page.append(""<ul id=\""LogList\"">\n"") page.append("" <li><a href=\""reports/RServer/RServerReport.html\"">R Server Activity</a></li>\n"") page.append("" <li><a href=\""reports/RServer/RServerTasks.html\"">Task Report</a></li>\n"") page.append(""</ul>\n"") page.append(""<h3 id=\""RunningHeader\"">Running Tasks</h3>\n"") page.append(""<table id=\""RunningTable\"">\n"") page.append("" <thead>\n"") page.append( """""" <th>Task Name</th> <th>Log File</th> <th>Start Time</th> <th>Duration</th> <th>Runtime Parameters</th> <th>Owner</th> <th>End Process</th> """""" ) page.append("" </thead>\n"") synchronized(this@RServer) { for (task in runningTasks.values()) { val startTime: Long = task.getStartTime() val duration = (System.currentTimeMillis() - startTime) / 1000 page.append("" <tr>\n"") page.append("" <td>"" + (if (task.getShinyApp()) ""<a href=\"""" + task.getShinyUrl() + ""\"">"" else """") + task.getTaskName() + (if (task.getShinyApp()) ""</a>"" else """") + ""</td>"") if (task.getrScript().toLowerCase().contains("".r"") || task.getIsPython()) { val link = ""<a href=\""Rout.php?task="" + task.getTaskName() + ""&log="" + (if (task.getrScript() .contains("".r"") ) task.getrScript() + "".Rout"" else task.getrScript().split(""\\."") .get(0) + "".Rout"") + ""\"">"" + task.getrScript() + ""</a>"" page.append(""\n <td>$link</td>"") } else { page.append(""\n <td> </td>"") } page.append( """""" <td>${Date(startTime).toString()}</td>"""""" ) page.append( """""" <td>${if (task.getShinyApp()) """" else (duration / 60).toString() + "" m "" + duration % 60 + "" s""}</td>"""""" ) page.append( """""" <td>${task.getParameters()}</td>"""""" ) page.append( """""" <td>${task.getOwner()}</td>"""""" ) if (PerforceTask.equalsIgnoreCase(task.getTaskName())) { page.append(""\n <td> </td>"") } else { page.append( """"""${ """""" <td><form onsubmit=""return confirm('Are you sure?')"" action=""KillTask.php"" method=""post""> <input type=""hidden"" name=""name"" value=""${task.getTaskName()}"""""" }"" /> <button >Terminate</button> </form></td>"""""" ) } page.append(""\n </tr>\n"") } } page.append(""</table>\n\n"") page.append(""<h3 id=\""LogHeader\"">Recent Log Entries</h3>\n"") synchronized(this@RServer) { page.append(""<ul id=\""LogList\"">\n"") for (log in logEntries) { if (log.contains(""ERROR:"")) { page.append("" <li class=\""FontLogError\"">$log</li>\n"") } else { page.append("" <li>$log</li>\n"") } } page.append(""</ul>\n\n"") } page.append(""<h3 id=\""SchedulesHeader\"">Scheduled Tasks</h3>\n"") page.append(""<table id=\""ScheduleTable\"">\n"") page.append("" <thead>\n"") page.append( """""" <th>Task Name</th> <th>R Script</th> <th>Runtime Parameters</th> <th>Frequency</th> <th>Next Run Time</th> <th>Owner</th> <th>Run Now</th> """""" ) page.append("" </thead>\n"") page.append(""<ul id=\""LogList\"">\n"") if (schedulePath.split(""//"").length > 1) { page.append( """""" ${"" <li>Schedule File: //"" + schedulePath.split(""//"").get(1)}</li> """""".trimIndent() ) } else { page.append( """""" ${"" <li>Schedule File: $schedulePath""}</li> """""".trimIndent() ) } page.append(""</ul>\n"") for (schedule in regularSchedules) { page.append("" <tr>\n"") page.append( """"""${ "" <td>"" + schedule.getTaskName() .replace(""_"", "" "") + ""</td>\n "" + ""<td>"" + schedule.getrScript().replace( ""_"", "" "" ) + ""</td>\n "" + ""<td>"" + schedule.getParameters() + ""</td>\n "" + ""<td>"" + (if (schedule.getFrequency() === Schedule.Frequency.Now) ""Startup"" else schedule.getFrequency()) + ""</td>\n <td>"" + (if (schedule.getFrequency() === Schedule.Frequency.Now || schedule.getFrequency() === Schedule.Frequency.Never) "" "" else Date( schedule.getNextRunTime() ).toString()) + ""</td>\n <td>"" + schedule.getOwner() + ""</td>\n "" + ""<td><form onsubmit=\""return confirm('Are you sure?')\"""" + "" action=\""SubmitTask.php\"" method=\""post\"">"" + ""\n <input type=\""hidden\"" name=\""name\"" value=\"""" + schedule.getTaskName() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""path\"" value=\"""" + schedule.getPerforcePath() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""rscript\"" value=\"""" + schedule.getrScript() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""email\"" value=\"""" + schedule.getOwner() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""sendemail\"" value=\"""" + schedule.getEmailOnSuccess() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""params\"" value=\"""" + schedule.getParameters() + ""\"" />"" + ""\n <input type=\""hidden\"" name=\""shiny\"" value=\"""" + schedule.getShinyApp() }"" /> <button>Start</button> </form></td> """""" ) page.append("" </tr>\n"") } page.append(""</table>\n\n"") page.append(""<h3 id=\""CompletedHeader\"">Completed Tasks</h3>\n"") page.append(""<table id=\""CompletedTable\"">\n"") page.append("" <thead>\n"") page.append( """""" <th>Task Name</th> <th>Completion Time</th> <th>Duration</th> <th>Runtime Parameters</th> <th>Outcome</th><th>.Rout log</th> <th>Owner</th> """""" ) page.append("" </thead>\n"") synchronized(this@RServer) { for (task in completed) { val duration: Long = (task.getEndTime() - task.getStartTime()) / 1000 page.append("" <tr>\n"") page.append( """"""${"" <td>"" + task.getTaskName().replace(""_"", "" "")}</td> <td>"""""" ) page.append( """"""${"" "" + Date(task.getEndTime()).toString()}</td> <td>"""""" ) page.append( """""" ${(duration / 60).toString() + "" m "" + duration % 60 + "" s ""}</td> <td>"""""" ) page.append( """"""${"" "" + task.getParameters()}</td> <td>"""""" ) page.append( "" "" + if (task.getOutcome() .equals(""Success"") ) ""<font class=\""FontTaskSuccess\"">"" else ""<font class=\""FontTaskFailure\"">"" ) page.append( """"""${"" "" + task.getOutcome()}</font></td> <td>"""""" ) if (task.getRout() != null) { page.append( ""<a href=\""Rout.php?path="" + task.getRout() + ""&log="" + task.getrScript() + "".Rout\"">"" + task.getrScript() .replace(""_"", "" "") + ""</a></td>\n"" ) } else { page.append("" </td>\n"") } page.append( """""" ${"" "" + ""<td>"" + task.getOwner()}</td> """""".trimIndent() ) page.append("" </tr>\n"") } } page.append(""</table>\n\n"") page.append(""</div>\n\n"") page.append(""<div id=\""FooterDiv\"">\n"") page.append("" <a href=\""https://github.com/bgweber/RServer\"">RServer on GitHub</a>\n"") page.append(""</div>\n\n"") page.append(""</div>\n</body>\n</html>\n"") val writer = BufferedWriter(FileWriter(indexPagePath)) writer.write(page.toString()) writer.close() } catch (e: Exception) { log(""ERROR: failure updating server status: "" + e.message) e.printStackTrace() } }"	Generates the index.php file for the server dashboard .
fun removeServerById(serverId: Int) { servers.remove(serverId) }	Remove server with given unique id from list
fun TreeSet(c: Comparator?) { this(TreeMap(c)) }	"Constructs a new , empty set , sorted according to the specified comparator . All elements inserted into the set must be < i > mutually comparable < /i > by the specified comparator : < tt > comparator.compare ( e1 , e2 ) < /tt > must not throw a < tt > ClassCastException < /tt > for any elements < tt > e1 < /tt > and < tt > e2 < /tt > in the set . If the user attempts to add an element to the set that violates this constraint , the < tt > add ( Object ) < /tt > call will throw a < tt > ClassCastException < /tt > ."
fun <T> read(operation: Supplier<T>): T { return try { lock.readLock().lock() operation.get() } finally { lock.readLock().unlock() } }	"Obtain a read lock , perform the operation , and release the read lock ."
"public void test_nCopiesILjava_lang_Object ( ) { Object o = new Object ( ) ; List l = Collections . nCopies ( 100 , o ) ; Iterator i = l . iterator ( ) ; Object first = i . next ( ) ; assertTrue ( ""Returned list consists of copies not refs"" , first == o ) ; assertEquals ( ""Returned list of incorrect size"" , 100 , l . size ( ) ) ; assertTrue ( ""Contains"" , l . contains ( o ) ) ; assertTrue ( ""Contains null"" , ! l . contains ( null ) ) ; assertTrue ( ""null nCopies contains"" , ! Collections . nCopies ( 2 , null ) . contains ( o ) ) ; assertTrue ( ""null nCopies contains null"" , Collections . nCopies ( 2 , null ) . contains ( null ) ) ; l = Collections . nCopies ( 20 , null ) ; i = l . iterator ( ) ; for ( int counter = 0 ; i . hasNext ( ) ; counter ++ ) { assertTrue ( ""List is too large"" , counter < 20 ) ; assertNull ( ""Element should be null: "" + counter , i . next ( ) ) ; } try { l . add ( o ) ; fail ( ""Returned list is not immutable"" ) ; } catch ( UnsupportedOperationException e ) { return ; } try { Collections . nCopies ( - 2 , new HashSet ( ) ) ; fail ( ""nCopies with negative arg didn't throw IAE"" ) ; } catch ( IllegalArgumentException e ) { } }"	"java.util.Collections # nCopies ( int , java.lang.Object )"
"fun test_nCopiesILjava_lang_Object() { val o = Any() var l: MutableList<*> = Collections.nCopies(100, o) var i: Iterator<*> = l.iterator() val first = i.next()!! assertTrue(""Returned list consists of copies not refs"", first === o) assertEquals(""Returned list of incorrect size"", 100, l.size) assertTrue(""Contains"", l.contains(o)) assertTrue(""Contains null"", !l.contains(null)) assertTrue(""null nCopies contains"", !Collections.nCopies(2, null).contains(o)) assertTrue(""null nCopies contains null"", Collections.nCopies(2, null).contains(null)) l = Collections.nCopies(20, null) i = l.iterator() var counter = 0 while (i.hasNext()) { assertTrue(""List is too large"", counter < 20) assertNull(""Element should be null: $counter"", i.next()) counter++ } try { l.add(o) fail(""Returned list is not immutable"") } catch (e: UnsupportedOperationException) { return } try { Collections.nCopies(-2, HashSet()) fail(""nCopies with negative arg didn't throw IAE"") } catch (e: IllegalArgumentException) { } }"	"add a + b + 1 , returning the result in a . The a value is treated as a BigInteger of length ( b.length * 8 ) bits . The result is modulo 2^b.length in case of overflow ."
"fun findByThriftIdOrThrow(fieldId: Int): _Fields? { return findByThriftId(fieldId) ?: throw IllegalArgumentException(""Field $fieldId doesn't exist!"") }"	"Find the _Fields constant that matches fieldId , throwing an exception if it is not found ."
fun outerResource(@LayoutRes resource: Int): DividerAdapterBuilder { return outerView(asViewFactory(resource)) }	Sets the divider that appears before and after the wrapped adapters items .
fun ExecutionEntryImpl() { super() }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun logDiagnostic(msg: String) { if (isDiagnosticsEnabled()) { logRawDiagnostic(diagnosticPrefix + msg) } }	Output a diagnostic message to a user-specified destination ( if the user has enabled diagnostic logging ) .
"fun Code39Reader(usingCheckDigit: Boolean, extendedMode: Boolean) { this.usingCheckDigit = usingCheckDigit this.extendedMode = extendedMode }"	"Creates a reader that can be configured to check the last character as a check digit , or optionally attempt to decode `` extended Code 39 '' sequences that are used to encode the full ASCII character set ."
fun eStaticClass(): EClass? { return SexecPackage.Literals.UNSCHEDULE_TIME_EVENT }	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun insertIfAbsent(s: K?, v: V?) { this.arc.get(getPartition(s)).insertIfAbsent(s, v) }"	put a value to the cache if there was not an entry before do not return a previous content value
private fun Tokenizer(text: CharSequence) { this.text = text this.matcher = java.awt.font.GlyphMetrics.WHITESPACE.matcher(text) skipWhitespace() nextToken() }	Construct a tokenizer that parses tokens from the given text .
"private fun BucketAdvisor(bucket: Bucket, regionAdvisor: RegionAdvisor) { super(bucket) this.regionAdvisor = regionAdvisor this.pRegion = this.regionAdvisor.getPartitionedRegion() resetParentAdvisor(bucket.getId()) }"	Constructs a new BucketAdvisor for the Bucket owned by RegionAdvisor .
"fun prepareYLegend() { val yLegend = ArrayList<Float>() if (mRoundedYLegend) { val interval: Float = mDeltaY / (mYLegendCount - 1) val log10 = Math.log10(interval.toDouble()) var exp = Math.floor(log10).toInt() if (exp < 0) { exp = 0 } val tenPowExp: Double = POW_10.get(exp + 5) var multi = Math.round(interval / tenPowExp).toDouble() if (multi >= 1) { if (multi > 2 && multi <= 3) { multi = 3.0 } else if (multi > 3 && multi <= 5) { multi = 5.0 } else if (multi > 5 && multi < 10) { multi = 10.0 } } else { multi = 1.0 } val step = (multi * tenPowExp).toFloat() log("" log10 is $log10 interval is $interval mDeltaY is $mDeltaY tenPowExp is $tenPowExp multi is $multi mYChartMin is $mYChartMin step is $step"") var `val` = 0f if (step >= 1f) { `val` = (mYChartMin / step) as Int * step } else { `val` = mYChartMin } while (`val` <= mDeltaY + step + mYChartMin) { yLegend.add(`val`) `val` = `val` + step } if (step >= 1f) { mYChartMin = (mYChartMin / step) as Int * step log(""mYChartMin write --- step >= 1f -- and mYChartMin is $mYChartMin"") } mDeltaY = `val` - step - mYChartMin mYChartMax = yLegend[yLegend.size() - 1] } else { val interval: Float = mDeltaY / (mYLegendCount - 1) yLegend.add(mYChartMin) var i = 1 if (!isDrawOutline) { i = 0 } while (i < mYLegendCount - 1) { yLegend.add(mYChartMin + i.toFloat() * interval) i++ } yLegend.add(mDeltaY + mYChartMin) } mYLegend = yLegend.toArray(arrayOfNulls<Float>(0)) }"	setup the Y legend
"private fun displayHeaders(headers: List<AdsenseReportsGenerateResponse.Headers>) { for (header in headers) { System.out.printf(""%25s"", header.getName()) } println() }"	Displays the headers for the report .
"fun initData() { var classLoader: ClassLoader? = this.getClassLoader() if (classLoader != null) { val t1: TextView = this.createdView() t1.text = ""[onCreate] classLoader "" + ++i + "" : "" + classLoader.toString() this.classLoaderRootLayout.addView(t1) while (classLoader!!.parent != null) { classLoader = classLoader.parent val t2: TextView = this.createdView() t2.text = ""[onCreate] classLoader "" + ++i + "" : "" + classLoader.toString() this.classLoaderRootLayout.addView(t2) } } }"	Initialize the Activity data
"fun toType(value: String?, pattern: String?, locale: Locale?): Any? { val calendar: Calendar = toCalendar(value, pattern, locale) return toType(calendar) }"	Parse a String value to the required type
"fun toggleSong(songId: Long?, songName: String?, albumName: String?, artistName: String?) { if (getSongId(songId) == null) { addSongId(songId, songName, albumName, artistName) } else { removeItem(songId) } }"	Toggle the current song as favorite
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:55:07.260 -0500"", hash_original_method = ""03611E3BB30258B8EC4FDC9F783CBCCF"", hash_generated_method = ""75EED4D564C6A1FA0F492FBBD941CE61"" ) fun createRouteHeader(address: Address?): RouteHeader? { if (address == null) throw NullPointerException(""null address arg"") val route = Route() route.setAddress(address) return route }"	Creates a new RouteHeader based on the newly supplied address value .
"@Throws(Exception::class) fun NominalItem(att: Attribute, valueIndex: Int) { super(att) if (att.isNumeric()) { throw Exception(""NominalItem must be constructed using a nominal attribute"") } m_attribute = att if (m_attribute.numValues() === 1) { m_valueIndex = 0 } else { m_valueIndex = valueIndex } }"	Constructs a new NominalItem .
"fun inferType(tuples: TupleSet, field: String): Class<*>? { return if (tuples is Table) { (tuples as Table).getColumnType(field) } else { var type: Class<*>? = null var type2: Class<*>? = null val iter: Iterator<*> = tuples.tuples() while (iter.hasNext()) { val t: Tuple = iter.next() as Tuple if (type == null) { type = t.getColumnType(field) } else if (type != t.getColumnType(field).also { type2 = it }) { if (type2!!.isAssignableFrom(type)) { type = type2 } else require(type.isAssignableFrom(type2)) { ""The data field [$field] does not have a consistent type across provided Tuples"" } } } type } }"	Infer the data field type across all tuples in a TupleSet .
"private fun exactMinMax(relation: Relation<O>, distFunc: DistanceQuery<O>): DoubleMinMax? { val progress: FiniteProgress? = if (LOG.isVerbose()) FiniteProgress( ""Exact fitting distance computations"", relation.size(), LOG ) else null val minmax = DoubleMinMax() val iditer: DBIDIter = relation.iterDBIDs() while (iditer.valid()) { val iditer2: DBIDIter = relation.iterDBIDs() while (iditer2.valid()) { if (DBIDUtil.equal(iditer, iditer2)) { iditer2.advance() continue } val d: Double = distFunc.distance(iditer, iditer2) minmax.put(d) iditer2.advance() } LOG.incrementProcessed(progress) iditer.advance() } LOG.ensureCompleted(progress) return minmax }"	Compute the exact maximum and minimum .
"fun testDoubleValueMinusZero() { val a = ""-123809648392384754573567356745735.63567890295784902768787678287E-400"" val aNumber = BigDecimal(a) val minusZero = (-9223372036854775808L).toLong() val result: Double = aNumber.doubleValue() assertTrue(""incorrect value"", java.lang.Double.doubleToLongBits(result) == minusZero) }"	Double value of a small negative BigDecimal
"fun SeaGlassContext(component: JComponent?, region: Region?, style: SynthStyle?, state: Int) { super(component, region, style, state) if (component === fakeComponent) { this.component = null this.region = null this.style = null return } if (component == null || region == null || style == null) { throw NullPointerException(""You must supply a non-null component, region and style"") } reset(component, region, style, state) }"	"Creates a SeaGlassContext with the specified values . This is meant for subclasses and custom UI implementors . You very rarely need to construct a SeaGlassContext , though some methods will take one ."
"fun same( tags1: ArrayList<LinkedHashMap<String?, String?>>, tags2: ArrayList<LinkedHashMap<String?, String?>?> ): Boolean { if (tags1.size() !== tags2.size()) { return false } for (i in 0 until tags1.size()) { if (!tags1[i].equals(tags2[i])) { return false } } return true }"	Check if two lists of tags are the same Note : this considers order relevant
"fun copy(): TemplateEffect? { return TemplateEffect(labelTemplate, valueTemplate, attr.priority, exclusive, negated) }"	Returns a copy of the effect .
fun RegionMBeanBridge(cachePerfStats: CachePerfStats) { this.regionStats = cachePerfStats this.regionMonitor = MBeanStatsMonitor(ManagementStrings.REGION_MONITOR.toLocalizedString()) regionMonitor.addStatisticsToMonitor(cachePerfStats.getStats()) configureRegionMetrics() }	Statistic related Methods
fun Set(cl: Class<*>) { OptionInstance = false PlugInObject = cl ObjectName = (PlugInObject as Class<*>).simpleName ObjectName = Convert(ObjectName) }	Defines the stored object as a class .
"@Throws(IOException::class) fun include(ctx: DefaultFaceletContext, parent: UIComponent?, url: URL?) { val f: DefaultFacelet = this.factory.getFacelet(ctx.getFacesContext(), url) as DefaultFacelet f.include(ctx, parent) }"	Grabs a DefaultFacelet from referenced DefaultFaceletFacotry
"@DSComment(""From safe class list"") @DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:56:30.241 -0500"", hash_original_method = ""6B85F90491881D2C299E5BF02CCF5806"", hash_generated_method = ""82489B93E2C39EE14F117933CF49B12C"" ) fun toHexString(v: Long): String? { return IntegralToString.longToHexString(v) }"	Converts the specified long value into its hexadecimal string representation . The returned string is a concatenation of characters from ' 0 ' to ' 9 ' and ' a ' to ' f ' .
"private fun initializeProgressView(inflater: LayoutInflater, actionArea: ViewGroup) { if (mCard.mCardProgress != null) { val progressView: View = inflater.inflate(R.layout.card_progress, actionArea, false) val progressBar = progressView.findViewById(R.id.card_progress) as ProgressBar (progressView.findViewById(R.id.card_progress_text) as TextView).setText(mCard.mCardProgress.label) progressBar.max = mCard.mCardProgress.maxValue progressBar.progress = 0 mCard.mCardProgress.progressView = progressView mCard.mCardProgress.setProgressType(mCard.getProgressType()) actionArea.addView(progressView) } }"	Build the progress view into the given ViewGroup .
@Synchronized fun resetReaders() { readers = null }	"Resets a to-many relationship , making the next get call to query for a fresh result ."
"fun register(containerFactory: ContainerFactory) { containerFactory.registerContainer( ""wildfly8x"", ContainerType.INSTALLED, WildFly8xInstalledLocalContainer::class.java ) containerFactory.registerContainer( ""wildfly8x"", ContainerType.REMOTE, WildFly8xRemoteContainer::class.java ) containerFactory.registerContainer( ""wildfly9x"", ContainerType.INSTALLED, WildFly9xInstalledLocalContainer::class.java ) containerFactory.registerContainer( ""wildfly9x"", ContainerType.REMOTE, WildFly9xRemoteContainer::class.java ) containerFactory.registerContainer( ""wildfly10x"", ContainerType.INSTALLED, WildFly10xInstalledLocalContainer::class.java ) containerFactory.registerContainer( ""wildfly10x"", ContainerType.REMOTE, WildFly10xRemoteContainer::class.java ) }"	Register container .
"public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64Data = encoded . toCharArray ( ) ; int len = removeWhiteSpace ( base64Data ) ; if ( len % FOURBYTE != 0 ) { return null ; } int numberQuadruple = ( len / FOURBYTE ) ; if ( numberQuadruple == 0 ) { return new byte [ 0 ] ; } byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 ; char d1 = 0 , d2 = 0 , d3 = 0 , d4 = 0 ; int i = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; decodedData = new byte [ ( numberQuadruple ) * 3 ] ; for ( ; i < numberQuadruple - 1 ; i ++ ) { if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d3 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d4 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << 6 | b4 ) ; } if ( ! isData ( ( d1 = base64Data [ dataIndex ++ ] ) ) || ! isData ( ( d2 = base64Data [ dataIndex ++ ] ) ) ) { return null ; } b1 = base64Alphabet [ d1 ] ; b2 = base64Alphabet [ d2 ] ; d3 = base64Data [ dataIndex ++ ] ; d4 = base64Data [ dataIndex ++ ] ; if ( ! isData ( ( d3 ) ) || ! isData ( ( d4 ) ) ) { if ( isPad ( d3 ) && isPad ( d4 ) ) { if ( ( b2 & 0xf ) != 0 ) { return null ; } byte [ ] tmp = new byte [ i * 3 + 1 ] ; System . arraycopy ( decodedData , 0 , tmp , 0 , i * 3 ) ; tmp [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; return tmp ; } else if ( ! isPad ( d3 ) && isPad ( d4 ) ) { b3 = base64Alphabet [ d3 ] ; if ( ( b3 & 0x3 ) != 0 ) { return null ; } byte [ ] tmp = new byte [ i * 3 + 2 ] ; System . arraycopy ( decodedData , 0 , tmp , 0 , i * 3 ) ; tmp [ encodedIndex ++ ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; tmp [ encodedIndex ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; return tmp ; } else { return null ; } } else { b3 = base64Alphabet [ d3 ] ; b4 = base64Alphabet [ d4 ] ; decodedData [ encodedIndex ++ ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex ++ ] = ( byte ) ( b3 << 6 | b4 ) ; } return decodedData ; }"	Decodes Base64 data into octects
"@DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:55:34.017 -0500"", hash_original_method = ""647E85AB615972325C277E376A221EF0"", hash_generated_method = ""9835D90D4E0E7CCFFD07C436051E80EB"" ) fun hasIsdnSubaddress(): Boolean { return hasParm(ISUB) }"	return true if the isdn subaddress exists .
private fun tryScrollBackToTopWhileLoading() { tryScrollBackToTop() }	just make easier to understand
"private fun extractVariables(variablesBody: String): Map<String, String?>? { val map: Map<String, String> = HashMap() val m: Matcher = PATTERN_VARIABLES_BODY.matcher(variablesBody) LOG.debug(""parsing variables body"") while (m.find()) { val key: String = m.group(1) val value: String = m.group(2) if (map.containsKey(key)) { LOG.warn(""A duplicate variable name found with name: {} and value: {}."", key, value) } map.put(key, value) } return map }"	Extract variables map from variables body .
fun hashCode(): Int { val fh = if (first == null) 0 else first.hashCode() val sh = if (second == null) 0 else second.hashCode() return fh shl 16 or (sh and 0xFFFF) }	"Returns this Pair 's hash code , of which the 16 high bits are the 16 low bits of < tt > getFirst ( ) .hashCode ( ) < /tt > are identical to the 16 low bits and the 16 low bits of < tt > getSecond ( ) .hashCode ( ) < /tt >"
"@Throws(Exception::class) private fun CallStaticVoidMethod(env: JNIEnvironment, classJREF: Int, methodID: Int) { if (VM.VerifyAssertions) { VM._assert(VM.BuildForPowerPC, ERROR_MSG_WRONG_IMPLEMENTATION) } if (traceJNI) VM.sysWrite(""JNI called: CallStaticVoidMethod \n"") RuntimeEntrypoints.checkJNICountDownToGC() try { JNIHelpers.invokeWithDotDotVarArg(methodID, TypeReference.Void) } catch (unexpected: Throwable) { if (traceJNI) unexpected.printStackTrace(System.err) env.recordException(unexpected) } }"	"CallStaticVoidMethod : invoke a static method that returns void arguments passed using the vararg ... style NOTE : the vararg 's are not visible in the method signature here ; they are saved in the caller frame and the glue frame < p > < strong > NOTE : This implementation is NOT used for IA32 . On IA32 , it is overwritten with a C implementation in the bootloader when the VM starts. < /strong >"
fun visitInterface(): jdk.internal.org.objectweb.asm.signature.SignatureVisitor? { return this }	Visits the type of an interface implemented by the class .
"fun intersect(line: javax.sound.sampled.Line?): Vec4? { val intersection: Intersection? = intersect(line, this.a, this.b, this.c) return if (intersection != null) intersection.getIntersectionPoint() else null }"	Determine the intersection of the triangle with a specified line .
"fun lostOwnership( clipboard: java.awt.datatransfer.Clipboard?, contents: java.awt.datatransfer.Transferable? ) { }"	Notifies this object that it is no longer the owner of the contents of the clipboard .
"fun testExample() { Locale.setDefault(Locale(""en"", ""UK"")) doTestExample(""fr"", ""CH"", arrayOf(""_fr_CH.class"", ""_fr.properties"", "".class"")) doTestExample(""fr"", ""FR"", arrayOf(""_fr.properties"", "".class"")) doTestExample(""de"", ""DE"", arrayOf(""_en.properties"", "".class"")) doTestExample(""en"", ""US"", arrayOf(""_en.properties"", "".class"")) doTestExample(""es"", ""ES"", arrayOf(""_es_ES.class"", "".class"")) }"	Verifies the example from the getBundle specification .
"fun PubSubManager(connection: Connection, toAddress: String) { con = connection to = toAddress }"	Create a pubsub manager associated to the specified connection where the pubsub requests require a specific to address for packets .
"fun discoverOnAllPorts() { log.info(""Sending LLDP packets out of all the enabled ports"") for (sw in switchService.getAllSwitchDpids()) { val iofSwitch: IOFSwitch = switchService.getSwitch(sw) ?: continue if (!iofSwitch.isActive()) continue val c: Collection<OFPort> = iofSwitch.getEnabledPortNumbers() if (c != null) { for (ofp in c) { if (isLinkDiscoverySuppressed(sw, ofp)) { continue } log.trace(""Enabled port: {}"", ofp) sendDiscoveryMessage(sw, ofp, true, false) val npt = NodePortTuple(sw, ofp) addToMaintenanceQueue(npt) } } } }"	Send LLDPs to all switch-ports
"fun parseQuerystring(queryString: String?): Map<String, String>? { val map: MutableMap<String, String> = HashMap() if (queryString == null || queryString == """") { return map } val params = queryString.split(""&"".toRegex()).dropLastWhile { it.isEmpty() } .toTypedArray() for (param in params) { try { val keyValuePair = param.split(""="".toRegex(), limit = 2).toTypedArray() val name: String = URLDecoder.decode(keyValuePair[0], ""UTF-8"") if (name === """") { continue } val value = if (keyValuePair.size > 1) URLDecoder.decode(keyValuePair[1], ""UTF-8"") else """" map[name] = value } catch (e: UnsupportedEncodingException) { } } return map }"	Parse a querystring into a map of key/value pairs .
fun isDiscardVisible(): Boolean { return m_ButtonDiscard.isVisible() }	Returns the visibility of the discard button .
"private fun editNote(noteId: Int) { hideSoftKeyboard() val intent = Intent(this@MainActivity, NoteActivity::class.java) intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TASK intent.putExtra(""id"", noteId.toString()) startActivity(intent) }"	Method used to enter note edition mode
"private fun createLeftSide(): javax.swing.JPanel? { val leftPanel: javax.swing.JPanel = javax.swing.JPanel() listModel = CustomListModel() leftPanel.setLayout(java.awt.BorderLayout()) listBox = javax.swing.JList<String>(listModel) listBox.setCellRenderer(JlistRenderer()) listBox.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION) listBox.addListSelectionListener(CustomListSelectionListener()) val scrollPane: javax.swing.JScrollPane = javax.swing.JScrollPane(listBox) scrollPane.setBorder(javax.swing.BorderFactory.createEmptyBorder()) leftPanel.add(scrollPane, java.awt.BorderLayout.CENTER) scrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(""Dialogue states:"")) val controlPanel: javax.swing.JPanel = createControlPanel() leftPanel.add(controlPanel, java.awt.BorderLayout.SOUTH) return leftPanel }"	Creates the panel on the left side of the window
"fun insertAt(dest: FloatArray, src: FloatArray, offset: Int): FloatArray? { val temp = FloatArray(dest.size + src.size - 1) System.arraycopy(dest, 0, temp, 0, offset) System.arraycopy(src, 0, temp, offset, src.size) System.arraycopy(dest, offset + 1, temp, src.size + offset, dest.size - offset - 1) return temp }"	Inserts one array into another by replacing specified offset .
fun removeFailListener() { this.failedListener = null }	"Unregister fail listener , initialised by Builder # failListener"
"private fun fieldsForOtherResourceSpecified( includedFields: TypedParams<IncludedFieldsParams>?, typeIncludedFields: IncludedFieldsParams ): Boolean { return includedFields != null && !includedFields.getParams() .isEmpty() && noResourceIncludedFieldsSpecified(typeIncludedFields) }"	Checks if fields for other resource has been specified but not for the processed one
fun resolveReference(ref: MemberRef?): IBinding? { return null }	Resolves the given reference and returns the binding for it . < p > The implementation of < code > MemberRef.resolveBinding < /code > forwards to this method . How the name resolves is often a function of the context in which the name node is embedded as well as the name itself . < /p > < p > The default implementation of this method returns < code > null < /code > . Subclasses may reimplement . < /p >
"@Scheduled(fixedRate = FIXED_RATE) fun logStatistics() { if (beansAvailable) { if (log.isInfoEnabled()) { logOperatingSystemStatistics() logRuntimeStatistics() logMemoryStatistics() logThreadStatistics() log.info(""\n"") } } if (log.isInfoEnabled()) { logDroppedData() logBufferStatistics() logStorageStatistics() } }"	Log all the statistics .
"@HLEFunction(nid = -0x6cbbf4ef, version = 150) fun sceWlanDevIsPowerOn(): Int { return Wlan.getSwitchState() }"	Determine if the wlan device is currently powered on
"@Throws(IOException::class) fun readTransformMetaDataFromFile(spec: String?, metapath: String?): FrameBlock? { return readTransformMetaDataFromFile(spec, metapath, TfUtils.TXMTD_SEP) }"	"Reads transform meta data from an HDFS file path and converts it into an in-memory FrameBlock object . The column names in the meta data file 'column.names ' is processed with default separator ' , ' ."
"fun toString(codeset: String?): String { val retVal = StringBuffer() for (i in 0 until prolog.size()) { val e: ConcreteElement = prolog.elementAt(i) as ConcreteElement retVal.append(e.toString(getCodeset()) + ""\n"") } if (content != null) retVal.append(content.toString(getCodeset()) + ""\n"") return versionDecl + retVal.toString() }"	Override toString so it prints something useful
fun isCompound(): Boolean { return splits.size() !== 1 }	Checks if this instance is a compounding word .
fun hasAnnotation(annotation: Annotation?): Boolean { return annotationAccessor.typeHas(annotation) }	Determines whether T has a particular annotation .
fun create(): Builder? { return Builder(false) }	Constructs an asynchronous query task .
"@Throws(IOException::class) fun MP4Reader(fis: FileInputStream?) { if (null == fis) { log.warn(""Reader was passed a null file"") log.debug(""{}"", ToStringBuilder.reflectionToString(this)) } this.fis = MP4DataStream(fis) channel = fis.getChannel() decodeHeader() analyzeFrames() firstTags.add(createFileMeta()) createPreStreamingTags(0, false) }"	"Creates MP4 reader from file input stream , sets up metadata generation flag ."
@Strictfp fun plusPIO2_strict(angRad: Double): Double { return if (angRad > -Math.PI / 4) { angRad + PIO2_LO + PIO2_HI } else { angRad + PIO2_HI + PIO2_LO } }	Strict version .
@Synchronized private fun isSelectedTrackRecording(): Boolean { return trackDataHub != null && trackDataHub.isSelectedTrackRecording() }	Returns true if the selected track is recording . Needs to be synchronized because trackDataHub can be accessed by multiple threads .
"fun loadIcon(suggestion: ApplicationSuggestion): Drawable? { return try { val `is`: InputStream = mContext.getContentResolver().openInputStream(suggestion.getThumbailUri()) Drawable.createFromStream(`is`, null) } catch (e: FileNotFoundException) { null } }"	Loads the icon for the given suggestion .
fun isHead(): Boolean { return if (parent == null) true else false }	Returns true if this node is the head of its DominatorTree .
"fun ofMethod(returnType: CtClass?, paramTypes: Array<CtClass?>?): String? { val desc = StringBuffer() desc.append('(') if (paramTypes != null) { val n = paramTypes.size for (i in 0 until n) toDescriptor(desc, paramTypes[i]) } desc.append(')') if (returnType != null) toDescriptor(desc, returnType) return desc.toString() }"	Returns the descriptor representing a method that receives the given parameter types and returns the given type .
"fun eGet(featureID: Int, resolve: Boolean, coreType: Boolean): Any? { when (featureID) { UmplePackage.GEN_EXPR___NAME_1 -> return getName_1() UmplePackage.GEN_EXPR___ANONYMOUS_GEN_EXPR_11 -> return getAnonymous_genExpr_1_1() UmplePackage.GEN_EXPR___EQUALITY_OP_1 -> return getEqualityOp_1() UmplePackage.GEN_EXPR___NAME_2 -> return getName_2() UmplePackage.GEN_EXPR___ANONYMOUS_GEN_EXPR_21 -> return getAnonymous_genExpr_2_1() } return super.eGet(featureID, resolve, coreType) }"	< ! -- begin-user-doc -- > < ! -- end-user-doc -- >
fun Main() {}	Creates a new instance of Main
"fun serializeFile(path: String?, o: Any) { try { val context: JAXBContext = JAXBContext.newInstance(o.javaClass) val m: Marshaller = context.createMarshaller() m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE) val stream = FileOutputStream(path) m.marshal(o, stream) } catch (e: JAXBException) { e.printStackTrace() } catch (e: FileNotFoundException) { e.printStackTrace() } }"	"Serializes an object and saves it to a file , located at given path ."
"fun min(expression: Expression?): MinProjectionExpression? { return MinProjectionExpression(expression, false) }"	Minimum aggregation function .
fun onUIReset(frame: PtrFrameLayout?) { mScale = 1f mDrawable.stop() }	"When the content view has reached top and refresh has been completed , view will be reset ."
fun forgetInstruction(ins: BytecodeInstruction): Boolean { if (!instructionMap.containsKey(ins.getClassName())) return false return if (!instructionMap.get(ins.getClassName()) .containsKey(ins.getMethodName()) ) false else instructionMap.get(ins.getClassName()).get(ins.getMethodName()).remove(ins) }	< p > forgetInstruction < /p >
"@Throws(IOException::class) fun watchRecursive(path: Path?): Observable<WatchEvent<*>?>? { val recursive = true return ObservableFactory(path, recursive).create() }"	"Creates an observable that watches the given directory and all its subdirectories . Directories that are created after subscription are watched , too ."
"fun invertMatrix(matrix: Matrix3?): Matrix3? { if (matrix == null) { throw IllegalArgumentException( Logger.logMessage( Logger.ERROR, ""Matrix3"", ""invertMatrix"", ""missingMatrix"" ) ) } throw UnsupportedOperationException(""Matrix3.invertMatrix is not implemented"") }"	Inverts the specified matrix and stores the result in this matrix . < p/ > This throws an exception if the matrix is singular . < p/ > The result of this method is undefined if this matrix is passed in as the matrix to invert .
"fun sync(context: Context) { val cr: ContentResolver = cr() val proj = arrayOf<String>(_ID, Syncs.TYPE_ID, Syncs.OBJECT_ID, millis(Syncs.ACTION_ON)) val sel: String = Syncs.STATUS_ID + "" = ?"" val args = arrayOf<String>(java.lang.String.valueOf(ACTIVE.id)) val order: String = Syncs.ACTION_ON + "" DESC"" val c = EasyCursor(cr.query(Syncs.CONTENT_URI, proj, sel, args, order)) val count: Int = c.getCount() if (count > 0) { var users = 0 var reviews = 0 var review: Review? = null val lines: Set<CharSequence> = LinkedHashSet() var `when` = 0L var icon: Bitmap? = null val syncIds: Set<String> = HashSet(count) while (c.moveToNext()) { var photo: Uri? = null when (Sync.Type.get(c.getInt(Syncs.TYPE_ID))) { USER -> { photo = user(context, cr, c.getLong(Syncs.OBJECT_ID), lines, icon) if (photo != null) { users++ syncIds.add(java.lang.String.valueOf(c.getLong(_ID))) } } REVIEW -> { val (first, second) = review( context, cr, c.getLong(Syncs.OBJECT_ID), lines, icon ) photo = first if (second != null) { reviews++ syncIds.add(java.lang.String.valueOf(c.getLong(_ID))) if (review == null) { review = second } } } } if (`when` == 0L) { `when` = c.getLong(Syncs.ACTION_ON) } if (photo != null && photo !== EMPTY) { icon = photo(context, photo) } } val size: Int = lines.size() if (size > 0) { var bigText: CharSequence? = null var summary: CharSequence? = null val activity: Intent if (users > 0 && reviews == 0) { activity = Intent(context, FriendsActivity::class.java) } else if (users == 0 && (reviews == 1 || size == 1)) { bigText = ReviewAdapter.comments(review.comments) summary = context.getString(R.string.n_stars, review.rating) activity = Intent(context, RestaurantActivity::class.java).putExtra( EXTRA_ID, review.restaurantId ) if (review.type === GOOGLE) { activity.putExtra(EXTRA_TAB, TAB_PUBLIC) } } else { activity = Intent(context, NotificationsActivity::class.java) } notify(context, lines, bigText, summary, `when`, icon, users + reviews, activity) Prefs.putStringSet(context, APP, NEW_SYNC_IDS, syncIds) event(""notification"", ""notify"", ""sync"", size) } else { Managers.notification(context).cancel(TAG_SYNC, 0) context.startService(Intent(context, SyncsReadService::class.java)) } } c.close() }"	Post a notification for any unread server changes .
"fun serializableInstance(): LogisticRegressionRunner? { val variables: MutableList<Node> = LinkedList() val var1 = ContinuousVariable(""X"") val var2 = ContinuousVariable(""Y"") variables.add(var1) variables.add(var2) val dataSet: DataSet = ColtDataSet(3, variables) val col1data = doubleArrayOf(0.0, 1.0, 2.0) val col2data = doubleArrayOf(2.3, 4.3, 2.5) for (i in 0..2) { dataSet.setDouble(i, 0, col1data[i]) dataSet.setDouble(i, 1, col2data[i]) } val dataWrapper = DataWrapper(dataSet) return LogisticRegressionRunner(dataWrapper, Parameters()) }"	Generates a simple exemplar of this class to test serialization .
"fun ESHistory(documentId: String, events: Collection<HistoryEvent?>) { this.documentId = documentId this.events = events }"	New instance with the specified content .
"fun executeDelayedExpensiveWrite(task: Runnable?): Boolean { val f: Future<*> = executeDiskStoreTask(task, this.delayedWritePool) lastDelayedWrite = f return f != null }"	"Execute a task asynchronously , or in the calling thread if the bound is reached . This pool is used for write operations which can be delayed , but we have a limit on how many write operations we delay so that we do n't run out of disk space . Used for deletes , unpreblow , RAF close , etc ."
private fun resetMnemonics() { if (mnemonicToIndexMap != null) { mnemonicToIndexMap.clear() mnemonicInputMap.clear() } }	Resets the mnemonics bindings to an empty state .
fun textureMode(mode: Int) { g.textureMode(mode) }	Set texture mode to either to use coordinates based on the IMAGE ( more intuitive for new users ) or NORMALIZED ( better for advanced chaps )
"fun execute(params: Array<String?>?): GetETLDriverInfo? { return try { val commandLine: CommandLine = getCommandLine(params, PARAMS_STRUCTURE) val minBId: String = commandLine.getOptionValue(""min-batch-id"") LOGGER.debug(""minimum-batch-id is $minBId"") val maxBId: String = commandLine.getOptionValue(""max-batch-id"") LOGGER.debug(""maximum-batch-id is $maxBId"") val getETLDriverInfoList: List<GetETLDriverInfo> = getETLInfoDAO.getETLInfo(minBId.toLong(), maxBId.toLong()) LOGGER.info(""list of File is "" + getETLDriverInfoList[0].getFileList()) getETLDriverInfoList[0] } catch (e: Exception) { LOGGER.error(""Error occurred"", e) throw MetadataException(e) } }"	This method runs GetETLInfo proc and retrieves information regarding files available for batches mentioned .
fun FunctionblockFactoryImpl() { super() }	Creates an instance of the factory . < ! -- begin-user-doc -- > < ! -- end-user-doc -- >
"fun writePopulation(outputfolder: String) { var outputfolder = outputfolder outputfolder = outputfolder + if (outputfolder.endsWith(""/"")) """" else ""/"" if (sc.getPopulation().getPersons().size() === 0 || sc.getPopulation() .getPersonAttributes() == null ) { throw RuntimeException(""Either no persons or person attributes to write."") } else { LOG.info(""Writing population to file... ("" + sc.getPopulation().getPersons().size() + "")"") val pw = PopulationWriter(sc.getPopulation(), sc.getNetwork()) pw.writeV5(outputfolder + ""Population.xml"") LOG.info(""Writing person attributes to file..."") val oaw = ObjectAttributesXmlWriter(sc.getPopulation().getPersonAttributes()) oaw.putAttributeConverter(IncomeImpl::class.java, SAIncomeConverter()) oaw.setPrettyPrint(true) oaw.writeFile(outputfolder + ""PersonAttributes.xml"") } }"	Writes the population and their attributes to file .
"@Throws(LocalRepositoryException::class) fun restart(serviceName: String) { val prefix = ""restart(): serviceName=$serviceName "" _log.debug(prefix) val cmd = arrayOf(_SYSTOOL_CMD, _SYSTOOL_RESTART, serviceName) val result: Exec.Result = org.gradle.api.tasks.Exec.sudo(_SYSTOOL_TIMEOUT, cmd) checkFailure(result, prefix) }"	Restart a service
public void receiveResultqueryStorageProcessors ( com . emc . storageos . vasa . VasaServiceStub . QueryStorageProcessorsResponse result ) { }	auto generated Axis2 call back method for queryStorageProcessors method override this method for handling normal response from queryStorageProcessors operation
"public final void testNextBytesbyteArray02 ( ) { byte [ ] myBytes ; byte [ ] myBytes1 ; byte [ ] myBytes2 ; for ( int i = 1 ; i < LENGTH ; i += INCR ) { myBytes = new byte [ i ] ; for ( int j = 1 ; j < i ; j ++ ) { myBytes [ j ] = ( byte ) ( j & 0xFF ) ; } sr . setSeed ( myBytes ) ; sr2 . setSeed ( myBytes ) ; for ( int k = 1 ; k < LENGTH ; k += INCR ) { myBytes1 = new byte [ k ] ; myBytes2 = new byte [ k ] ; sr . nextBytes ( myBytes1 ) ; sr2 . nextBytes ( myBytes2 ) ; for ( int l = 0 ; l < k ; l ++ ) { assertFalse ( ""unexpected: myBytes1[l] != myBytes2[l] :: l=="" + l + "" k="" + k + "" i="" + i + "" myBytes1[l]="" + myBytes1 [ l ] + "" myBytes2[l]="" + myBytes2 [ l ] , myBytes1 [ l ] != myBytes2 [ l ] ) ; } } } for ( int n = 1 ; n < LENGTH ; n += INCR ) { int n1 = 10 ; int n2 = 20 ; int n3 = 100 ; byte [ ] [ ] bytes1 = new byte [ 10 ] [ n1 ] ; byte [ ] [ ] bytes2 = new byte [ 5 ] [ n2 ] ; for ( int k = 0 ; k < bytes1 . length ; k ++ ) { sr . nextBytes ( bytes1 [ k ] ) ; } for ( int k = 0 ; k < bytes2 . length ; k ++ ) { sr2 . nextBytes ( bytes2 [ k ] ) ; } for ( int k = 0 ; k < n3 ; k ++ ) { int i1 = k / n1 ; int i2 = k % n1 ; int i3 = k / n2 ; int i4 = k % n2 ; assertTrue ( ""non-equality: i1="" + i1 + "" i2="" + i2 + "" i3="" + i3 + "" i4="" + i4 , bytes1 [ i1 ] [ i2 ] == bytes2 [ i3 ] [ i4 ] ) ; } } }"	test against the `` void nextBytes ( byte [ ] ) '' method ; it checks out that different SecureRandom objects being supplied with the same seed return the same sequencies of bytes as results of their `` nextBytes ( byte [ ] ) '' methods
"@DSSafe(DSCat.SAFE_LIST) @DSGenerator( tool_name = ""Doppelganger"", tool_version = ""2.0"", generated_on = ""2013-12-30 12:29:27.931 -0500"", hash_original_method = ""92BE44E9F6280B7AE0D2A8904499350A"", hash_generated_method = ""5A68C897F2049F6754C8DA6E4CBD57CE"" ) fun translationXBy(value: Float): ViewPropertyAnimator? { animatePropertyBy(TRANSLATION_X, value) return this }"	This method will cause the View 's < code > translationX < /code > property to be animated by the specified value . Animations already running on the property will be canceled .
"private fun loadServerDetailsActivity() { Preference.putString(context, Constants.PreferenceFlag.IP, null) val intent = Intent(this@AlreadyRegisteredActivity, ServerDetails::class.java) intent.putExtra(getResources().getString(R.string.intent_extra_regid), regId) intent.putExtra( getResources().getString(R.string.intent_extra_from_activity), AlreadyRegisteredActivity::class.java.getSimpleName() ) intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) startActivity(intent) finish() }"	Load server details activity .
"fun createNamedGraph(model: Model, graphNameNode: Resource?, elements: RDFList?): NamedGraph? { val result: NamedGraph = model.createResource(SP.NamedGraph).`as`(NamedGraph::class.java) result.addProperty(SP.graphNameNode, graphNameNode) result.addProperty(SP.elements, elements) return result }"	Creates a new NamedGraph element as a blank node in a given Model .
"fun SQLWarning(reason: String?, SQLState: String?, vendorCode: Int, cause: Throwable?) { super(reason, SQLState, vendorCode, cause) }"	"Creates an SQLWarning object . The Reason string is set to reason , the SQLState string is set to given SQLState and the Error Code is set to vendorCode , cause is set to the given cause"
"@POST @Path(""downloads"") @ApiOperation(value = ""Starts downloading artifacts"", response = DownloadToken::class) @ApiResponses( value = [ApiResponse(code = 202, message = ""OK""), ApiResponse( code = 400, message = ""Illegal version format or artifact name"" ), ApiResponse(code = 409, message = ""Downloading already in progress""), ApiResponse( code = 500, message = ""Server error"" )] ) fun startDownload( @QueryParam(value = ""artifact"") @ApiParam( value = ""Artifact name"", allowableValues = CDECArtifact.NAME ) artifactName: String?, @QueryParam(value = ""version"") @ApiParam(value = ""Version number"") versionNumber: String? ): Response? { return try { val downloadToken = DownloadToken() downloadToken.setId(DOWNLOAD_TOKEN) val artifact: Artifact = createArtifactOrNull(artifactName) val version: Version = createVersionOrNull(versionNumber) facade.startDownload(artifact, version) Response.status(Response.Status.ACCEPTED).entity(downloadToken).build() } catch (e: ArtifactNotFoundException) { handleException(e, Response.Status.BAD_REQUEST) } catch (e: IllegalVersionException) { handleException(e, Response.Status.BAD_REQUEST) } catch (e: DownloadAlreadyStartedException) { handleException(e, Response.Status.CONFLICT) } catch (e: Exception) { handleException(e) } }"	Starts downloading artifacts .
"fun release() { this@PathLockFactory.release(path, permits) }"	Release file permit .
fun BuddyPanel(model: BuddyListModel?) { super(model) setCellRenderer(BuddyLabel()) setOpaque(false) this.setFocusable(false) this.addMouseListener(BuddyPanelMouseListener()) }	Create a new BuddyList .
fun createComponent(owner: Component?): Component? { return if (java.awt.GraphicsEnvironment.isHeadless()) { null } else HeavyWeightWindow(getParentWindow(owner)) }	"Creates the Component to use as the parent of the < code > Popup < /code > . The default implementation creates a < code > Window < /code > , subclasses should override ."
"fun UnknownResolverVariableException(i18n: String?, vararg arguments: Any?) { super(i18n, arguments) }"	Creates a parsing exception with message associated to the i18n and the arguments .
fun isEndNode(node: Node?): Boolean { return getDelegator().getCurrentStorage().isEndNode(node) }	Test if the given Node is an end node of a Way . Isolated nodes not part of a way are not considered an end node .
"fun hasDefClearPathToMethodExit(duVertex: Definition): Boolean { require(graph.containsVertex(duVertex)) { ""vertex not in graph"" } return if (duVertex.isLocalDU()) false else hasDefClearPathToMethodExit( duVertex, duVertex, HashSet<BytecodeInstruction>() ) }"	< p > hasDefClearPathToMethodExit < /p >
"private fun resetAndGetFollowElements( tokens: ObservableXtextTokenStream, strict: Boolean ): Collection<FollowElement?>? { val parser: CustomInternalN4JSParser = createParser() parser.setStrict(strict) tokens.reset() return doGetFollowElements(parser, tokens) }"	Create a fresh parser instance and process the tokens for a second pass .
"@Throws(IgniteException::class) private fun printInfo(fs: IgniteFileSystem, path: IgfsPath) { println() println(""Information for "" + path + "": "" + fs.info(path)) }"	Prints information for file or directory .
fun makeHashValue(currentMaxListSize: Int): List<BindingSet?>? { return ArrayList<BindingSet>(currentMaxListSize / 2 + 1) }	Utility methods to make it easier to inserted custom store dependent list
"fun cdf(`val`: Double, loc: Double, scale: Double): Double { var `val` = `val` `val` = (`val` - loc) / scale return 1.0 / (1.0 + Math.exp(-`val`)) }"	Cumulative density function .
"fun taskStateChanged(@TASK_STATE taskState: Int, tag: Serializable?) { when (taskState) { TASK_STATE_PREPARE -> { iView.layoutLoadingVisibility(isContentEmpty()) iView.layoutContentVisibility(!isContentEmpty()) iView.layoutEmptyVisibility(false) iView.layoutLoadFailedVisibility(false) } TASK_STATE_SUCCESS -> { iView.layoutLoadingVisibility(false) if (isContentEmpty()) { iView.layoutEmptyVisibility(true) } else { iView.layoutContentVisibility(true) } } TASK_STATE_FAILED -> { if (isContentEmpty()) { iView.layoutEmptyVisibility(false) iView.layoutLoadingVisibility(false) iView.layoutLoadFailedVisibility(true) if (tag != null) { iView.setTextLoadFailed(tag.toString()) } } } TASK_STATE_FINISH -> {} } }"	According to the task execution state to update the page display state .
"@Throws(javax.swing.text.BadLocationException::class) fun addLineTrackingIcon(line: Int, icon: Icon?): GutterIconInfo? { val offs: Int = textArea.getLineStartOffset(line) return addOffsetTrackingIcon(offs, icon) }"	"Adds an icon that tracks an offset in the document , and is displayed adjacent to the line numbers . This is useful for marking things such as source code errors ."
fun createVertex(point: Point?): SpatialSparseVertex? { if (point != null) point.setSRID(SRID) return SpatialSparseVertex(point) }	Creates a new vertex located at < tt > point < /tt > . The spatial reference id is the to the one of the factory 's coordinate reference system .
"private fun indentString(): String? { val sb = StringBuffer() for (i in 0 until indent) { sb.append("" "") } return sb.toString() }"	Indent child nodes to help visually identify the structure of the AST .
fun isProcessing(): Boolean { return isProcessing }	Returns whether XBL processing is currently enabled .
"@Throws(IOException::class) fun computeCodebase( name: String?, jarFile: String?, port: String, srcRoot: String?, mdAlgorithm: String? ): String? { return computeCodebase(name, jarFile, port.toInt(), srcRoot, mdAlgorithm) }"	Convenience method that ultimately calls the primary 5-argument version of this method . This method allows one to input a < code > String < /code > value for the port to use when constructing the codebase ; which can be useful when invoking this method from a Jini configuration file .
"private fun purgeRelayLogs(wait: Boolean) { if (relayLogRetention > 1) { logger.info(""Checking for old relay log files..."") val logDir = File(binlogDir) val filesToPurge: Array<File> = FileCommands.filesOverRetentionAndInactive( logDir, binlogFilePattern, relayLogRetention, this.binlogPosition.getFileName() ) if (this.relayLogQueue != null) { for (fileToPurge in filesToPurge) { if (logger.isInfoEnabled()) { logger.debug(""Removing relay log file from relay log queue: "" + fileToPurge.getAbsolutePath()) } if (!relayLogQueue.remove(fileToPurge)) { logger.info(""Unable to remove relay log file from relay log queue, probably old: $fileToPurge"") } } } FileCommands.deleteFiles(filesToPurge, wait) } }"	Purge old relay logs that have aged out past the number of retained files .
fun fromInteger(address: Int): Inet4Address? { return getInet4Address(Ints.toByteArray(address)) }	Returns an Inet4Address having the integer value specified by the argument .
"fun isOverwriteUser1(): Boolean { val oo: Any = get_Value(COLUMNNAME_OverwriteUser1) return if (oo != null) { if (oo is Boolean) oo.toBoolean() else ""Y"" == oo } else false }"	Get Overwrite User1 .
"private fun valEquals(o1: Any?, o2: Any?): Boolean { return if (o1 == null) o2 == null else o1 == o2 }"	Test two values for equality . Differs from o1.equals ( o2 ) only in that it copes with with < tt > null < /tt > o1 properly .
"fun hasAttribute(name: String?): Boolean { return DTM.NULL !== dtm.getAttributeNode(node, null, name) }"	Method hasAttribute
"fun init() { Environment.init(this) Debug.init( this, arrayOf(""debug.basic"", ""debug.cspec"", ""debug.layer"", ""debug.mapbean"", ""debug.plugin"") ) val propValue: String = getParameter(PropertiesProperty) var propHandler: PropertyHandler? = null try { if (propValue != null) { val builder: PropertyHandler.Builder = Builder().setPropertiesFile(propValue) propHandler = PropertyHandler(builder) if (Debug.debugging(""app"")) { Debug.output(""OpenMapApplet: Using properties from $propValue"") } } } catch (murle: MalformedURLException) { Debug.error(""OpenMap: property file specified: $propValue doesn't exist, searching for default openmap.properties file..."") } catch (ioe: IOException) { Debug.error(""OpenMap: There is a problem using the property file specified: $propValue, searching for default openmap.properties file..."") } if (propHandler == null) { propHandler = PropertyHandler() } val mapPanel: MapPanel = BasicMapPanel(propHandler) mapPanel.getMapHandler().add(this) Debug.message(""app"", ""OpenMapApplet.init()"") }"	Called by the browser or applet viewer to inform this applet that it has been loaded into the system . It is always called before the first time that the < code > start < /code > method is called . < p > The implementation of this method provided by the < code > Applet < /code > class does nothing .
"@Throws(IOException::class) fun process(rb: ResponseBuilder) { val req: SolrQueryRequest = rb.req val rsp: SolrQueryResponse = rb.rsp val params: SolrParams = req.getParams() if (!params.getBool(COMPONENT_NAME, true)) { return } val searcher: SolrIndexSearcher = req.getSearcher() if (rb.getQueryCommand().getOffset() < 0) { throw SolrException( SolrException.ErrorCode.BAD_REQUEST, ""'start' parameter cannot be negative"" ) } val timeAllowed = params.getInt(CommonParams.TIME_ALLOWED, -1) as Long if (null != rb.getCursorMark() && 0 < timeAllowed) { throw SolrException( SolrException.ErrorCode.BAD_REQUEST, ""Can not search using both "" + CursorMarkParams.CURSOR_MARK_PARAM + "" and "" + CommonParams.TIME_ALLOWED ) } val ids: String = params.get(ShardParams.IDS) if (ids != null) { val idField: SchemaField = searcher.getSchema().getUniqueKeyField() val idArr: List<String> = StrUtils.splitSmart(ids, "","", true) val luceneIds = IntArray(idArr.size) var docs = 0 for (i in idArr.indices) { val id: Int = req.getSearcher().getFirstMatch( Term( idField.getName(), idField.getType().toInternal( idArr[i] ) ) ) if (id >= 0) luceneIds[docs++] = id } val res = DocListAndSet() res.docList = DocSlice(0, docs, luceneIds, null, docs, 0) if (rb.isNeedDocSet()) { val queries: MutableList<Query> = ArrayList() queries.add(rb.getQuery()) val filters: List<Query> = rb.getFilters() if (filters != null) queries.addAll(filters) res.docSet = searcher.getDocSet(queries) } rb.setResults(res) val ctx = ResultContext() ctx.docs = rb.getResults().docList ctx.query = null rsp.add(""response"", ctx) return } val cmd: SolrIndexSearcher.QueryCommand = rb.getQueryCommand() cmd.setTimeAllowed(timeAllowed) val result: SolrIndexSearcher.QueryResult = QueryResult() val groupingSpec: GroupingSpecification = rb.getGroupingSpec() if (groupingSpec != null) { try { val needScores = cmd.getFlags() and SolrIndexSearcher.GET_SCORES !== 0 if (params.getBool(GroupParams.GROUP_DISTRIBUTED_FIRST, false)) { val topsGroupsActionBuilder: CommandHandler.Builder = Builder().setQueryCommand(cmd).setNeedDocSet(false).setIncludeHitCount(true) .setSearcher(searcher) for (field in groupingSpec.getFields()) { topsGroupsActionBuilder.addCommandField( Builder().setField( searcher.getSchema().getField(field) ).setGroupSort(groupingSpec.getGroupSort()) .setTopNGroups(cmd.getOffset() + cmd.getLen()) .setIncludeGroupCount(groupingSpec.isIncludeGroupCount()).build() ) } val commandHandler: CommandHandler = topsGroupsActionBuilder.build() commandHandler.execute() val serializer = SearchGroupsResultTransformer(searcher) rsp.add(""firstPhase"", commandHandler.processResult(result, serializer)) rsp.add(""totalHitCount"", commandHandler.getTotalHitCount()) rb.setResult(result) return } else if (params.getBool(GroupParams.GROUP_DISTRIBUTED_SECOND, false)) { val secondPhaseBuilder: CommandHandler.Builder = Builder().setQueryCommand(cmd) .setTruncateGroups(groupingSpec.isTruncateGroups() && groupingSpec.getFields().length > 0) .setSearcher(searcher) for (field in groupingSpec.getFields()) { var topGroupsParam: Array<String?> = params.getParams(GroupParams.GROUP_DISTRIBUTED_TOPGROUPS_PREFIX + field) if (topGroupsParam == null) { topGroupsParam = arrayOfNulls(0) } val topGroups: MutableList<SearchGroup<BytesRef>> = ArrayList(topGroupsParam.size) for (topGroup in topGroupsParam) { val searchGroup: SearchGroup<BytesRef> = SearchGroup() if (topGroup != TopGroupsShardRequestFactory.GROUP_NULL_VALUE) { searchGroup.groupValue = BytesRef( searcher.getSchema().getField(field).getType() .readableToIndexed(topGroup) ) } topGroups.add(searchGroup) } secondPhaseBuilder.addCommandField( Builder().setField( searcher.getSchema().getField(field) ).setGroupSort(groupingSpec.getGroupSort()) .setSortWithinGroup(groupingSpec.getSortWithinGroup()) .setFirstPhaseGroups(topGroups) .setMaxDocPerGroup(groupingSpec.getGroupOffset() + groupingSpec.getGroupLimit()) .setNeedScores(needScores).setNeedMaxScore(needScores).build() ) } for (query in groupingSpec.getQueries()) { secondPhaseBuilder.addCommandField( Builder().setDocsToCollect(groupingSpec.getOffset() + groupingSpec.getLimit()) .setSort(groupingSpec.getGroupSort()).setQuery(query, rb.req) .setDocSet(searcher).build() ) } val commandHandler: CommandHandler = secondPhaseBuilder.build() commandHandler.execute() val serializer = TopGroupsResultTransformer(rb) rsp.add(""secondPhase"", commandHandler.processResult(result, serializer)) rb.setResult(result) return } val maxDocsPercentageToCache: Int = params.getInt(GroupParams.GROUP_CACHE_PERCENTAGE, 0) val cacheSecondPassSearch = maxDocsPercentageToCache >= 1 && maxDocsPercentageToCache <= 100 val defaultTotalCount: Grouping.TotalCount = if (groupingSpec.isIncludeGroupCount()) TotalCount.grouped else TotalCount.ungrouped val limitDefault: Int = cmd.getLen() val grouping: Grouping<*, *> = Grouping<Any?, Any?>( searcher, result, cmd, cacheSecondPassSearch, maxDocsPercentageToCache, groupingSpec.isMain() ) grouping.setSort(groupingSpec.getGroupSort()) .setGroupSort(groupingSpec.getSortWithinGroup()) .setDefaultFormat(groupingSpec.getResponseFormat()).setLimitDefault(limitDefault) .setDefaultTotalCount(defaultTotalCount) .setDocsPerGroupDefault(groupingSpec.getGroupLimit()) .setGroupOffsetDefault(groupingSpec.getGroupOffset()) .setGetGroupedDocSet(groupingSpec.isTruncateGroups()) if (groupingSpec.getFields() != null) { for (field in groupingSpec.getFields()) { grouping.addFieldCommand(field, rb.req) } } if (groupingSpec.getFunctions() != null) { for (groupByStr in groupingSpec.getFunctions()) { grouping.addFunctionCommand(groupByStr, rb.req) } } if (groupingSpec.getQueries() != null) { for (groupByStr in groupingSpec.getQueries()) { grouping.addQueryCommand(groupByStr, rb.req) } } if (rb.doHighlights || rb.isDebug() || params.getBool(MoreLikeThisParams.MLT, false)) { cmd.setFlags(SolrIndexSearcher.GET_DOCLIST) } grouping.execute() if (grouping.isSignalCacheWarning()) { rsp.add( ""cacheWarning"", java.lang.String.format( Locale.ROOT, ""Cache limit of %d percent relative to maxdoc has exceeded. Please increase cache size or disable caching."", maxDocsPercentageToCache ) ) } rb.setResult(result) if (grouping.mainResult != null) { val ctx = ResultContext() ctx.docs = grouping.mainResult ctx.query = null rsp.add(""response"", ctx) rsp.getToLog().add(""hits"", grouping.mainResult.matches()) } else if (!grouping.getCommands().isEmpty()) { rsp.add(""grouped"", result.groupedResults) rsp.getToLog().add(""hits"", grouping.getCommands().get(0).getMatches()) } return } catch (e: jdk.internal.org.jline.reader.SyntaxError) { throw SolrException(SolrException.ErrorCode.BAD_REQUEST, e) } } searcher.search(result, cmd) rb.setResult(result) val ctx = ResultContext() ctx.docs = rb.getResults().docList ctx.query = rb.getQuery() rsp.add(""response"", ctx) rsp.getToLog().add(""hits"", rb.getResults().docList.matches()) if (!rb.req.getParams().getBool(ShardParams.IS_SHARD, false)) { if (null != rb.getNextCursorMark()) { rb.rsp.add( CursorMarkParams.CURSOR_MARK_NEXT, rb.getNextCursorMark().getSerializedTotem() ) } } if (rb.mergeFieldHandler != null) { rb.mergeFieldHandler.handleMergeFields(rb, searcher) } else { doFieldSortValues(rb, searcher) } doPrefetch(rb) }"	Actually run the query
fun addUser(user: IUser?) { if (!this.users.contains(user) && user != null) this.users.add(user) }	CACHES a user to the guild .
"fun create(prefix: String?, doc: Document?): Element? { return SVGOMForeignObjectElement(prefix, doc as javax.swing.text.AbstractDocument?) }"	Creates an instance of the associated element type .